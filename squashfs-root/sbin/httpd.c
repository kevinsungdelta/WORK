/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2017 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

void init_proc();
// int chroot(const char *path);
// char *strcpy(char *dest, const char *src);
// char *asctime(const struct tm *tp);
// int __fastcall setrlimit64(_DWORD, _DWORD); weak
// int __fastcall mkstemp64(_DWORD); weak
// __pid_t waitpid(__pid_t pid, int *stat_loc, int options);
// int ioctl(int fd, unsigned __int32 request, ...);
// int printf(const char *format, ...);
// int connect(int fd, const struct sockaddr *addr, socklen_t len);
// int ungetc(int c, FILE *stream);
// int sigemptyset(sigset_t *set);
// char *strerror(int errnum);
// int inet_pton(int af, const char *cp, void *buf);
// void *memmove(void *dest, const void *src, size_t n);
// int snprintf(char *s, size_t maxlen, const char *format, ...);
// __int32 atol(const char *nptr);
// char *getenv(const char *name);
// int execve(const char *path, char *const argv[], char *const envp[]);
// __pid_t getpid(void);
// int __fastcall fcntl64(_DWORD, _DWORD, _DWORD); weak
// int __fastcall getrlimit64(_DWORD, _DWORD); weak
// void *memcpy(void *dest, const void *src, size_t n);
// void perror(const char *s);
// int dup2(int fd, int fd2);
// int tolower(int c);
// void *malloc(size_t size);
// int remove(const char *filename);
// int sysinfo(struct sysinfo *info);
// int vsnprintf(char *s, size_t maxlen, const char *format, __gnuc_va_list arg);
// ssize_t recvfrom(int fd, void *buf, size_t n, int flags, struct sockaddr *addr, socklen_t *addr_len);
// uintmax_t strtoumax(const char *nptr, char **endptr, int base);
// unsigned __int32 strtoul(const char *nptr, char **endptr, int base);
// int socket(int domain, int type, int protocol);
// int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
// int fflush(FILE *stream);
// int strncasecmp(const char *s1, const char *s2, size_t n);
// int setpgid(__pid_t pid, __pid_t pgid);
// ssize_t send(int fd, const void *buf, size_t n, int flags);
// void freeaddrinfo(struct addrinfo *ai);
// int getnameinfo(const struct sockaddr *sa, socklen_t salen, char *host, socklen_t hostlen, char *serv, socklen_t servlen, unsigned int flags);
// int __fastcall fstat64(_DWORD, _DWORD); weak
// __pid_t getpgrp(void);
// int accept(int fd, struct sockaddr *addr, socklen_t *addr_len);
// char *strrchr(const char *s, int c);
// const char *gai_strerror(int ecode);
// ssize_t write(int fd, const void *buf, size_t n);
// int fprintf(FILE *stream, const char *format, ...);
// int bind(int fd, const struct sockaddr *addr, socklen_t len);
// int __fastcall if_nametoindex(_DWORD); weak
// int __fastcall _deregister_frame_info(_DWORD); weak
// int chdir(const char *path);
// int setsockopt(int fd, int level, int optname, const void *optval, socklen_t optlen);
// __mode_t umask(__mode_t mask);
// ssize_t read(int fd, void *buf, size_t nbytes);
// int strncmp(const char *s1, const char *s2, size_t n);
// char *strncpy(char *dest, const char *src, size_t n);
// int unlink(const char *name);
// int getrusage(__rusage_who_t who, struct rusage *usage);
// int strcasecmp(const char *s1, const char *s2);
// uint32_t htonl(uint32_t hostlong);
// void *realloc(void *ptr, size_t size);
// int listen(int fd, int n);
// char *crypt(const char *key, const char *salt);
// FILE *fdopen(int fd, const char *modes);
// __pid_t fork(void);
// int sigaction(int sig, const struct sigaction *act, struct sigaction *oact);
// char *strdup(const char *s);
// int inet_aton(const char *cp, struct in_addr *inp);
// unsigned __int64 strtoull(const char *nptr, char **endptr, int base);
// int gettimeofday(struct timeval *tv, __timezone_ptr_t tz);
// int getopt(int argc, char *const *argv, const char *shortopts);
// struct tm *localtime(const time_t *timer);
// void *memset(void *s, int c, size_t n);
// int fclose(FILE *stream);
// int __fastcall open64(_DWORD, _DWORD); weak
// char *inet_ntoa(struct in_addr in);
// time_t time(time_t *timer);
// int poll(struct pollfd *fds, nfds_t nfds, int timeout);
// int strcmp(const char *s1, const char *s2);
// int dup(int fd);
// struct passwd *getpwnam(const char *name);
// int fgetc(FILE *stream);
// int sprintf(char *s, const char *format, ...);
// int fputc(int c, FILE *stream);
// const unsigned __int16 **_ctype_b_loc(void);
// int getsockopt(int fd, int level, int optname, void *optval, socklen_t *optlen);
// int getaddrinfo(const char *name, const char *service, const struct addrinfo *req, struct addrinfo **pai);
// int socketpair(int domain, int type, int protocol, int fds[2]);
// size_t strftime(char *s, size_t maxsize, const char *format, const struct tm *tp);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// int *_errno_location(void);
// void exit(int status);
// int atoi(const char *nptr);
// void exit(int status);
// struct tm *gmtime(const time_t *timer);
// size_t strlen(const char *s);
// int __fastcall lseek64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int toupper(int c);
// char *strchr(const char *s, int c);
// int fputs(const char *s, FILE *stream);
// __pid_t setsid(void);
// int __fastcall _register_frame_info(_DWORD, _DWORD); weak
// int close(int fd);
// int vfprintf(FILE *s, const char *format, __gnuc_va_list arg);
// int raise(int sig);
// void free(void *ptr);
// int getsockname(int fd, struct sockaddr *addr, socklen_t *len);
// int __fastcall fopen64(_DWORD, _DWORD); weak
// int __fastcall ftruncate64(_DWORD, _DWORD, _DWORD, _DWORD); weak
void sub_99D4();
int *sub_9A18();
signed int __fastcall sub_9A6C(unsigned __int8 *a1, _BYTE *a2);
bool __fastcall sub_9FE0(const char *a1, const char *a2, int a3);
signed int __fastcall sub_A070(const char *a1, FILE *a2, char *a3, int a4, int a5);
int __fastcall sub_A31C(int a1, int a2, int a3, int a4, int a5);
signed int __fastcall ad_hoc_set_env(char *a1, char *a2, size_t a3, _DWORD *a4);
signed int __fastcall sub_A640(char *a1, int a2, int a3, int a4);
signed int __fastcall sort_of_setenv_2(int a1, int a2);
signed int __fastcall sub_ACB4(int a1, int a2);
signed int __fastcall sub_B4F8(int a1, int a2);
signed int __fastcall sub_B678(int a1, int a2);
void __fastcall sub_B6DC(void **a1);
signed int __fastcall sub_B80C(_DWORD *a1);
signed int __fastcall sub_BCA0(int a1);
signed int __fastcall sub_C058(int a1, char **a2);
signed int __fastcall sub_C0E0(int a1, unsigned __int32 *a2);
signed int __fastcall sub_C18C(int a1, _DWORD *a2);
signed int __fastcall sub_C24C(int a1, _DWORD *a2);
signed int __fastcall sub_C354(int a1, void **a2, _DWORD *a3);
signed int __fastcall sub_C840(int a1, _DWORD *a2, int a3);
signed int __fastcall sub_CA2C(int a1, _DWORD *a2);
int __fastcall sub_CAD0(int a1, int a2);
size_t __fastcall sub_CB34(const char *a1);
signed int __fastcall sub_CBA0(int a1, _DWORD *a2);
signed int __fastcall sub_D764(_DWORD *a1, int a2, int a3);
signed int __fastcall sub_D7F8(_DWORD *a1, int a2, char *a3, int a4);
signed int __fastcall sub_D8F0(int a1, void **a2, int a3);
signed int __fastcall sub_DBC4(int a1, _DWORD *a2);
signed int __fastcall sub_DC84(int a1, _DWORD *a2);
int __fastcall sub_DF30(int a1, _DWORD *a2);
signed int __fastcall sub_E5A0(int a1, unsigned int *a2);
signed int __fastcall sub_E614(int a1, unsigned __int32 *a2);
signed int __fastcall sub_E9B8(int a1);
signed int __fastcall sub_EA70(int a1);
signed int __fastcall sub_EE3C(int a1);
signed int sub_F110();
int *__fastcall sub_F1CC(int *result, int **a2);
_DWORD *__fastcall sub_F28C(_DWORD *result, int *a2);
signed int __fastcall sub_F304(int a1);
int *__fastcall sub_F38C(int *result, int a2);
int __fastcall sub_F420(int a1);
signed int __fastcall sub_F4DC(int a1);
int *__fastcall sub_F5FC(int a1);
int sub_F72C();
int *sub_F798();
int sub_F89C();
unsigned int __fastcall sub_F900(unsigned int result, unsigned int a2);
_DWORD *__fastcall sub_F9A0(int a1);
int __fastcall sub_FAE4(int *a1);
int __fastcall sub_FDB8(int *a1);
signed int __fastcall sub_101DC(int a1);
int *__fastcall sub_103E8(int a1);
int *__fastcall sub_10424(int a1);
signed int __fastcall sub_10658(int a1);
signed int __fastcall sub_109BC(int a1);
signed int __fastcall sub_10AAC(int a1);
int __fastcall sub_10F5C(int a1);
int __fastcall sub_11028(int a1);
signed int sub_111E4();
int *__fastcall sub_1128C(int *result);
int *__fastcall sub_113A0(int *result);
int *sub_11438();
int *__fastcall sub_1153C(int *result, int a2, int a3);
int *sub_115D8();
int *sub_116B8();
void __fastcall sub_11884(int a1, int a2);
int *sub_11AB4();
signed int __fastcall sub_11FA0(int a1);
signed int __fastcall sub_12020(_DWORD *a1, size_t a2);
signed int __fastcall sub_120D0(unsigned int a1);
int __fastcall sub_1233C(FILE *a1);
_DWORD *__fastcall sub_12510(_DWORD *result, _DWORD *a2, _DWORD *a3);
size_t __fastcall sub_125AC(FILE *a1);
signed int __fastcall sub_12808(int a1);
int *sub_12B30();
bool __fastcall sub_12C0C(int a1, int a2, _DWORD *a3);
int __fastcall sub_12CD8(int a1);
bool __fastcall sub_12D04(int a1, int a2, _DWORD *a3);
int __fastcall sub_12DBC(int a1, int a2, _DWORD *a3, signed int a4);
signed int __fastcall sub_12FA4(_BYTE *a1, signed int a2, FILE *a3);
int __fastcall sub_1303C(int a1, int a2, int a3);
int __fastcall sub_1331C(int a1, FILE *a2);
int __fastcall sub_13A78(int a1);
signed int __fastcall sub_13BAC(size_t a1);
_DWORD *__fastcall sub_13C34(_DWORD *result, _DWORD *a2, _DWORD *a3);
int *__fastcall sub_13CC8(int *result);
int __fastcall sub_142EC(const char *a1);
signed int __fastcall sub_143F0(const char *a1, int *a2);
signed int __fastcall sub_14538(int a1);
int *sub_14604(int *result, ...);
int *__fastcall sub_14840(_BYTE *a1);
int __fastcall sub_1490C(int a1, int a2);
void __noreturn sub_14964(char *a1, const char *a2, ...);
int __fastcall sub_14A30(int *a1);
signed int __fastcall sub_15150(int a1, char **a2);
__pid_t __fastcall sub_158C4(int a1, int a2, int a3, char *path, int a5, int a6, int a7, char *patha);
int __fastcall sub_15A18(_DWORD *a1);
signed int __fastcall sub_15C10(unsigned __int8 *a1);
char *__fastcall sub_16324(time_t a1, char *a2);
int __fastcall sub_163B0(int a1, int a2);
int __fastcall sub_16580(char *a1, const char *a2);
int __fastcall sub_16640(char *a1, const char *a2);
signed int __fastcall sub_166D0(_DWORD *a1, const char *a2);
int __fastcall sub_1686C(int result);
signed int __fastcall sub_168F4(int a1, int a2);
signed int __fastcall sub_16998(int a1);
int *__fastcall sub_16CA4(int *result);
signed int __fastcall sub_16EBC(int a1);
int __fastcall sub_17048(int a1);
signed int __fastcall sub_17170(int a1);
signed int __fastcall sub_17358(_DWORD *a1);
signed int __fastcall sub_1738C(int a1);
signed int __fastcall sub_17510(int a1);
signed int __fastcall sub_177AC(int a1);
signed int __fastcall sub_17C00(_DWORD *a1);
signed int __fastcall sub_17D34(int a1);
unsigned int __fastcall sub_17E64(char *a1, unsigned __int8 *a2, int a3, unsigned int a4);
int __fastcall sub_17F74(char *a1, char *a2, int a3, int a4, int a5);
int *__fastcall sub_182E4(_DWORD *a1);
int __fastcall sub_184EC(int a1);
signed int __fastcall sub_18980(int a1, const char *a2);
signed int __fastcall sub_18C88(int a1);
_BYTE *__fastcall sub_18E90(_BYTE *a1, _DWORD *a2);
const char *__fastcall sub_18FD4(int a1, char *a2);
signed int __fastcall sub_190AC(int a1, char *a2);
signed int __fastcall sub_19150(int a1);
signed int __fastcall sub_1A08C(signed int a1);
signed int sub_1A2C0(int a1, const char *a2, ...);
signed int __fastcall sub_1A380(_DWORD *a1);
int __fastcall sub_1ACC4(int result);
signed int __fastcall sub_1AF4C(_DWORD *a1, signed int *a2);
int __fastcall sub_1B0F8(int a1);
signed int __fastcall sub_1B338(int *a1);
signed int __fastcall sub_1B3EC(unsigned __int8 *a1, _BYTE *a2);
signed int __fastcall sub_1B5A8(unsigned __int8 *a1, _BYTE *a2, int a3);
signed int __fastcall sub_1B790(const char *a1);
signed int __fastcall sub_1B89C(const char *a1);
signed int sub_1B958();
signed int sub_1B9DC();
signed int __fastcall sub_1B9FC(int a1, int a2);
signed int __fastcall sub_1C674(int a1);
signed int __fastcall sub_1C8A0(int a1);
signed int __fastcall sub_1CB8C(int a1);
signed int __fastcall sub_1CD88(int a1);
signed int __fastcall sub_1CF18(_DWORD *a1);
_DWORD *__fastcall sub_1D1B0(_DWORD *result);
void **__fastcall sub_1D408(void **result);
bool __fastcall sub_1D49C(int a1);
int *__fastcall sub_1D54C(_DWORD *a1);
int *__fastcall sub_1D868(int a1, int a2);
int __fastcall sub_1DB94(int a1, int *a2);
int __fastcall sub_1E164(signed int a1);
int __fastcall sub_1E230(size_t n, __int16 a2, int a3, void *a4, unsigned __int16 na);
int __fastcall sub_1E2D4(unsigned int a1, FILE *a2);
unsigned int __fastcall sub_1E4B4(unsigned int a1, int a2, unsigned int a3);
signed int __fastcall sub_1E678(signed int a1, __int16 a2, int a3, void *a4, unsigned __int16 a5, FILE *a6);
int __fastcall sub_1E730(signed int a1, __int16 a2, int a3, void *a4, unsigned __int16 a5);
unsigned int __fastcall sub_1ED78(unsigned int result, unsigned int a2);
unsigned int __fastcall sub_1EE20(unsigned int a1, unsigned int a2);
int sub_1EE40();
void term_proc();
// int sprintf(char *s, const char *format, ...);
// size_t strlen(const char *s);
// int toupper(int c);

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_1EE14; // weak
_DWORD algn_2150C[67] =
{
  0,
  31,
  59,
  90,
  120,
  151,
  181,
  212,
  243,
  273,
  304,
  334,
  0,
  31,
  60,
  91,
  121,
  152,
  182,
  213,
  244,
  274,
  305,
  335,
  979650852,
  1769239840,
  744697452,
  774971510,
  840971569,
  791818288,
  841954096,
  925966388,
  976565306,
  1646277681,
  1851878511,
  2017796196,
  2367600,
  979650852,
  1970565920,
  744697442,
  774971510,
  540291377,
  925904946,
  792145967,
  824194864,
  875575862,
  540160314,
  1634496354,
  1159750766,
  606105720,
  0,
  1953066601,
  1768383327,
  1634035807,
  1936876900,
  1970217018,
  1718558836,
  1835363616,
  7959151,
  1914728302,
  544042863,
  1952867692,
  1919903264,
  1414809632,
  1701322832,
  1919247457,
  115
}; // idb
_UNKNOWN unk_215D8; // weak
_UNKNOWN unk_215F8; // weak
_UNKNOWN unk_21618; // weak
int dword_29B48 = 0; // weak
int dword_29E34 = 4294967295; // weak
int dword_29E38 = 4294967295; // weak
int dword_29E3C = 4294967295; // weak
int stdout; // weak
int optarg; // weak
int stdin; // weak
int stderr; // weak
char byte_29E54; // weak
int dword_29E70; // weak
int dword_29E74; // weak
int dword_29E78; // weak
int dword_29E7C; // weak
int dword_29E84; // weak
int dword_29E88; // weak
int dword_29E8C; // weak
int dword_29E94; // weak
int dword_29E9C; // weak
int dword_29EA4; // weak
int dword_29EA8; // weak
int dword_29EAC; // weak
int dword_29EB0; // weak
int dword_29EB4; // weak
int dword_29EB8; // weak
int dword_29EBC; // weak
int dword_29EC0; // weak
int dword_29EC4; // weak
int dword_29EC8; // weak
int dword_29ECC; // weak
int dword_29ED0; // weak
int dword_29ED4; // weak
int dword_29ED8; // weak
int dword_29EDC; // weak
int dword_29EE0; // weak
int dword_29EE4; // weak
int dword_29EE8; // weak
int dword_29EEC; // weak
int dword_29EF0; // weak
int dword_29EF4; // weak
int dword_29EF8; // weak
int dword_29EFC; // weak
int dword_29F00; // weak
int dword_29F04; // weak
int dword_29F08; // weak
int dword_29F0C; // weak
int dword_29F10; // weak
int dword_29F14; // weak
int dword_29F18; // weak
int dword_29F1C; // weak
int dword_29F20; // weak
int dword_29F24; // weak
int dword_29F28; // weak
int dword_29F2C; // weak
int dword_29F30; // weak
int dword_29F34; // weak
int dword_29F38; // weak
int dword_29F3C; // weak
int dword_29F40; // weak
int dword_29F44; // weak
int dword_29F48; // weak
int dword_29F4C; // weak
int dword_29F50; // weak
int dword_29F54; // weak
int dword_29F58; // weak
int dword_29F5C; // weak
int dword_29F60; // weak
int dword_29F64; // weak
int dword_29F68; // weak
int dword_29F6C; // weak
int dword_29F70; // weak
int dword_29F74; // weak
int dword_29F78; // weak
int dword_29F7C; // weak
int dword_29F80; // weak


//----- (0000941C) --------------------------------------------------------
void init_proc()
{
  ;
}

//----- (00009998) --------------------------------------------------------
#error "99A4: positive sp value has been found (funcsize=3)"

//----- (000099D4) --------------------------------------------------------
void sub_99D4()
{
  if ( !byte_29E54 )
    byte_29E54 = 1;
}
// 96BC: using guessed type int __fastcall _deregister_frame_info(_DWORD);
// 29E54: using guessed type char byte_29E54;

//----- (00009A18) --------------------------------------------------------
int *sub_9A18()
{
  return &dword_29B48;
}
// 9938: using guessed type int __fastcall _register_frame_info(_DWORD, _DWORD);
// 29B48: using guessed type int dword_29B48;

//----- (00009A6C) --------------------------------------------------------
signed int __fastcall sub_9A6C(unsigned __int8 *a1, _BYTE *a2)
{
  char v3; // r3
  unsigned __int8 v4; // r3
  unsigned __int8 v5; // r3
  char v6; // r3
  _BYTE *v8; // [sp+0h] [bp-14h]
  _BYTE *v9; // [sp+0h] [bp-14h]
  _BYTE *v10; // [sp+0h] [bp-14h]
  unsigned __int8 *v11; // [sp+4h] [bp-10h]
  unsigned __int8 *v12; // [sp+4h] [bp-10h]
  unsigned __int8 *v13; // [sp+4h] [bp-10h]
  unsigned __int8 *v14; // [sp+4h] [bp-10h]
  char v15; // [sp+Ah] [bp-Ah]
  char v16; // [sp+Bh] [bp-9h]
  char v17; // [sp+Ch] [bp-8h]
  unsigned __int8 v18; // [sp+Dh] [bp-7h]
  char v19; // [sp+Eh] [bp-6h]
  unsigned __int8 v20; // [sp+Eh] [bp-6h]
  unsigned __int8 v21; // [sp+Fh] [bp-5h]
  unsigned __int8 v22; // [sp+Fh] [bp-5h]
  unsigned __int8 v23; // [sp+Fh] [bp-5h]
  unsigned __int8 v24; // [sp+Fh] [bp-5h]

  v11 = a1;
  v8 = a2;
  do
  {
    v21 = *v11;
    v12 = v11 + 1;
    if ( !v21 )
    {
      *v8 = 0;
      return 0;
    }
    if ( v21 <= 0x40u )
    {
      if ( v21 > 0x39u )
      {
        if ( v21 == 61 )
          v3 = 0;
        else
          v3 = 64;
      }
      else if ( v21 <= 0x2Fu )
      {
        if ( v21 == 43 )
        {
          v3 = 62;
        }
        else if ( v21 == 47 )
        {
          v3 = 63;
        }
        else
        {
          v3 = 64;
        }
      }
      else
      {
        v3 = v21 + 4;
      }
    }
    else if ( v21 > 0x5Au )
    {
      if ( v21 <= 0x60u )
      {
        v3 = 64;
      }
      else if ( v21 > 0x7Au )
      {
        v3 = 64;
      }
      else
      {
        v3 = v21 - 71;
      }
    }
    else
    {
      v3 = v21 - 65;
    }
    v19 = v3;
    if ( v3 == 64 )
      return -1;
    v22 = *v12;
    v13 = v12 + 1;
    if ( !v22 )
      return -1;
    if ( v22 <= 0x40u )
    {
      if ( v22 > 0x39u )
      {
        if ( v22 == 61 )
          v4 = 0;
        else
          v4 = 64;
      }
      else if ( v22 <= 0x2Fu )
      {
        if ( v22 == 43 )
        {
          v4 = 62;
        }
        else if ( v22 == 47 )
        {
          v4 = 63;
        }
        else
        {
          v4 = 64;
        }
      }
      else
      {
        v4 = v22 + 4;
      }
    }
    else if ( v22 > 0x5Au )
    {
      if ( v22 <= 0x60u )
      {
        v4 = 64;
      }
      else if ( v22 > 0x7Au )
      {
        v4 = 64;
      }
      else
      {
        v4 = v22 - 71;
      }
    }
    else
    {
      v4 = v22 - 65;
    }
    v18 = v4;
    if ( v4 == 64 )
      return -1;
    v17 = 4 * v19 | (v4 >> 4);
    v23 = *v13;
    v14 = v13 + 1;
    if ( !v23 )
      return -1;
    if ( v23 <= 0x40u )
    {
      if ( v23 > 0x39u )
      {
        if ( v23 == 61 )
          v5 = 0;
        else
          v5 = 64;
      }
      else if ( v23 <= 0x2Fu )
      {
        if ( v23 == 43 )
        {
          v5 = 62;
        }
        else if ( v23 == 47 )
        {
          v5 = 63;
        }
        else
        {
          v5 = 64;
        }
      }
      else
      {
        v5 = v23 + 4;
      }
    }
    else if ( v23 > 0x5Au )
    {
      if ( v23 <= 0x60u )
      {
        v5 = 64;
      }
      else if ( v23 > 0x7Au )
      {
        v5 = 64;
      }
      else
      {
        v5 = v23 - 71;
      }
    }
    else
    {
      v5 = v23 - 65;
    }
    v20 = v5;
    if ( v5 == 64 )
      return -1;
    v16 = 16 * v18 | (v5 >> 2);
    v24 = *v14;
    v11 = v14 + 1;
    if ( !v24 )
      return -1;
    if ( v24 <= 0x40u )
    {
      if ( v24 > 0x39u )
      {
        if ( v24 == 61 )
          v6 = 0;
        else
          v6 = 64;
      }
      else if ( v24 <= 0x2Fu )
      {
        if ( v24 == 43 )
        {
          v6 = 62;
        }
        else if ( v24 == 47 )
        {
          v6 = 63;
        }
        else
        {
          v6 = 64;
        }
      }
      else
      {
        v6 = v24 + 4;
      }
    }
    else if ( v24 > 0x5Au )
    {
      if ( v24 <= 0x60u )
      {
        v6 = 64;
      }
      else if ( v24 > 0x7Au )
      {
        v6 = 64;
      }
      else
      {
        v6 = v24 - 71;
      }
    }
    else
    {
      v6 = v24 - 65;
    }
    if ( v6 == 64 )
      return -1;
    v15 = (v20 << 6) | v6;
    *v8 = v17;
    v9 = v8 + 1;
    if ( !v17 )
      return 0;
    *v9 = v16;
    v10 = v9 + 1;
    if ( !v16 )
      return 0;
    *v10 = v15;
    v8 = v10 + 1;
  }
  while ( v15 );
  return 0;
}

//----- (00009FE0) --------------------------------------------------------
bool __fastcall sub_9FE0(const char *a1, const char *a2, int a3)
{
  _BOOL4 v3; // r3
  char *s1; // [sp+Ch] [bp-10h]
  const char *v6; // [sp+14h] [bp-8h]

  s1 = (char *)a1;
  if ( !a3 )
    return strcmp(a1, a2) == 0;
  v6 = crypt(a2, a1);
  if ( v6 )
    v3 = strcmp(s1, v6) == 0;
  else
    v3 = 0;
  return v3;
}

//----- (0000A070) --------------------------------------------------------
signed int __fastcall sub_A070(const char *a1, FILE *a2, char *a3, int a4, int a5)
{
  signed int v5; // r3
  int v7; // [sp+0h] [bp-12Ch]
  char *dest; // [sp+4h] [bp-128h]
  FILE *stream; // [sp+8h] [bp-124h]
  unsigned __int8 *s; // [sp+Ch] [bp-120h]
  char s1[128]; // [sp+14h] [bp-118h]
  char s2; // [sp+94h] [bp-98h]
  char *v13; // [sp+114h] [bp-18h]
  int v14; // [sp+118h] [bp-14h]
  char *v15; // [sp+11Ch] [bp-10h]
  unsigned int v16; // [sp+120h] [bp-Ch]
  _BOOL4 i; // [sp+124h] [bp-8h]
  char v18[4]; // [sp+128h] [bp-4h]

  s = (unsigned __int8 *)a1;
  stream = a2;
  dest = a3;
  v7 = a4;
  if ( strlen(a1) <= 0x7F )
  {
    if ( sub_9A6C(s, s1) == -1 )
    {
      sub_14604((int *)"could not decode authorization");
      v5 = 0;
    }
    else
    {
      v15 = strchr(s1, 58);
      if ( v15 )
      {
        if ( dest && &s1[v7] <= v15 )
        {
          sub_14604((int *)"supplied username too long");
          v5 = 0;
        }
        else
        {
          *v15++ = 0;
          v16 = 0;
          for ( i = 0; ; i = 0 )
          {
            while ( 1 )
            {
              v14 = fgetc(stream);
              if ( v14 == -1 )
                return 0;
              if ( v14 == 10 )
                break;
              if ( i && v16 <= 0x7F )
                v18[v16++ - 148] = 13;
              i = v14 == 13;
              if ( v14 != 13 && v16 <= 0x7F )
                v18[v16++ - 148] = v14;
            }
            if ( v16 <= 0x7F )
            {
              v18[v16 - 148] = 0;
              v13 = strchr(&s2, 58);
              if ( v13 )
              {
                *v13++ = 0;
                if ( !strcmp(s1, &s2) && sub_9FE0(v13, v15, a5) )
                  break;
              }
            }
            v16 = 0;
          }
          if ( dest )
            strcpy(dest, &s2);
          v5 = 1;
        }
      }
      else
      {
        sub_14604((int *)"no colon in decoded authorization");
        v5 = 0;
      }
    }
  }
  else
  {
    sub_14604((int *)"authorization string too long");
    v5 = 0;
  }
  return v5;
}
// A070: using guessed type char s1[128];
// A070: using guessed type char var_4[4];

//----- (0000A31C) --------------------------------------------------------
int __fastcall sub_A31C(int a1, int a2, int a3, int a4, int a5)
{
  signed int v5; // r3
  signed int v6; // ST1C_4
  int v8; // [sp+8h] [bp-24h]
  char *v9; // [sp+Ch] [bp-20h]
  int v10; // [sp+10h] [bp-1Ch]
  const char *v11; // [sp+14h] [bp-18h]
  FILE *stream; // [sp+20h] [bp-Ch]
  int fd; // [sp+24h] [bp-8h]

  v11 = (const char *)a1;
  v10 = a2;
  v9 = (char *)a3;
  v8 = a4;
  fd = open64(a2, 2048);
  if ( fd == -1 )
  {
    sub_14604((int *)"cannot open userfile %s", v10);
    v5 = 0;
  }
  else
  {
    fcntl64(fd, 2, 1);
    stream = fdopen(fd, "r");
    if ( stream )
    {
      v6 = sub_A070(v11, stream, v9, v8, a5);
      fclose(stream);
      v5 = v6;
    }
    else
    {
      sub_14604((int *)"webuserok: fdopen failed");
      close(fd);
      v5 = 0;
    }
  }
  return v5;
}
// 953C: using guessed type int __fastcall fcntl64(_DWORD, _DWORD, _DWORD);
// 97F4: using guessed type int __fastcall open64(_DWORD, _DWORD);

//----- (0000A3F0) --------------------------------------------------------
signed int __fastcall ad_hoc_set_env(char *a1, char *a2, size_t a3, _DWORD *a4)
{
  char **v5; // r4
  _DWORD *v7; // [sp+0h] [bp-2Ch]
  size_t v8; // [sp+4h] [bp-28h]
  const char *s; // [sp+8h] [bp-24h]
  const char *v10; // [sp+Ch] [bp-20h]
  char *dest; // [sp+10h] [bp-1Ch]
  size_t n; // [sp+14h] [bp-18h]
  void *v13; // [sp+18h] [bp-14h]
  size_t v14; // [sp+1Ch] [bp-10h]

  v10 = a1;
  s = a2;
  v8 = a3;
  v7 = a4;
  if ( a1 && !a2 )
    return 0;
  v13 = realloc((void *)*a4, 4 * (a4[2] + 1));
  if ( v13 )
  {
    *v7 = v13;
    if ( v10 )
    {
      n = strlen(v10);
      v14 = strlen(s);
      if ( v8 )
      {
        if ( v8 >= v14 )
          v14 = 0;
        else
          v14 -= v8;
      }
      dest = (char *)malloc(n + v14 + 2);
      if ( !dest )
      {
        *(_DWORD *)(*v7 + 4 * v7[2]) = 0;
        return -1;
      }
      memcpy(dest, v10, n);
      dest[n] = 61;
      memcpy(&dest[n + 1], s, v14);
      dest[n + 1 + v14] = 0;
      *(_DWORD *)(*v7 + 4 * v7[2]) = dest;
    }
    else if ( s )
    {
      v5 = (char **)(*v7 + 4 * v7[2]);
      *v5 = strdup(s);
      if ( !*v5 )
        return -1;
    }
    else
    {
      *(_DWORD *)(*v7 + 4 * v7[2]) = 0;
    }
    ++v7[2];
    return 0;
  }
  return -1;
}

//----- (0000A640) --------------------------------------------------------
signed int __fastcall sub_A640(char *a1, int a2, int a3, int a4)
{
  size_t v5; // r3
  int v7; // [sp+0h] [bp-24h]
  int v8; // [sp+4h] [bp-20h]
  int v9; // [sp+8h] [bp-1Ch]
  char *s; // [sp+Ch] [bp-18h]
  _BYTE *ptr; // [sp+14h] [bp-10h]
  size_t n; // [sp+18h] [bp-Ch]
  void *v13; // [sp+1Ch] [bp-8h]

  s = a1;
  v9 = a2;
  v8 = a3;
  v7 = a4;
  v13 = realloc(*(void **)(a4 + 4), 4 * (*(_DWORD *)(a4 + 12) + 1));
  if ( v13 )
  {
    *(_DWORD *)(v7 + 4) = v13;
    if ( s )
    {
      if ( v9 )
        v5 = v9 - (_DWORD)s;
      else
        v5 = strlen(s);
      n = v5;
      ptr = malloc(v5 + 1);
      if ( !ptr )
      {
        *(_DWORD *)(*(_DWORD *)(v7 + 4) + 4 * *(_DWORD *)(v7 + 12)) = 0;
        return -1;
      }
      if ( v8 )
      {
        if ( sub_1B5A8((unsigned __int8 *)s, ptr, n) )
        {
          free(ptr);
          *(_DWORD *)(*(_DWORD *)(v7 + 4) + 4 * *(_DWORD *)(v7 + 12)) = 0;
          return -1;
        }
      }
      else
      {
        memcpy(ptr, s, n);
        ptr[n] = 0;
      }
      *(_DWORD *)(*(_DWORD *)(v7 + 4) + 4 * *(_DWORD *)(v7 + 12)) = ptr;
    }
    else
    {
      *(_DWORD *)(*(_DWORD *)(v7 + 4) + 4 * *(_DWORD *)(v7 + 12)) = 0;
    }
    ++*(_DWORD *)(v7 + 12);
    return 0;
  }
  return -1;
}

//----- (0000A810) --------------------------------------------------------
signed int __fastcall sort_of_setenv_2(int a1, int a2)
{
  size_t v3; // r4
  int v5; // [sp+0h] [bp-44h]
  int v6; // [sp+4h] [bp-40h]
  void *v7; // [sp+Ch] [bp-38h]
  char *dest; // [sp+10h] [bp-34h]
  char *s1; // [sp+14h] [bp-30h]
  _DWORD *ptr; // [sp+18h] [bp-2Ch]
  unsigned int v11; // [sp+1Ch] [bp-28h]
  char *s; // [sp+20h] [bp-24h]
  char *sa; // [sp+20h] [bp-24h]
  int v14; // [sp+24h] [bp-20h]
  size_t size; // [sp+28h] [bp-1Ch]
  size_t sizea; // [sp+28h] [bp-1Ch]
  size_t l; // [sp+2Ch] [bp-18h]
  unsigned int k; // [sp+30h] [bp-14h]
  unsigned int m; // [sp+30h] [bp-14h]
  unsigned int i; // [sp+34h] [bp-10h]
  unsigned int j; // [sp+34h] [bp-10h]

  v6 = a1;
  v5 = a2;
  v11 = *(_DWORD *)(a1 + 3436);
  if ( !v11 )
    return 0;
  ptr = malloc(4 * v11);
  if ( !ptr )
    return -1;
  for ( i = 0; i < v11; ++i )
    ptr[i] = 0;
  for ( j = 0; j < v11; ++j )
  {
    if ( !ptr[j] )
    {
      s1 = *(char **)(*(_DWORD *)(v6 + 3440) + 8 * j);
      if ( strcasecmp(*(const char **)(*(_DWORD *)(v6 + 3440) + 8 * j), "Authorization")
        || v6 == -2616
        || !*(_BYTE *)(v6 + 2616) )
      {
        v3 = strlen(s1);
        size = v3 + strlen(*(const char **)(*(_DWORD *)(v6 + 3440) + 8 * j + 4)) + 7;
        for ( k = j + 1; k < v11; ++k )
        {
          if ( !ptr[k] && !strcasecmp(*(const char **)(*(_DWORD *)(v6 + 3440) + 8 * k), s1) )
          {
            ptr[k] = 1;
            size += strlen(*(const char **)(*(_DWORD *)(v6 + 3440) + 8 * k + 4)) + 1;
          }
        }
        dest = (char *)malloc(size);
        if ( !dest )
        {
          free(ptr);
          return -1;
        }
        memcpy(dest, "HTTP_", 5u);
        s = dest + 5;
        sizea = strlen(s1);
        for ( l = 0; l < sizea; ++l )
        {
          v14 = toupper((unsigned __int8)s1[l]);
          if ( v14 == '-' )
            LOBYTE(v14) = '_';
          *s++ = v14;
        }
        sa = &s[sprintf(s, "=%s", *(_DWORD *)(*(_DWORD *)(v6 + 3440) + 8 * j + 4))];
        for ( m = j + 1; m < v11; ++m )
        {
          if ( ptr[m] == 1 )
          {
            sa += sprintf(sa, ",%s", *(_DWORD *)(*(_DWORD *)(v6 + 3440) + 8 * m + 4));
            ptr[m] = 2;
          }
        }
        v7 = realloc(*(void **)v5, 4 * (*(_DWORD *)(v5 + 8) + 1));
        if ( !v7 )
        {
          free(dest);
          free(ptr);
          return -1;
        }
        *(_DWORD *)v5 = v7;
        *(_DWORD *)(*(_DWORD *)v5 + 4 * (*(_DWORD *)(v5 + 8))++) = dest;
      }
    }
  }
  free(ptr);
  return 0;
}

//----- (0000ACB4) --------------------------------------------------------
signed int __fastcall sub_ACB4(int a1, int a2)
{
  signed int v2; // r3
  size_t v3; // r4
  size_t v4; // r0
  size_t v5; // r0
  char *v6; // r4
  char *v7; // r0
  _DWORD *v9; // [sp+8h] [bp-34Ch]
  char *v10; // [sp+Ch] [bp-348h]
  char v11; // [sp+10h] [bp-344h]
  char v12; // [sp+330h] [bp-24h]
  char *s; // [sp+340h] [bp-14h]
  int i; // [sp+344h] [bp-10h]

  v10 = (char *)a1;
  v9 = (_DWORD *)a2;
  if ( sort_of_setenv_2(a1, a2) == -1 )
    return -1;
  if ( ad_hoc_set_env("GATEWAY_INTERFACE", "CGI/1.1", 0, v9) == -1 )
    return -1;
  if ( ad_hoc_set_env("CONTENT_LENGTH", *((char **)v10 + 7), 0, v9) == -1 )
    return -1;
  if ( ad_hoc_set_env("CONTENT_TYPE", *((char **)v10 + 6), 0, v9) == -1 )
    return -1;
  if ( v10 != (char *)-2616 && v10[2616] )
  {
    if ( ad_hoc_set_env("AUTH_TYPE", "Basic", 0, v9) == -1 )
      return -1;
    if ( ad_hoc_set_env("REMOTE_USER", v10 + 2616, 0, v9) == -1 )
      return -1;
  }
  if ( ad_hoc_set_env("SCRIPT_FILENAME", v10 + 0x344, 0, v9) == -1 )
    return -1;
  if ( v10[1636] )
  {
    sub_17F74(v10 + 1636, &v11, (int)v10, 0, 800);
    if ( ad_hoc_set_env("PATH_INFO", v10 + 1636, 0, v9) == -1 )
      return -1;
    if ( ad_hoc_set_env("PATH_TRANSLATED", &v11, 0, v9) == -1 )
      return -1;
  }
  if ( ad_hoc_set_env("QUERY_STRING", *((char **)v10 + 619), 0, v9) == -1 )
    return -1;
  if ( *((_DWORD *)v10 + 619) )
  {
    v3 = strlen(*((const char **)v10 + 618));
    v4 = strlen(*((const char **)v10 + 619));
    s = (char *)malloc(v3 + v4 + 2);
    if ( !s )
      return -1;
    sprintf(s, "%s?%s", *((_DWORD *)v10 + 618), *((_DWORD *)v10 + 619));
    if ( ad_hoc_set_env("REQUEST_URI", s, 0, v9) == -1 )
    {
      free(s);
      return -1;
    }
    free(s);
  }
  else if ( ad_hoc_set_env("REQUEST_URI", *((char **)v10 + 618), 0, v9) == -1 )
  {
    return -1;
  }
  if ( *((_DWORD *)v10 + 864) )
  {
    sprintf(&v12, "%d", *((_DWORD *)v10 + 864));
    if ( ad_hoc_set_env("RANGE", &v12, 0, v9) == -1 )
      return -1;
    sprintf(&v12, "%u", (unsigned int)*((_QWORD *)v10 + 433));
    if ( ad_hoc_set_env("RANGE_FLOOR", &v12, 0, v9) == -1 )
      return -1;
    sprintf(&v12, "%u", (unsigned int)*((_QWORD *)v10 + 434));
    if ( ad_hoc_set_env("RANGE_CEILING", &v12, 0, v9) == -1 )
      return -1;
    sprintf(&v12, "%u", (unsigned int)*((_QWORD *)v10 + 435));
    if ( ad_hoc_set_env("RANGE_SUFFIX", &v12, 0, v9) == -1 )
      return -1;
  }
  if ( ad_hoc_set_env("REMOTE_ADDR", (char *)(*(_DWORD *)v10 + 28), 0, v9) == -1 )
    return -1;
  if ( ad_hoc_set_env("REMOTE_PORT", (char *)(*(_DWORD *)v10 + 86), 0, v9) == -1 )
    return -1;
  if ( ad_hoc_set_env("REQUEST_METHOD", *((char **)v10 + 617), 0, v9) == -1 )
    return -1;
  v5 = strlen(v10 + 1636);
  if ( ad_hoc_set_env("SCRIPT_NAME", v10 + 36, v5, v9) == -1 )
    return -1;
  if ( ad_hoc_set_env("SERVER_NAME", *((char **)v10 + 5), 0, v9) == -1 )
    return -1;
  if ( ad_hoc_set_env("SERVER_ADDR", (char *)(*(_DWORD *)v10 + 92), 0, v9) == -1 )
    return -1;
  if ( ad_hoc_set_env("SERVER_PORT", (char *)(*(_DWORD *)v10 + 150), 0, v9) == -1 )
    return -1;
  if ( ad_hoc_set_env("SERVER_SOFTWARE", "WebServer", 0, v9) == -1 )
    return -1;
  if ( *(_DWORD *)(*(_DWORD *)(*(_DWORD *)v10 + 16) + 64)
    && ad_hoc_set_env("SERVER_ID", *(char **)(*(_DWORD *)(*(_DWORD *)v10 + 16) + 64), 0, v9) == -1 )
  {
    return -1;
  }
  sprintf(&v12, "HTTP/%d.%d", *((_DWORD *)v10 + 621), *((_DWORD *)v10 + 622));
  if ( ad_hoc_set_env("SERVER_PROTOCOL", &v12, 0, v9) == -1 )
    return -1;
  for ( i = *(_DWORD *)(*((_DWORD *)v10 + 625) + 56); i; i = *(_DWORD *)(i + 4) )
  {
    v6 = *(char **)i;
    v7 = getenv(*(const char **)i);
    if ( ad_hoc_set_env(v6, v7, 0, v9) == -1 )
      return -1;
  }
  for ( i = *(_DWORD *)(*((_DWORD *)v10 + 625) + 80); i; i = *(_DWORD *)(i + 4) )
  {
    if ( ad_hoc_set_env(0, *(char **)i, 0, v9) == -1 )
      return -1;
  }
  if ( ad_hoc_set_env(0, 0, 0, v9) == -1 )
    v2 = -1;
  else
    v2 = 0;
  return v2;
}

//----- (0000B4F8) --------------------------------------------------------
signed int __fastcall sub_B4F8(int a1, int a2)
{
  signed int v2; // r3
  int v4; // [sp+0h] [bp-14h]
  int v5; // [sp+4h] [bp-10h]
  char *v6; // [sp+8h] [bp-Ch]
  char *v7; // [sp+8h] [bp-Ch]
  char *s; // [sp+Ch] [bp-8h]
  char *sa; // [sp+Ch] [bp-8h]

  v5 = a1;
  v4 = a2;
  if ( *(_DWORD *)(a1 + 2444) == 3 )
  {
    s = *(char **)(a1 + 2436);
    while ( 1 )
    {
      v6 = strchr(s, 32);
      if ( sub_A640(s, (int)v6, 0, v4) == -1 )
        break;
      if ( v6 )
        s = v6 + 1;
      if ( !v6 )
        goto LABEL_8;
    }
    v2 = -1;
  }
  else
  {
LABEL_8:
    if ( sub_A640((char *)(v5 + 836), 0, 0, v4) == -1 )
    {
      v2 = -1;
    }
    else
    {
      sa = *(char **)(v5 + 2476);
      if ( !sa || strchr(sa, 61) )
      {
LABEL_17:
        if ( sub_A640(0, 0, 0, v4) == -1 )
          v2 = -1;
        else
          v2 = 0;
      }
      else
      {
        while ( 1 )
        {
          v7 = strchr(sa, 43);
          if ( sub_A640(sa, (int)v7, 1, v4) == -1 )
            break;
          if ( v7 )
            sa = v7 + 1;
          if ( !v7 )
            goto LABEL_17;
        }
        v2 = -1;
      }
    }
  }
  return v2;
}

//----- (0000B678) --------------------------------------------------------
signed int __fastcall sub_B678(int a1, int a2)
{
  int v4; // [sp+0h] [bp-Ch]
  int v5; // [sp+4h] [bp-8h]

  v5 = a1;
  v4 = a2;
  if ( sub_ACB4(a1, a2) == -1 )
    return -1;
  if ( sub_B4F8(v5, v4) == -1 )
    return -1;
  return 0;
}

//----- (0000B6DC) --------------------------------------------------------
void __fastcall sub_B6DC(void **a1)
{
  void **v1; // [sp+4h] [bp-10h]
  signed int i; // [sp+Ch] [bp-8h]
  signed int j; // [sp+Ch] [bp-8h]

  v1 = a1;
  if ( *a1 )
  {
    for ( i = 0; (signed int)v1[2] > i; ++i )
    {
      if ( *((_DWORD *)*v1 + i) )
        free(*((void **)*v1 + i));
    }
    free(*v1);
  }
  if ( v1[1] )
  {
    for ( j = 0; (signed int)v1[3] > j; ++j )
    {
      if ( *((_DWORD *)v1[1] + j) )
        free(*((void **)v1[1] + j));
    }
    free(v1[1]);
  }
}

//----- (0000B80C) --------------------------------------------------------
signed int __fastcall sub_B80C(_DWORD *a1)
{
  signed int v1; // r3
  int v2; // r3
  char *v4; // [sp+14h] [bp-70h]
  int fds[2]; // [sp+18h] [bp-6Ch]
  char v6; // [sp+20h] [bp-64h]
  unsigned int v7; // [sp+24h] [bp-60h]
  int v8; // [sp+60h] [bp-24h]
  int v9; // [sp+64h] [bp-20h]
  int v10; // [sp+68h] [bp-1Ch]
  int v11; // [sp+6Ch] [bp-18h]
  __pid_t v12; // [sp+70h] [bp-14h]
  int fd; // [sp+74h] [bp-10h]
  int v14; // [sp+78h] [bp-Ch]
  int v15; // [sp+7Ch] [bp-8h]

  v4 = (char *)a1;
  sysinfo((struct sysinfo *)&v6);
  if ( v7 > 0x3FFFF
    && *(_DWORD *)v4
    && *(_DWORD *)(*(_DWORD *)v4 + 16)
    && *(_DWORD *)(*(_DWORD *)(*(_DWORD *)v4 + 16) + 12)
    && *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)v4 + 16) + 12) + 16) <= 0 )
  {
    if ( dword_29F58 )
      sub_14604((int *)"Http server reject service. (system load = %ld)\n", v7 >> 16);
    *((_DWORD *)v4 + 624) = 500;
    v1 = 0;
  }
  else if ( v4[3920] )
  {
    v2 = *(_DWORD *)(*((_DWORD *)v4 + 625) + 60);
    if ( v2 == 1 )
    {
      v15 = *(_DWORD *)(*((_DWORD *)v4 + 625) + 64);
      v14 = *(_DWORD *)(*((_DWORD *)v4 + 625) + 68);
    }
    else if ( v2 == 2 )
    {
      v15 = *((_DWORD *)v4 + 632);
      v14 = *((_DWORD *)v4 + 633);
    }
    else
    {
      v15 = 0;
      v14 = 0;
    }
    if ( dword_29F68 )
    {
      if ( v15 == dword_29ED4 )
      {
        sub_14604((int *)"cannot run scripts without changing identity");
        *((_DWORD *)v4 + 624) = 500;
        return 0;
      }
      if ( !v15 )
      {
        sub_14604((int *)"ScriptUser or RunScriptsAsOwner must be set");
        *((_DWORD *)v4 + 624) = 500;
        return 0;
      }
    }
    else if ( v15 )
    {
      sub_14604((int *)"root privileges are required to change identity");
      *((_DWORD *)v4 + 624) = 500;
      return 0;
    }
    v10 = 0;
    v8 = 0;
    v11 = 0;
    v9 = 0;
    if ( sub_B678((int)v4, (int)&v8) == -1 )
    {
      sub_14604((int *)"process_cgi: out of memory");
      sub_B6DC((void **)&v8);
      *((_DWORD *)v4 + 624) = 500;
      v1 = 0;
    }
    else if ( socketpair(1, 1, 0, fds) == -1 )
    {
      sub_14840("socketpair");
      sub_B6DC((void **)&v8);
      *((_DWORD *)v4 + 624) = 500;
      v1 = 0;
    }
    else
    {
      fcntl64(fds[0], 2, 1);
      fcntl64(fds[1], 2, 1);
      if ( *(_DWORD *)(*((_DWORD *)v4 + 625) + 52) )
      {
        fd = sub_142EC(*(const char **)(*((_DWORD *)v4 + 625) + 52));
        if ( fd == -1 )
        {
          close(fds[0]);
          close(fds[1]);
          sub_B6DC((void **)&v8);
          *((_DWORD *)v4 + 624) = 500;
          return 0;
        }
        fcntl64(fd, 2, 1);
      }
      else
      {
        fd = -1;
      }
      v12 = sub_158C4(*(_DWORD *)v9, v9, v8, (char *)fds[1], fd, v15, v14, v4 + 3920);
      if ( fd != -1 )
        close(fd);
      close(fds[1]);
      if ( v12 == -1 )
      {
        close(fds[0]);
        sub_B6DC((void **)&v8);
        *(_DWORD *)(*(_DWORD *)v4 + 272) = 0;
        *((_DWORD *)v4 + 624) = 503;
        v1 = 0;
      }
      else
      {
        fcntl64(fds[0], 4, 2048);
        sub_1D868(*(_DWORD *)v4, fds[0]);
        sub_B6DC((void **)&v8);
        if ( dword_29F58 )
          sub_14604((int *)"process_cgi: %d", fds[0]);
        *((_DWORD *)v4 + 1181) = 1;
        v1 = -1;
      }
    }
  }
  else
  {
    *((_DWORD *)v4 + 624) = 500;
    v1 = 0;
  }
  return v1;
}
// 953C: using guessed type int __fastcall fcntl64(_DWORD, _DWORD, _DWORD);
// 29ED4: using guessed type int dword_29ED4;
// 29F58: using guessed type int dword_29F58;
// 29F68: using guessed type int dword_29F68;

//----- (0000BCA0) --------------------------------------------------------
signed int __fastcall sub_BCA0(int a1)
{
  int v2; // [sp+4h] [bp-28h]
  void *v3; // [sp+Ch] [bp-20h]
  size_t size; // [sp+10h] [bp-1Ch]
  signed int c; // [sp+14h] [bp-18h]
  signed int v6; // [sp+18h] [bp-14h]
  char v7; // [sp+1Fh] [bp-Dh]
  int v8; // [sp+20h] [bp-Ch]
  char v9; // [sp+27h] [bp-5h]

  v2 = a1;
  v8 = 0;
  v7 = 1;
  v6 = 128540;
  while ( 2 )
  {
    v9 = 0;
    c = fgetc(*(FILE **)v2);
    if ( c == -1 )
    {
      v7 = 0;
      v6 = 128724;
    }
    else if ( c == 10 )
    {
      ++*(_DWORD *)(v2 + 12);
    }
    switch ( v7 )
    {
      case 1:
        if ( c == 32 )
          goto LABEL_51;
        if ( c > 32 )
        {
          if ( c == 35 )
          {
            v7 = 2;
            goto LABEL_51;
          }
          if ( c > 35 )
          {
            if ( c == 123 )
            {
              v6 = 128748;
              v9 = 1;
              v7 = 0;
              goto LABEL_51;
            }
            if ( c == 125 )
            {
              v6 = 128696;
              v9 = 1;
              v7 = 0;
              goto LABEL_51;
            }
          }
          else if ( c == 34 )
          {
            v6 = 128776;
            v7 = 3;
            goto LABEL_51;
          }
LABEL_25:
          v6 = 128776;
          v9 = 1;
          v7 = 4;
          goto LABEL_51;
        }
        if ( c < 9 || c > 10 && c != 13 )
          goto LABEL_25;
LABEL_51:
        if ( v9 )
        {
          if ( (unsigned int)(v8 + 1) >= *(_DWORD *)(v2 + 8) )
          {
            size = 2 * *(_DWORD *)(v2 + 8);
            v3 = realloc(*(void **)(v2 + 4), 2 * *(_DWORD *)(v2 + 8));
            if ( v3 )
            {
              *(_DWORD *)(v2 + 8) = size;
              *(_DWORD *)(v2 + 4) = v3;
              *(_BYTE *)(*(_DWORD *)(v2 + 4) + v8++) = c;
            }
            else
            {
              v7 = 0;
              v6 = 128600;
            }
          }
          else
          {
            *(_BYTE *)(*(_DWORD *)(v2 + 4) + v8++) = c;
          }
        }
        if ( v7 )
          continue;
        *(_BYTE *)(*(_DWORD *)(v2 + 4) + v8) = 0;
        return v6;
      case 2:
        if ( c == 10 )
          v7 = 1;
        goto LABEL_51;
      case 3:
        if ( c == 92 )
        {
          v7 = 5;
        }
        else if ( c == 34 )
        {
          v7 = 0;
        }
        else
        {
          v9 = 1;
        }
        goto LABEL_51;
      case 4:
        if ( c == 32 )
          goto LABEL_46;
        if ( c > 32 )
        {
          if ( c == 123 )
            goto LABEL_47;
          if ( c > 123 )
          {
            if ( c == 125 )
            {
LABEL_47:
              ungetc(c, *(FILE **)v2);
              v7 = 0;
              goto LABEL_51;
            }
          }
          else if ( (unsigned int)(c - 34) <= 1 )
          {
            goto LABEL_47;
          }
        }
        else if ( c >= 9 && (c <= 10 || c == 13) )
        {
LABEL_46:
          v7 = 0;
          goto LABEL_51;
        }
        v9 = 1;
        goto LABEL_51;
      case 5:
        v9 = 1;
        v7 = 3;
        goto LABEL_51;
      default:
        goto LABEL_51;
    }
  }
}

//----- (0000C058) --------------------------------------------------------
signed int __fastcall sub_C058(int a1, char **a2)
{
  signed int v2; // r3
  char **v4; // [sp+0h] [bp-14h]
  int v5; // [sp+4h] [bp-10h]
  signed int v6; // [sp+Ch] [bp-8h]

  v5 = a1;
  v4 = a2;
  v6 = sub_BCA0(a1);
  if ( v6 != 128776 )
    return v6;
  *v4 = strdup(*(const char **)(v5 + 4));
  if ( *v4 )
    v2 = 0;
  else
    v2 = 128600;
  return v2;
}

//----- (0000C0E0) --------------------------------------------------------
signed int __fastcall sub_C0E0(int a1, unsigned __int32 *a2)
{
  unsigned __int32 *v4; // [sp+0h] [bp-1Ch]
  int v5; // [sp+4h] [bp-18h]
  char *endptr; // [sp+Ch] [bp-10h]
  unsigned __int32 v7; // [sp+10h] [bp-Ch]
  int v8; // [sp+14h] [bp-8h]

  v5 = a1;
  v4 = a2;
  v8 = sub_BCA0(a1);
  if ( v8 != 128776 )
    return v8;
  v7 = strtoul(*(const char **)(v5 + 4), &endptr, 0);
  if ( *endptr || *(char **)(v5 + 4) == endptr )
    return 128564;
  *v4 = v7;
  return 0;
}

//----- (0000C18C) --------------------------------------------------------
signed int __fastcall sub_C18C(int a1, _DWORD *a2)
{
  _DWORD *v4; // [sp+0h] [bp-14h]
  int v5; // [sp+4h] [bp-10h]
  signed int v6; // [sp+Ch] [bp-8h]

  v5 = a1;
  v4 = a2;
  v6 = sub_BCA0(a1);
  if ( v6 == 128776 )
  {
    if ( !strcasecmp(*(const char **)(v5 + 4), "Off") )
    {
      *v4 = 0;
    }
    else
    {
      if ( strcasecmp(*(const char **)(v5 + 4), "On") )
        return 128584;
      *v4 = 1;
    }
    return 0;
  }
  return v6;
}

//----- (0000C24C) --------------------------------------------------------
signed int __fastcall sub_C24C(int a1, _DWORD *a2)
{
  _DWORD *v4; // [sp+0h] [bp-14h]
  int v5; // [sp+4h] [bp-10h]
  _DWORD *v6; // [sp+8h] [bp-Ch]
  signed int v7; // [sp+Ch] [bp-8h]
  signed int v8; // [sp+Ch] [bp-8h]

  v5 = a1;
  v4 = a2;
  v7 = sub_BCA0(a1);
  if ( v7 != 128748 )
    return v7;
  while ( 1 )
  {
    v8 = sub_BCA0(v5);
    if ( v8 == 128696 )
      break;
    if ( v8 != 128776 )
      return v8;
    v6 = malloc(8u);
    if ( !v6 )
      return 128600;
    *v6 = strdup(*(const char **)(v5 + 4));
    if ( !*v6 )
      return 128600;
    v6[1] = *v4;
    *v4 = v6;
  }
  return 0;
}

//----- (0000C354) --------------------------------------------------------
signed int __fastcall sub_C354(int a1, void **a2, _DWORD *a3)
{
  _DWORD *v5; // [sp+4h] [bp-20h]
  void **v6; // [sp+8h] [bp-1Ch]
  int v7; // [sp+Ch] [bp-18h]
  signed int v8; // [sp+10h] [bp-14h]
  signed int v9; // [sp+10h] [bp-14h]
  int v10; // [sp+14h] [bp-10h]
  void *ptr; // [sp+18h] [bp-Ch]
  signed int v12; // [sp+1Ch] [bp-8h]

  v7 = a1;
  v6 = a2;
  v5 = a3;
  ptr = *a2;
  v10 = *a3;
  v8 = sub_BCA0(a1);
  if ( v8 != 128748 )
    return v8;
  while ( 1 )
  {
    v9 = sub_BCA0(v7);
    if ( v9 == 128696 )
      break;
    if ( v9 != 128776 )
      return v9;
    if ( !strcasecmp(*(const char **)(v7 + 4), "Ctime") )
    {
      v12 = 0;
    }
    else if ( !strcasecmp(*(const char **)(v7 + 4), "RemoteUser") )
    {
      v12 = 1;
    }
    else if ( !strcasecmp(*(const char **)(v7 + 4), "RemoteAddress") )
    {
      v12 = 2;
    }
    else if ( !strcasecmp(*(const char **)(v7 + 4), "RemotePort") )
    {
      v12 = 3;
    }
    else if ( !strcasecmp(*(const char **)(v7 + 4), "LocalAddress") )
    {
      v12 = 4;
    }
    else if ( !strcasecmp(*(const char **)(v7 + 4), "LocalPort") )
    {
      v12 = 5;
    }
    else if ( !strcasecmp(*(const char **)(v7 + 4), "ServerName") )
    {
      v12 = 6;
    }
    else if ( !strcasecmp(*(const char **)(v7 + 4), "Method") )
    {
      v12 = 7;
    }
    else if ( !strcasecmp(*(const char **)(v7 + 4), "Uri") )
    {
      v12 = 8;
    }
    else if ( !strcasecmp(*(const char **)(v7 + 4), "Version") )
    {
      v12 = 9;
    }
    else if ( !strcasecmp(*(const char **)(v7 + 4), "Status") )
    {
      v12 = 10;
    }
    else if ( !strcasecmp(*(const char **)(v7 + 4), "ContentLength") )
    {
      v12 = 11;
    }
    else if ( !strcasecmp(*(const char **)(v7 + 4), "Referer") )
    {
      v12 = 12;
    }
    else if ( !strcasecmp(*(const char **)(v7 + 4), "UserAgent") )
    {
      v12 = 13;
    }
    else if ( !strcasecmp(*(const char **)(v7 + 4), "BytesRead") )
    {
      v12 = 14;
    }
    else if ( !strcasecmp(*(const char **)(v7 + 4), "BytesWritten") )
    {
      v12 = 15;
    }
    else if ( !strcasecmp(*(const char **)(v7 + 4), "QueryString") )
    {
      v12 = 16;
    }
    else if ( !strcasecmp(*(const char **)(v7 + 4), "TimeTaken") )
    {
      v12 = 17;
    }
    else if ( !strcasecmp(*(const char **)(v7 + 4), "MicroTime") )
    {
      v12 = 18;
    }
    else
    {
      if ( strcasecmp(*(const char **)(v7 + 4), "PID") )
        return 128584;
      v12 = 19;
    }
    ptr = realloc(ptr, 4 * ++v10);
    if ( !ptr )
      return 128600;
    *((_DWORD *)ptr + v10 - 1) = v12;
    *v6 = ptr;
    *v5 = v10;
  }
  return 0;
}

//----- (0000C840) --------------------------------------------------------
signed int __fastcall sub_C840(int a1, _DWORD *a2, int a3)
{
  int v5; // [sp+4h] [bp-20h]
  _DWORD *v6; // [sp+8h] [bp-1Ch]
  int v7; // [sp+Ch] [bp-18h]
  _DWORD *v8; // [sp+14h] [bp-10h]
  char *v9; // [sp+18h] [bp-Ch]
  signed int v10; // [sp+1Ch] [bp-8h]
  signed int v11; // [sp+1Ch] [bp-8h]
  signed int v12; // [sp+1Ch] [bp-8h]
  signed int v13; // [sp+1Ch] [bp-8h]

  v7 = a1;
  v6 = a2;
  v5 = a3;
  v10 = sub_BCA0(a1);
  if ( v10 != 128748 )
    return v10;
  while ( 1 )
  {
    v13 = sub_BCA0(v7);
    if ( v13 == 128696 )
      break;
    if ( v13 != 128776 )
      return v13;
    v9 = strdup(*(const char **)(v7 + 4));
    if ( !v9 )
      return 128600;
    v11 = sub_BCA0(v7);
    if ( v11 != 128748 )
      return v11;
    while ( 1 )
    {
      v12 = sub_BCA0(v7);
      if ( v12 == 128696 )
        break;
      if ( v12 != 128776 )
        return v12;
      v8 = malloc(0x10u);
      if ( !v8 )
        return 128600;
      *v8 = v5;
      v8[2] = v9;
      if ( !strcasecmp(*(const char **)(v7 + 4), "*") )
      {
        v8[1] = 0;
      }
      else
      {
        v8[1] = strdup(*(const char **)(v7 + 4));
        if ( !v8[1] )
          return 128600;
      }
      v8[3] = *v6;
      *v6 = v8;
    }
  }
  return 0;
}

//----- (0000CA2C) --------------------------------------------------------
signed int __fastcall sub_CA2C(int a1, _DWORD *a2)
{
  _DWORD *v4; // [sp+0h] [bp-14h]
  int v5; // [sp+4h] [bp-10h]
  struct passwd *v6; // [sp+8h] [bp-Ch]
  signed int v7; // [sp+Ch] [bp-8h]

  v5 = a1;
  v4 = a2;
  v7 = sub_BCA0(a1);
  if ( v7 != 128776 )
    return v7;
  v6 = getpwnam(*(const char **)(v5 + 4));
  if ( !v6 )
    return 128664;
  v4[15] = 1;
  v4[16] = v6->pw_uid;
  v4[17] = v6->pw_gid;
  return 0;
}

//----- (0000CAD0) --------------------------------------------------------
int __fastcall sub_CAD0(int a1, int a2)
{
  int v4; // [sp+0h] [bp-14h]
  int v5; // [sp+8h] [bp-Ch]
  int v6; // [sp+Ch] [bp-8h]

  v4 = a2;
  v6 = sub_C18C(a1, &v5);
  if ( v6 )
    return v6;
  if ( v5 )
    *(_DWORD *)(v4 + 60) = 2;
  return 0;
}

//----- (0000CB34) --------------------------------------------------------
size_t __fastcall sub_CB34(const char *a1)
{
  size_t result; // r0
  char *s; // [sp+4h] [bp-10h]
  char *i; // [sp+Ch] [bp-8h]

  s = (char *)a1;
  result = strlen(a1);
  for ( i = &s[result]; --i >= s && *i == 47; *i = 0 )
    ;
  return result;
}

//----- (0000CBA0) --------------------------------------------------------
signed int __fastcall sub_CBA0(int a1, _DWORD *a2)
{
  signed int v2; // r3
  _DWORD *v4; // [sp+0h] [bp-1Ch]
  int v5; // [sp+4h] [bp-18h]
  _DWORD *v6; // [sp+8h] [bp-14h]
  _DWORD *v7; // [sp+Ch] [bp-10h]
  signed int v8; // [sp+10h] [bp-Ch]
  signed int v9; // [sp+10h] [bp-Ch]
  signed int v10; // [sp+10h] [bp-Ch]
  signed int v11; // [sp+10h] [bp-Ch]
  signed int v12; // [sp+10h] [bp-Ch]
  _DWORD *i; // [sp+14h] [bp-8h]

  v5 = a1;
  v4 = a2;
  for ( i = (_DWORD *)*a2; i && i[6]; i = (_DWORD *)i[5] )
    ;
  v7 = malloc(0x68u);
  if ( !v7 )
    return 128600;
  v7[6] = 0;
  *v7 = 0;
  v7[2] = 0;
  v7[19] = 0;
  if ( i )
  {
    v7[3] = i[3];
    v7[4] = i[4];
    v7[1] = i[1];
    v7[7] = i[7];
    v7[8] = i[8];
    v7[9] = i[9];
    v7[10] = i[10];
    v7[11] = i[11];
    v7[12] = i[12];
    v7[13] = i[13];
    v7[14] = i[14];
    v7[15] = i[15];
    v7[16] = i[16];
    v7[17] = i[17];
    v7[18] = i[18];
    v7[20] = i[20];
    v7[21] = i[21];
    v7[22] = i[22];
    v7[23] = i[23];
    v7[24] = i[24];
    v7[25] = i[25];
  }
  else
  {
    v7[3] = 0;
    v7[4] = 0;
    v7[1] = 0;
    v7[7] = 0;
    v7[8] = 0;
    v7[9] = 0;
    v7[10] = 0;
    v7[11] = 0;
    v7[12] = 0;
    v7[13] = 0;
    v7[14] = 0;
    v7[15] = 0;
    v7[16] = 0;
    v7[17] = 0;
    v7[18] = 0;
    v7[20] = 0;
    v7[21] = 0;
    v7[22] = 0;
    v7[23] = 0;
    v7[24] = 0;
    v7[25] = 0;
  }
  v7[5] = *v4;
  *v4 = v7;
  v8 = sub_BCA0(v5);
  if ( v8 != 128748 )
    return v8;
  while ( 1 )
  {
    v12 = sub_BCA0(v5);
    if ( v12 == 128696 )
      break;
    if ( v12 != 128776 )
      return v12;
    if ( !strcasecmp(*(const char **)(v5 + 4), "Location") )
    {
      v6 = malloc(8u);
      if ( !v6 )
        return 128600;
      v9 = sub_BCA0(v5);
      if ( v9 != 128776 )
        return v9;
      sub_CB34(*(const char **)(v5 + 4));
      *v6 = strdup(*(const char **)(v5 + 4));
      if ( !*v6 )
        return 128600;
      if ( v7[6] )
      {
        v6[1] = *(_DWORD *)(v7[6] + 4);
        *(_DWORD *)(v7[6] + 4) = v6;
      }
      else
      {
        v6[1] = v6;
        v7[6] = v6;
      }
    }
    else if ( !strcasecmp(*(const char **)(v5 + 4), "Alias") )
    {
      v10 = sub_BCA0(v5);
      if ( v10 != 128776 )
        return v10;
      sub_CB34(*(const char **)(v5 + 4));
      *v7 = strdup(*(const char **)(v5 + 4));
      if ( !*v7 )
        return 128600;
    }
    else
    {
      if ( !strcasecmp(*(const char **)(v5 + 4), "PathArgs") )
      {
        v11 = sub_C18C(v5, v7 + 1);
      }
      else if ( !strcasecmp(*(const char **)(v5 + 4), "IndexNames") )
      {
        v11 = sub_C24C(v5, v7 + 3);
      }
      else if ( !strcasecmp(*(const char **)(v5 + 4), "Types") )
      {
        v11 = sub_C840(v5, v7 + 4, 1);
      }
      else if ( !strcasecmp(*(const char **)(v5 + 4), "Specials") )
      {
        v11 = sub_C840(v5, v7 + 4, 2);
      }
      else if ( !strcasecmp(*(const char **)(v5 + 4), "External") )
      {
        v11 = sub_C840(v5, v7 + 4, 3);
      }
      else if ( !strcasecmp(*(const char **)(v5 + 4), "Admin") )
      {
        v11 = sub_C058(v5, (char **)v7 + 7);
      }
      else if ( !strcasecmp(*(const char **)(v5 + 4), "Realm") )
      {
        v11 = sub_C058(v5, (char **)v7 + 8);
      }
      else if ( !strcasecmp(*(const char **)(v5 + 4), "UserFile") )
      {
        v11 = sub_C058(v5, (char **)v7 + 9);
      }
      else if ( !strcasecmp(*(const char **)(v5 + 4), "Error401File") )
      {
        v11 = sub_C058(v5, (char **)v7 + 10);
      }
      else if ( !strcasecmp(*(const char **)(v5 + 4), "Error404File") )
      {
        v11 = sub_C058(v5, (char **)v7 + 11);
      }
      else if ( !strcasecmp(*(const char **)(v5 + 4), "EncryptedUserFile") )
      {
        v11 = sub_C18C(v5, v7 + 12);
      }
      else if ( !strcasecmp(*(const char **)(v5 + 4), "ChildLog") )
      {
        v11 = sub_C058(v5, (char **)v7 + 13);
      }
      else if ( !strcasecmp(*(const char **)(v5 + 4), "Export") )
      {
        v11 = sub_C24C(v5, v7 + 14);
      }
      else if ( !strcasecmp(*(const char **)(v5 + 4), "ExactMatch") )
      {
        v11 = sub_C18C(v5, v7 + 2);
      }
      else if ( !strcasecmp(*(const char **)(v5 + 4), "ScriptUser") )
      {
        v11 = sub_CA2C(v5, v7);
      }
      else if ( !strcasecmp(*(const char **)(v5 + 4), "RunScriptsAsOwner") )
      {
        v11 = sub_CAD0(v5, (int)v7);
      }
      else if ( !strcasecmp(*(const char **)(v5 + 4), "AllowDotfiles") )
      {
        v11 = sub_C18C(v5, v7 + 18);
      }
      else if ( !strcasecmp(*(const char **)(v5 + 4), "UserDirectory") )
      {
        v11 = sub_C18C(v5, v7 + 19);
      }
      else if ( !strcasecmp(*(const char **)(v5 + 4), "PutEnv") )
      {
        v11 = sub_C24C(v5, v7 + 20);
      }
      else if ( !strcasecmp(*(const char **)(v5 + 4), "ExtraHeaders") )
      {
        v11 = sub_C24C(v5, v7 + 21);
      }
      else if ( !strcasecmp(*(const char **)(v5 + 4), "PathInfo") )
      {
        v11 = sub_C18C(v5, v7 + 22);
      }
      else if ( !strcasecmp(*(const char **)(v5 + 4), "AutoIndexCommand") )
      {
        v11 = sub_C058(v5, (char **)v7 + 23);
      }
      else if ( !strcasecmp(*(const char **)(v5 + 4), "ExpireInterval") )
      {
        v11 = sub_C0E0(v5, v7 + 24);
      }
      else if ( !strcasecmp(*(const char **)(v5 + 4), "SanitizePath") )
      {
        v11 = sub_C18C(v5, v7 + 25);
      }
      else if ( !strcasecmp(*(const char **)(v5 + 4), "AlphaTCPNodelay") )
      {
        v11 = sub_C18C(v5, &dword_29EC8);
      }
      else
      {
        v11 = 128584;
      }
      if ( v11 )
        return v11;
    }
  }
  if ( !*v7 || v7[6] )
    v2 = 0;
  else
    v2 = 128508;
  return v2;
}
// 29EC8: using guessed type int dword_29EC8;

//----- (0000D764) --------------------------------------------------------
signed int __fastcall sub_D764(_DWORD *a1, int a2, int a3)
{
  int v5; // [sp+4h] [bp-18h]
  int v6; // [sp+8h] [bp-14h]
  _DWORD *v7; // [sp+Ch] [bp-10h]
  _DWORD *s; // [sp+14h] [bp-8h]

  v7 = a1;
  v6 = a2;
  v5 = a3;
  s = malloc(0x14u);
  if ( !s )
    return 128600;
  memset(s, 0, 0x14u);
  s[2] = v6;
  s[1] = *v7;
  s[4] = v5;
  *v7 = s;
  return 0;
}

//----- (0000D7F8) --------------------------------------------------------
signed int __fastcall sub_D7F8(_DWORD *a1, int a2, char *a3, int a4)
{
  int v6; // [sp+0h] [bp-1Ch]
  const char *v7; // [sp+4h] [bp-18h]
  int v8; // [sp+8h] [bp-14h]
  const char **v9; // [sp+Ch] [bp-10h]
  const char **s; // [sp+14h] [bp-8h]

  v9 = (const char **)a1;
  v8 = a2;
  v7 = a3;
  v6 = a4;
  s = (const char **)malloc(0x14u);
  if ( s )
  {
    memset(s, 0, 0x14u);
    if ( v7 )
    {
      *s = strdup(v7);
      if ( !*s )
        return 128600;
      sub_1B89C(*s);
    }
    else
    {
      *s = 0;
    }
    s[2] = (const char *)v8;
    s[1] = *v9;
    s[3] = (const char *)v6;
    *v9 = (const char *)s;
    return 0;
  }
  return 128600;
}

//----- (0000D8F0) --------------------------------------------------------
signed int __fastcall sub_D8F0(int a1, void **a2, int a3)
{
  int v5; // [sp+4h] [bp-20h]
  void **v6; // [sp+8h] [bp-1Ch]
  int v7; // [sp+Ch] [bp-18h]
  int v8; // [sp+10h] [bp-14h]
  void *s; // [sp+14h] [bp-10h]
  _DWORD *v10; // [sp+18h] [bp-Ch]
  int v11; // [sp+1Ch] [bp-8h]

  v7 = a1;
  v6 = a2;
  v5 = a3;
  s = malloc(8u);
  if ( s )
  {
    memset(s, 0, 8u);
    if ( v5 )
    {
      *(_DWORD *)s = *(_DWORD *)(v5 + 16);
      v10 = (_DWORD *)(v5 + 12);
    }
    else
    {
      *(_DWORD *)s = dword_29E74;
      v10 = &dword_29E78;
    }
    *((_DWORD *)s + 1) = *v6;
    *v6 = s;
    v11 = sub_BCA0(v7);
    if ( v11 != 128748 )
      return v11;
    while ( 1 )
    {
      while ( 1 )
      {
        v11 = sub_BCA0(v7);
        if ( v11 == 128696 )
          return 0;
        if ( v11 != 128776 )
          return v11;
        if ( !strcasecmp(*(const char **)(v7 + 4), "Host") )
        {
          v11 = sub_BCA0(v7);
          if ( v11 != 128776 )
            return v11;
          v11 = sub_D7F8(v10, (int)s, *(char **)(v7 + 4), 0);
          goto LABEL_23;
        }
        if ( strcasecmp(*(const char **)(v7 + 4), "Priority") )
          break;
        v8 = -1;
        v11 = sub_C0E0(v7, (unsigned __int32 *)&v8);
        v11 = sub_D764(v10, (int)s, v8);
LABEL_23:
        if ( v11 )
          return v11;
      }
      if ( !strcasecmp(*(const char **)(v7 + 4), "NoHost") )
      {
        v11 = sub_D7F8(v10, (int)s, 0, 0);
        goto LABEL_23;
      }
      if ( !strcasecmp(*(const char **)(v7 + 4), "Control") )
      {
        v11 = sub_CBA0(v7, s);
        goto LABEL_23;
      }
      if ( strcasecmp(*(const char **)(v7 + 4), "AnyHost") )
      {
        v11 = 128584;
        goto LABEL_23;
      }
      v11 = sub_D7F8(v10, (int)s, 0, 1);
    }
  }
  return 128600;
}
// 29E74: using guessed type int dword_29E74;
// 29E78: using guessed type int dword_29E78;

//----- (0000DBC4) --------------------------------------------------------
signed int __fastcall sub_DBC4(int a1, _DWORD *a2)
{
  _DWORD *v4; // [sp+0h] [bp-14h]
  int v5; // [sp+4h] [bp-10h]
  signed int v6; // [sp+Ch] [bp-8h]

  v5 = a1;
  v4 = a2;
  v6 = sub_BCA0(a1);
  if ( v6 == 128776 )
  {
    if ( !strcasecmp(*(const char **)(v5 + 4), "inet") )
    {
      *v4 = 2;
    }
    else
    {
      if ( strcasecmp(*(const char **)(v5 + 4), "inet6") )
        return 128828;
      *v4 = 10;
    }
    return 0;
  }
  return v6;
}

//----- (0000DC84) --------------------------------------------------------
signed int __fastcall sub_DC84(int a1, _DWORD *a2)
{
  _DWORD *v4; // [sp+0h] [bp-2Ch]
  int v5; // [sp+4h] [bp-28h]
  int v6; // [sp+8h] [bp-24h]
  int v7; // [sp+Ch] [bp-20h]
  _DWORD *v8; // [sp+10h] [bp-1Ch]
  _DWORD *v9; // [sp+14h] [bp-18h]
  int v10; // [sp+18h] [bp-14h]
  int v11; // [sp+1Ch] [bp-10h]
  int v12; // [sp+20h] [bp-Ch]
  int v13; // [sp+24h] [bp-8h]

  v5 = a1;
  v4 = a2;
  v13 = sub_BCA0(a1);
  if ( v13 != 128748 )
    return v13;
  while ( 1 )
  {
    v13 = sub_BCA0(v5);
    if ( v13 == 128696 )
      break;
    if ( !strcasecmp(*(const char **)(v5 + 4), "rcvbuf") )
    {
      v12 = 1;
      v11 = 8;
      v10 = 1;
    }
    else if ( !strcasecmp(*(const char **)(v5 + 4), "sndbuf") )
    {
      v12 = 1;
      v11 = 7;
      v10 = 1;
    }
    else if ( !strcasecmp(*(const char **)(v5 + 4), "v6only") )
    {
      v12 = 41;
      v11 = 26;
      v10 = 0;
    }
    else
    {
      if ( strcasecmp(*(const char **)(v5 + 4), "nodelay") )
        return 128884;
      v12 = 6;
      v11 = 1;
      v10 = 0;
    }
    if ( v10 )
    {
      if ( v10 == 1 )
        v13 = sub_C0E0(v5, (unsigned __int32 *)&v6);
    }
    else
    {
      v13 = sub_C18C(v5, &v7);
    }
    if ( v13 )
      return v13;
    v9 = malloc(0x14u);
    if ( !v9 )
      return 128600;
    v8 = malloc(4u);
    if ( !v8 )
      return 128600;
    if ( v10 )
    {
      if ( v10 == 1 )
        *v8 = v6;
    }
    else
    {
      *v8 = v7;
    }
    *v9 = v12;
    v9[1] = v11;
    v9[2] = v8;
    v9[3] = 4;
    v9[4] = *v4;
    *v4 = v9;
  }
  return 0;
}

//----- (0000DF30) --------------------------------------------------------
int __fastcall sub_DF30(int a1, _DWORD *a2)
{
  signed int v2; // r3
  signed int v3; // r3
  FILE *v4; // r7
  signed int v5; // r4
  int v6; // r6
  const char *v7; // r0
  void *v8; // r0
  _DWORD *v10; // [sp+8h] [bp-5Ch]
  int v11; // [sp+Ch] [bp-58h]
  struct in_addr inp; // [sp+10h] [bp-54h]
  int v13; // [sp+14h] [bp-50h]
  int v14; // [sp+18h] [bp-4Ch]
  struct addrinfo *pai; // [sp+1Ch] [bp-48h]
  int s; // [sp+20h] [bp-44h]
  int v17; // [sp+24h] [bp-40h]
  int v18; // [sp+28h] [bp-3Ch]
  int v19; // [sp+2Ch] [bp-38h]
  int ecode; // [sp+40h] [bp-24h]
  void *v21; // [sp+44h] [bp-20h]
  char *cp; // [sp+48h] [bp-1Ch]
  int v23; // [sp+4Ch] [bp-18h]

  v11 = a1;
  v10 = a2;
  v13 = 0;
  v21 = malloc(0x44u);
  if ( !v21 )
    return 128600;
  *((_DWORD *)v21 + 3) = dword_29E78;
  *((_DWORD *)v21 + 7) = dword_29EC4;
  *((_DWORD *)v21 + 4) = dword_29E74;
  *((_DWORD *)v21 + 8) = 128;
  *((_DWORD *)v21 + 9) = 0;
  *((_DWORD *)v21 + 10) = strdup("80");
  *((_DWORD *)v21 + 15) = 0;
  *((_DWORD *)v21 + 16) = 0;
  if ( !*((_DWORD *)v21 + 10) )
    return 128600;
  *((_DWORD *)v21 + 14) = 0;
  v14 = 0;
  v23 = sub_BCA0(v11);
  if ( v23 != 128748 )
    return v23;
  while ( 1 )
  {
    v23 = sub_BCA0(v11);
    if ( v23 == 128696 )
      break;
    if ( v23 != 128776 )
      return v23;
    if ( !strcasecmp(*(const char **)(v11 + 4), "Port") )
    {
      v23 = sub_C058(v11, (char **)v21 + 10);
LABEL_32:
      if ( v23 )
        return v23;
    }
    else
    {
      if ( !strcasecmp(*(const char **)(v11 + 4), "Address") )
      {
        v23 = sub_C058(v11, (char **)v21 + 9);
        goto LABEL_32;
      }
      if ( !strcasecmp(*(const char **)(v11 + 4), "Virtual") )
      {
        v23 = sub_D8F0(v11, (void **)v21 + 7, (int)v21);
        goto LABEL_32;
      }
      if ( !strcasecmp(*(const char **)(v11 + 4), "Control") )
      {
        v23 = sub_CBA0(v11, (_DWORD *)v21 + 4);
        goto LABEL_32;
      }
      if ( !strcasecmp(*(const char **)(v11 + 4), "Backlog") )
      {
        v23 = sub_C0E0(v11, (unsigned __int32 *)v21 + 8);
        goto LABEL_32;
      }
      if ( !strcasecmp(*(const char **)(v11 + 4), "Family") )
      {
        v23 = sub_DBC4(v11, &v14);
        goto LABEL_32;
      }
      if ( !strcasecmp(*(const char **)(v11 + 4), "Options") )
      {
        v23 = sub_DC84(v11, (_DWORD *)v21 + 14);
        goto LABEL_32;
      }
      if ( !strcasecmp(*(const char **)(v11 + 4), "Interface") )
      {
        v23 = sub_C058(v11, (char **)v21 + 15);
        goto LABEL_32;
      }
      if ( strcasecmp(*(const char **)(v11 + 4), "ServerName") )
      {
        if ( !strcasecmp(*(const char **)(v11 + 4), "ServerId") )
        {
          v23 = sub_C058(v11, (char **)v21 + 16);
        }
        else if ( !strcasecmp(*(const char **)(v11 + 4), "Datagrams") )
        {
          v23 = sub_C18C(v11, &v13);
        }
        else
        {
          v23 = 128584;
        }
        goto LABEL_32;
      }
      v23 = sub_BCA0(v11);
    }
  }
  memset(&s, 0, 0x20u);
  s = 1;
  v17 = v14;
  if ( v13 )
    v3 = 2;
  else
    v3 = 1;
  v18 = v3;
  v19 = 0;
  cp = (char *)*((_DWORD *)v21 + 9);
  if ( v13 )
  {
    if ( cp )
    {
      inet_aton(cp, &inp);
      if ( (htonl(inp.s_addr) & 0xF0000000) == -536870912 )
        cp = 0;
    }
  }
  ecode = getaddrinfo(cp, *((const char **)v21 + 10), (const struct addrinfo *)&s, &pai);
  if ( ecode )
  {
    v4 = (FILE *)stderr;
    if ( *((_DWORD *)v21 + 9) )
      v5 = *((_DWORD *)v21 + 9);
    else
      v5 = 128984;
    v6 = *((_DWORD *)v21 + 10);
    v7 = gai_strerror(ecode);
    fprintf(v4, "address %s port %s: %s\n", v5, v6, v7);
    v2 = 128616;
  }
  else
  {
    v8 = malloc(pai->ai_addrlen);
    *((_DWORD *)v21 + 2) = v8;
    if ( *((_DWORD *)v21 + 2) )
    {
      *((_DWORD *)v21 + 11) = pai->ai_family;
      *((_DWORD *)v21 + 12) = pai->ai_socktype;
      *((_DWORD *)v21 + 13) = pai->ai_protocol;
      memcpy(*((void **)v21 + 2), pai->ai_addr, pai->ai_addrlen);
      *((_DWORD *)v21 + 1) = pai->ai_addrlen;
      freeaddrinfo(pai);
      ++dword_29E70;
      *((_DWORD *)v21 + 5) = *v10;
      *v10 = v21;
      v2 = 0;
    }
    else
    {
      freeaddrinfo(pai);
      v2 = 128600;
    }
  }
  return v2;
}
// 29E50: using guessed type int stderr;
// 29E70: using guessed type int dword_29E70;
// 29E74: using guessed type int dword_29E74;
// 29E78: using guessed type int dword_29E78;
// 29EC4: using guessed type int dword_29EC4;

//----- (0000E5A0) --------------------------------------------------------
signed int __fastcall sub_E5A0(int a1, unsigned int *a2)
{
  unsigned int *v4; // [sp+0h] [bp-14h]
  unsigned int v5; // [sp+8h] [bp-Ch]
  int v6; // [sp+Ch] [bp-8h]

  v4 = a2;
  v6 = sub_C0E0(a1, &v5);
  if ( v6 )
    return v6;
  if ( v5 > 0x40 )
    return 128680;
  *v4 = v5;
  return 0;
}

//----- (0000E614) --------------------------------------------------------
signed int __fastcall sub_E614(int a1, unsigned __int32 *a2)
{
  unsigned __int32 *v4; // [sp+0h] [bp-14h]
  int v5; // [sp+4h] [bp-10h]
  signed int v6; // [sp+Ch] [bp-8h]
  signed int v7; // [sp+Ch] [bp-8h]
  signed int v8; // [sp+Ch] [bp-8h]

  v5 = a1;
  v4 = a2;
  v6 = sub_BCA0(a1);
  if ( v6 != 128748 )
    return v6;
  while ( 1 )
  {
    v8 = sub_BCA0(v5);
    if ( v8 == 128696 )
      break;
    if ( v8 != 128776 )
      return v8;
    if ( !strcasecmp(*(const char **)(v5 + 4), "Timeout") )
    {
      v7 = sub_C0E0(v5, v4 + 3);
    }
    else if ( !strcasecmp(*(const char **)(v5 + 4), "BufSize") )
    {
      v7 = sub_C0E0(v5, v4);
    }
    else if ( !strcasecmp(*(const char **)(v5 + 4), "InputBufSize") )
    {
      v7 = sub_C0E0(v5, v4 + 1);
    }
    else if ( !strcasecmp(*(const char **)(v5 + 4), "NumConnections") )
    {
      v7 = sub_C0E0(v5, v4 + 2);
    }
    else if ( !strcasecmp(*(const char **)(v5 + 4), "AcceptMulti") )
    {
      v7 = sub_C18C(v5, v4 + 4);
    }
    else if ( !strcasecmp(*(const char **)(v5 + 4), "NumHeaders") )
    {
      v7 = sub_C0E0(v5, v4 + 5);
    }
    else if ( !strcasecmp(*(const char **)(v5 + 4), "ScriptTimeout") )
    {
      v7 = sub_C0E0(v5, v4 + 6);
    }
    else if ( !strcasecmp(*(const char **)(v5 + 4), "ScriptBufSize") )
    {
      v7 = sub_C0E0(v5, v4 + 7);
    }
    else if ( !strcasecmp(*(const char **)(v5 + 4), "Clobber") )
    {
      v7 = sub_C18C(v5, v4 + 8);
    }
    else if ( !strcasecmp(*(const char **)(v5 + 4), "Wait") )
    {
      v7 = sub_C0E0(v5, v4 + 9);
    }
    else if ( !strcasecmp(*(const char **)(v5 + 4), "NumProcesses") )
    {
      v7 = sub_E5A0(v5, v4 + 10);
    }
    else if ( !strcasecmp(*(const char **)(v5 + 4), "Greedy") )
    {
      v7 = sub_C18C(v5, v4 + 11);
    }
    else
    {
      v7 = 128584;
    }
    if ( v7 )
      return v7;
  }
  return 0;
}

//----- (0000E9B8) --------------------------------------------------------
signed int __fastcall sub_E9B8(int a1)
{
  int v3; // [sp+4h] [bp-10h]
  struct passwd *v4; // [sp+8h] [bp-Ch]
  signed int v5; // [sp+Ch] [bp-8h]

  v3 = a1;
  v5 = sub_BCA0(a1);
  if ( v5 != 128776 )
    return v5;
  v4 = getpwnam(*(const char **)(v3 + 4));
  if ( !v4 )
    return 128664;
  if ( !v4->pw_uid )
    return 128648;
  dword_29ED4 = v4->pw_uid;
  dword_29F20 = v4->pw_gid;
  return 0;
}
// 29ED4: using guessed type int dword_29ED4;
// 29F20: using guessed type int dword_29F20;

//----- (0000EA70) --------------------------------------------------------
signed int __fastcall sub_EA70(int a1)
{
  signed int i; // r0
  int v4; // [sp+4h] [bp-10h]
  signed int v5; // [sp+Ch] [bp-8h]

  v4 = a1;
  for ( i = sub_BCA0(a1); i != 128724; i = sub_BCA0(v4) )
  {
    if ( i != 128776 )
      return i;
    if ( !strcasecmp(*(const char **)(v4 + 4), "RootDirectory") )
    {
      v5 = sub_C058(v4, (char **)&dword_29F18);
    }
    else if ( !strcasecmp(*(const char **)(v4 + 4), "CoreDirectory") )
    {
      v5 = sub_C058(v4, (char **)&dword_29EE4);
    }
    else if ( !strcasecmp(*(const char **)(v4 + 4), "Umask") )
    {
      v5 = sub_C0E0(v4, (unsigned __int32 *)&dword_29F5C);
    }
    else if ( !strcasecmp(*(const char **)(v4 + 4), "StayRoot") )
    {
      v5 = sub_C18C(v4, &dword_29F74);
    }
    else if ( !strcasecmp(*(const char **)(v4 + 4), "User") )
    {
      v5 = sub_E9B8(v4);
    }
    else if ( !strcasecmp(*(const char **)(v4 + 4), "PIDFile") )
    {
      v5 = sub_C058(v4, (char **)&dword_29ED0);
    }
    else if ( !strcasecmp(*(const char **)(v4 + 4), "Log") )
    {
      v5 = sub_C058(v4, (char **)&dword_29EE0);
    }
    else if ( !strcasecmp(*(const char **)(v4 + 4), "ErrorLog") )
    {
      v5 = sub_C058(v4, (char **)&dword_29F1C);
    }
    else if ( !strcasecmp(*(const char **)(v4 + 4), "Tuning") )
    {
      v5 = sub_E614(v4, (unsigned __int32 *)&dword_29EE8);
    }
    else if ( !strcasecmp(*(const char **)(v4 + 4), "Control") )
    {
      v5 = sub_CBA0(v4, &dword_29E74);
    }
    else if ( !strcasecmp(*(const char **)(v4 + 4), "Server") )
    {
      v5 = sub_DF30(v4, &dword_29EC0);
    }
    else if ( !strcasecmp(*(const char **)(v4 + 4), "LogFormat") )
    {
      v5 = sub_C354(v4, (void **)&dword_29ECC, &dword_29EDC);
    }
    else if ( !strcasecmp(*(const char **)(v4 + 4), "LogGMT") )
    {
      v5 = sub_C18C(v4, &dword_29ED8);
    }
    else if ( !strcasecmp(*(const char **)(v4 + 4), "Virtual") )
    {
      v5 = sub_D8F0(v4, (void **)&dword_29EC4, 0);
    }
    else
    {
      v5 = 128584;
    }
    if ( v5 )
      return v5;
  }
  return 0;
}
// 29E74: using guessed type int dword_29E74;
// 29EC0: using guessed type int dword_29EC0;
// 29EC4: using guessed type int dword_29EC4;
// 29ECC: using guessed type int dword_29ECC;
// 29ED0: using guessed type int dword_29ED0;
// 29ED8: using guessed type int dword_29ED8;
// 29EDC: using guessed type int dword_29EDC;
// 29EE0: using guessed type int dword_29EE0;
// 29EE4: using guessed type int dword_29EE4;
// 29EE8: using guessed type int dword_29EE8;
// 29F18: using guessed type int dword_29F18;
// 29F1C: using guessed type int dword_29F1C;
// 29F5C: using guessed type int dword_29F5C;
// 29F74: using guessed type int dword_29F74;

//----- (0000EE3C) --------------------------------------------------------
signed int __fastcall sub_EE3C(int a1)
{
  int v1; // r3
  int v3; // [sp+4h] [bp-20h]
  FILE *stream; // [sp+Ch] [bp-18h]
  void *ptr; // [sp+10h] [bp-14h]
  size_t size; // [sp+14h] [bp-10h]
  int v7; // [sp+18h] [bp-Ch]
  int v8; // [sp+1Ch] [bp-8h]

  v3 = a1;
  size = 64;
  ptr = malloc(0x40u);
  if ( !ptr )
    return 128600;
  if ( v3 )
  {
    stream = (FILE *)fopen64(v3, 128992);
    if ( !stream )
    {
      fprintf((FILE *)stderr, "Cannot open configuration file %s\n", v3);
      free(ptr);
      return 128636;
    }
  }
  else
  {
    stream = (FILE *)stdin;
  }
  dword_29EE8 = 12288;
  dword_29EEC = 2048;
  dword_29EF0 = 64;
  dword_29EF4 = 60;
  dword_29EF8 = 1;
  dword_29EFC = 100;
  dword_29F00 = 60;
  dword_29F04 = 4096;
  dword_29F08 = 1;
  dword_29F0C = 60;
  dword_29F10 = 1;
  dword_29F14 = 1;
  dword_29F5C = 18;
  dword_29F74 = 0;
  dword_29EDC = 0;
  dword_29ECC = 0;
  dword_29ED8 = 0;
  v7 = 1;
  v8 = sub_EA70((int)&stream);
  if ( v3 )
    fclose(stream);
  if ( v8 )
  {
    if ( v3 )
      fprintf((FILE *)stderr, "In configuration file: %s\n", v3);
    fprintf((FILE *)stderr, "Error at token '%s' around line %d\n", ptr, v7);
    free(ptr);
    v1 = v8;
  }
  else
  {
    free(ptr);
    if ( !dword_29ECC )
    {
      dword_29ECC = 171520;
      dword_29EDC = 13;
    }
    v1 = 0;
  }
  return v1;
}
// 9980: using guessed type int __fastcall fopen64(_DWORD, _DWORD);
// 29E4C: using guessed type int stdin;
// 29E50: using guessed type int stderr;
// 29ECC: using guessed type int dword_29ECC;
// 29ED8: using guessed type int dword_29ED8;
// 29EDC: using guessed type int dword_29EDC;
// 29EE8: using guessed type int dword_29EE8;
// 29EEC: using guessed type int dword_29EEC;
// 29EF0: using guessed type int dword_29EF0;
// 29EF4: using guessed type int dword_29EF4;
// 29EF8: using guessed type int dword_29EF8;
// 29EFC: using guessed type int dword_29EFC;
// 29F00: using guessed type int dword_29F00;
// 29F04: using guessed type int dword_29F04;
// 29F08: using guessed type int dword_29F08;
// 29F0C: using guessed type int dword_29F0C;
// 29F10: using guessed type int dword_29F10;
// 29F14: using guessed type int dword_29F14;
// 29F5C: using guessed type int dword_29F5C;
// 29F74: using guessed type int dword_29F74;

//----- (0000F110) --------------------------------------------------------
signed int sub_F110()
{
  if ( sub_11FA0(2 * dword_29EF0 + dword_29E70) == -1 )
    return -1;
  if ( sub_120D0(dword_29EF0) == -1 )
    return -1;
  if ( sub_13BAC(dword_29EEC + 1000) == -1 )
    return -1;
  if ( sub_1B958() == -1 )
    return -1;
  return 0;
}
// 29E70: using guessed type int dword_29E70;
// 29EEC: using guessed type int dword_29EEC;
// 29EF0: using guessed type int dword_29EF0;

//----- (0000F1CC) --------------------------------------------------------
int *__fastcall sub_F1CC(int *result, int **a2)
{
  int *v2; // [sp+8h] [bp-Ch]
  int *v3; // [sp+Ch] [bp-8h]

  v3 = (int *)result[1];
  v2 = (int *)*result;
  if ( v3 )
    *v3 = (int)v2;
  if ( v2 )
    v2[1] = (int)v3;
  result[1] = 0;
  *result = 0;
  if ( *a2 == result )
    *a2 = v2;
  if ( a2[1] == result )
    a2[1] = v3;
  return result;
}

//----- (0000F28C) --------------------------------------------------------
_DWORD *__fastcall sub_F28C(_DWORD *result, int *a2)
{
  int v2; // [sp+Ch] [bp-8h]

  v2 = *a2;
  result[1] = 0;
  *result = v2;
  if ( v2 )
    *(_DWORD *)(v2 + 4) = result;
  else
    a2[1] = (int)result;
  *a2 = (int)result;
  return result;
}

//----- (0000F304) --------------------------------------------------------
signed int __fastcall sub_F304(int a1)
{
  signed int v1; // r3

  switch ( a1 )
  {
    case 1:
      v1 = 171644;
      break;
    case 2:
      v1 = 171676;
      break;
    case 3:
      v1 = 171660;
      break;
    case 4:
      v1 = 171668;
      break;
    case 5:
      v1 = 171652;
      break;
    default:
      v1 = 0;
      break;
  }
  return v1;
}

//----- (0000F38C) --------------------------------------------------------
int *__fastcall sub_F38C(int *result, int a2)
{
  int v2; // [sp+0h] [bp-1Ch]
  int *v3; // [sp+4h] [bp-18h]
  int *v4; // [sp+Ch] [bp-10h]
  int **v5; // [sp+10h] [bp-Ch]
  int v6; // [sp+14h] [bp-8h]

  v3 = result;
  v2 = a2;
  v6 = result[2];
  if ( a2 != v6 )
  {
    v5 = (int **)sub_F304(v6);
    result = (int *)sub_F304(v2);
    v4 = result;
    if ( v5 )
      result = sub_F1CC(v3, v5);
    v3[2] = v2;
    if ( v4 )
      result = sub_F28C(v3, v4);
  }
  return result;
}

//----- (0000F420) --------------------------------------------------------
int __fastcall sub_F420(int a1)
{
  int v1; // ST04_4

  v1 = a1;
  *(_BYTE *)(a1 + 180) = 0;
  *(_DWORD *)(v1 + 204) = *(_DWORD *)(v1 + 188);
  *(_DWORD *)(a1 + 196) = *(_DWORD *)(a1 + 204);
  sub_1ACC4(*(_DWORD *)(a1 + 12));
  *(_DWORD *)(v1 + 272) = 0;
  *(_QWORD *)(v1 + 288) = 0LL;
  *(_QWORD *)(v1 + 296) = 0LL;
  *(_QWORD *)(v1 + 304) = 0LL;
  *(_DWORD *)(v1 + 376) = 0;
  return gettimeofday((struct timeval *)(v1 + 316), 0);
}

//----- (0000F4DC) --------------------------------------------------------
signed int __fastcall sub_F4DC(int a1)
{
  signed int v1; // r3
  int *v3; // [sp+4h] [bp-10h]
  int v4; // [sp+Ch] [bp-8h]

  v3 = (int *)a1;
  ++dword_29F34;
  sub_13CC8(*(int **)(a1 + 12));
  v3[78] = 1;
  if ( v3[6] != -1 )
  {
    close(v3[6]);
    v3[6] = -1;
  }
  sub_F420((int)v3);
  sub_F38C(v3, 5);
  v4 = v3[43];
  if ( v3[44] == v4 )
  {
    v3[44] = v3[40];
    v3[43] = v3[44];
    v3[42] = v3[43];
    v1 = 0;
  }
  else
  {
    ++dword_29F44;
    v3[42] = v4;
    v1 = sub_10AAC((int)v3);
  }
  return v1;
}
// 29F34: using guessed type int dword_29F34;
// 29F44: using guessed type int dword_29F44;

//----- (0000F5FC) --------------------------------------------------------
int *__fastcall sub_F5FC(int a1)
{
  int *v2; // [sp+4h] [bp-8h]

  v2 = (int *)a1;
  if ( *(_QWORD *)(a1 + 288) || *(_QWORD *)(a1 + 296) || !*(_DWORD *)(a1 + 312) )
  {
    ++dword_29F34;
    sub_13CC8(*(int **)(a1 + 12));
  }
  --dword_29F2C;
  if ( dword_29F58 )
    sub_14604((int *)"close_connection: %d", v2[5]);
  if ( *(_DWORD *)(v2[4] + 48) != 2 )
    close(v2[5]);
  if ( v2[6] != -1 )
  {
    close(v2[6]);
    v2[6] = -1;
  }
  return sub_F38C(v2, 1);
}
// 29F2C: using guessed type int dword_29F2C;
// 29F34: using guessed type int dword_29F34;
// 29F58: using guessed type int dword_29F58;

//----- (0000F72C) --------------------------------------------------------
int sub_F72C()
{
  int result; // r0
  int *i; // [sp+4h] [bp-8h]

  for ( i = (int *)dword_29EC0; i; i = (int *)i[5] )
  {
    if ( *i != -1 )
    {
      result = close(*i);
      *i = -1;
    }
  }
  return result;
}
// 29EC0: using guessed type int dword_29EC0;

//----- (0000F798) --------------------------------------------------------
int *sub_F798()
{
  _DWORD *v0; // ST00_4
  int *result; // r0
  _DWORD *v2; // ST00_4
  _DWORD *v3; // ST00_4
  _DWORD *v4; // ST00_4
  _DWORD *i; // [sp+4h] [bp-8h]
  _DWORD *j; // [sp+4h] [bp-8h]
  _DWORD *k; // [sp+4h] [bp-8h]
  _DWORD *l; // [sp+4h] [bp-8h]

  for ( i = (_DWORD *)dword_29E84; i; i = v0 )
  {
    v0 = (_DWORD *)*i;
    result = sub_F5FC((int)i);
  }
  for ( j = (_DWORD *)dword_29E8C; j; j = v2 )
  {
    v2 = (_DWORD *)*j;
    result = sub_F5FC((int)j);
  }
  for ( k = (_DWORD *)dword_29E94; k; k = v3 )
  {
    v3 = (_DWORD *)*k;
    result = sub_F5FC((int)k);
  }
  for ( l = (_DWORD *)dword_29E9C; l; l = v4 )
  {
    v4 = (_DWORD *)*l;
    result = sub_F5FC((int)l);
  }
  return result;
}
// 29E84: using guessed type int dword_29E84;
// 29E8C: using guessed type int dword_29E8C;
// 29E94: using guessed type int dword_29E94;
// 29E9C: using guessed type int dword_29E9C;

//----- (0000F89C) --------------------------------------------------------
int sub_F89C()
{
  if ( dword_29E7C )
    return dword_29E7C;
  if ( dword_29F08 )
    return dword_29E88;
  return 0;
}
// 29E7C: using guessed type int dword_29E7C;
// 29E88: using guessed type int dword_29E88;
// 29F08: using guessed type int dword_29F08;

//----- (0000F900) --------------------------------------------------------
unsigned int __fastcall sub_F900(unsigned int result, unsigned int a2)
{
  int v2; // r1
  _DWORD *v3; // [sp+4h] [bp-10h]
  unsigned int v4; // [sp+Ch] [bp-8h]

  v3 = (_DWORD *)result;
  v4 = *(_DWORD *)(result + 24);
  if ( a2 && a2 < v4 )
  {
    result = sub_1EE20(v4, a2);
    v4 -= v2;
  }
  if ( dword_29F58 )
    result = (unsigned int)sub_14604((int *)"pool_adjust: n=%zu", v4);
  v3[1] = *v3 + v4;
  return result;
}
// 29F58: using guessed type int dword_29F58;

//----- (0000F9A0) --------------------------------------------------------
_DWORD *__fastcall sub_F9A0(int a1)
{
  _DWORD *i; // [sp+Ch] [bp-8h]
  _DWORD *j; // [sp+Ch] [bp-8h]
  _DWORD *k; // [sp+Ch] [bp-8h]
  _DWORD *l; // [sp+Ch] [bp-8h]

  for ( i = (_DWORD *)dword_29E84; i; i = (_DWORD *)*i )
  {
    if ( i[5] == a1 )
      return i;
  }
  for ( j = (_DWORD *)dword_29E8C; j; j = (_DWORD *)*j )
  {
    if ( j[5] == a1 )
      return j;
  }
  for ( k = (_DWORD *)dword_29E94; k; k = (_DWORD *)*k )
  {
    if ( k[5] == a1 )
      return k;
  }
  for ( l = (_DWORD *)dword_29E9C; l; l = (_DWORD *)*l )
  {
    if ( l[5] == a1 )
      return l;
  }
  return 0;
}
// 29E84: using guessed type int dword_29E84;
// 29E8C: using guessed type int dword_29E8C;
// 29E94: using guessed type int dword_29E94;
// 29E9C: using guessed type int dword_29E9C;

//----- (0000FAE4) --------------------------------------------------------
int __fastcall sub_FAE4(int *a1)
{
  const char *v1; // r0
  int *v3; // [sp+14h] [bp-18h]
  socklen_t len; // [sp+18h] [bp-14h]
  int ecode; // [sp+1Ch] [bp-10h]
  int fd; // [sp+20h] [bp-Ch]
  int v7; // [sp+24h] [bp-8h]

  v3 = a1;
  if ( !sub_F9A0(*a1) )
  {
    v7 = sub_F89C();
    if ( v7 )
    {
      fd = *v3;
      ++dword_29F40;
      if ( dword_29F58 )
        sub_14604((int *)"%s: %d", 130296, fd);
      fcntl64(fd, 2, 1);
      fcntl64(fd, 4, 2048);
      if ( *(_DWORD *)(v7 + 8) != 1 )
      {
        if ( dword_29F58 )
          sub_14604((int *)"%s: clobbering connection to %s[%s]", 130296, v7 + 28, v7 + 86);
        sub_F5FC(v7);
      }
      len = 128;
      if ( getsockname(fd, (struct sockaddr *)(v7 + 508), &len) == -1 )
      {
        sub_14840("getsockname");
      }
      else
      {
        ecode = getnameinfo(
                  (const struct sockaddr *)(v7 + 508),
                  len,
                  (char *)(v7 + 92),
                  0x3Au,
                  (char *)(v7 + 150),
                  6u,
                  3u);
        if ( ecode )
        {
          v1 = gai_strerror(ecode);
          sub_14604((int *)"%s: getnameinfo failed for sock: %s", 130296, v1);
        }
        else
        {
          *(_DWORD *)(v7 + 16) = v3;
          *(_DWORD *)(v7 + 20) = fd;
          *(_DWORD *)(v7 + 24) = -1;
          *(_DWORD *)(v7 + 156) = dword_29F24;
          *(_DWORD *)(v7 + 276) = -1;
          if ( ++dword_29F2C > dword_29F30 )
            dword_29F30 = dword_29F2C;
          sub_F420(v7);
          *(_DWORD *)(v7 + 312) = 0;
          *(_DWORD *)(v7 + 176) = *(_DWORD *)(v7 + 160);
          *(_DWORD *)(v7 + 172) = *(_DWORD *)(v7 + 176);
          *(_DWORD *)(v7 + 168) = *(_DWORD *)(v7 + 172);
          sub_F38C((int *)v7, 5);
        }
      }
    }
  }
  return 0;
}
// 953C: using guessed type int __fastcall fcntl64(_DWORD, _DWORD, _DWORD);
// 29F24: using guessed type int dword_29F24;
// 29F2C: using guessed type int dword_29F2C;
// 29F30: using guessed type int dword_29F30;
// 29F40: using guessed type int dword_29F40;
// 29F58: using guessed type int dword_29F58;

//----- (0000FDB8) --------------------------------------------------------
int __fastcall sub_FDB8(int *a1)
{
  int v2; // r3
  const char *v3; // r0
  const char *v4; // r0
  int *v6; // [sp+14h] [bp-120h]
  unsigned int optval; // [sp+1Ch] [bp-118h]
  socklen_t addr_len; // [sp+20h] [bp-114h]
  struct sockaddr sa; // [sp+24h] [bp-110h]
  struct sockaddr addr; // [sp+A4h] [bp-90h]
  int ecode; // [sp+124h] [bp-10h]
  int fd; // [sp+128h] [bp-Ch]
  int v13; // [sp+12Ch] [bp-8h]

  v6 = a1;
  if ( a1[12] == 2 )
    return sub_FAE4(a1);
  while ( 1 )
  {
    v13 = sub_F89C();
    if ( !v13 )
      return 0;
    addr_len = 128;
    fd = accept(*v6, &addr, &addr_len);
    if ( fd == -1 )
      break;
    ++dword_29F40;
    if ( dword_29F58 )
      sub_14604((int *)"accept_connection: %d", fd);
    fcntl64(fd, 2, 1);
    fcntl64(fd, 4, 2048);
    if ( *(_DWORD *)(v13 + 8) != 1 )
    {
      if ( dword_29F58 )
        sub_14604((int *)"clobbering connection to %s[%s]", v13 + 28, v13 + 86);
      sub_F5FC(v13);
    }
    ecode = getnameinfo(&addr, addr_len, (char *)(v13 + 28), 0x3Au, (char *)(v13 + 86), 6u, 3u);
    if ( ecode )
    {
      v3 = gai_strerror(ecode);
      sub_14604((int *)"accept_connection: getnameinfo failed for peer: %s", v3);
      close(fd);
      return 0;
    }
    addr_len = 128;
    if ( getsockname(fd, &sa, &addr_len) == -1 )
    {
      sub_14840("getsockname");
      close(fd);
      return 0;
    }
    ecode = getnameinfo(&sa, addr_len, (char *)(v13 + 92), 0x3Au, (char *)(v13 + 150), 6u, 3u);
    if ( ecode )
    {
      v4 = gai_strerror(ecode);
      sub_14604((int *)"accept_connection: getnameinfo failed for sock: %s", v4);
      close(fd);
      return 0;
    }
    addr_len = 4;
    if ( getsockopt(fd, 6, 2, &optval, &addr_len) == -1 )
    {
      sub_14840("getsockopt");
      close(fd);
      return 0;
    }
    *(_DWORD *)(v13 + 16) = v6;
    *(_DWORD *)(v13 + 20) = fd;
    *(_DWORD *)(v13 + 24) = -1;
    *(_DWORD *)(v13 + 156) = dword_29F24;
    *(_DWORD *)(v13 + 276) = -1;
    if ( ++dword_29F2C > dword_29F30 )
      dword_29F30 = dword_29F2C;
    sub_F900(v13 + 188, optval);
    sub_F420(v13);
    *(_DWORD *)(v13 + 312) = 0;
    *(_DWORD *)(v13 + 176) = *(_DWORD *)(v13 + 160);
    *(_DWORD *)(v13 + 172) = *(_DWORD *)(v13 + 176);
    *(_DWORD *)(v13 + 168) = *(_DWORD *)(v13 + 172);
    sub_F38C((int *)v13, 5);
LABEL_29:
    if ( !dword_29EF8 )
      return 0;
  }
  v2 = *_errno_location();
  if ( v2 == 71 || v2 == 103 )
  {
    sub_14840("accept");
    goto LABEL_29;
  }
  if ( v2 == 11 )
    return 0;
  sub_14840("accept");
  return -1;
}
// 953C: using guessed type int __fastcall fcntl64(_DWORD, _DWORD, _DWORD);
// 29EF8: using guessed type int dword_29EF8;
// 29F24: using guessed type int dword_29F24;
// 29F2C: using guessed type int dword_29F2C;
// 29F30: using guessed type int dword_29F30;
// 29F40: using guessed type int dword_29F40;
// 29F58: using guessed type int dword_29F58;

//----- (000101DC) --------------------------------------------------------
signed int __fastcall sub_101DC(int a1)
{
  signed int v1; // r3
  signed __int64 v2; // ST18_8
  signed int v3; // r3
  int v5; // [sp+Ch] [bp-20h]
  ssize_t v6; // [sp+10h] [bp-1Ch]
  signed int nbytes; // [sp+14h] [bp-18h]
  _DWORD *v8; // [sp+24h] [bp-8h]

  v5 = a1;
  if ( *(_DWORD *)(a1 + 24) == -1 )
    return 0;
  v8 = (_DWORD *)(a1 + 188);
  v2 = *(_QWORD *)(a1 + 304);
  if ( v2 <= *(_DWORD *)(a1 + 192) - *(_DWORD *)(a1 + 204) )
    v3 = *(_QWORD *)(a1 + 304);
  else
    v3 = *(_DWORD *)(a1 + 192) - *(_DWORD *)(a1 + 204);
  nbytes = v3;
  if ( v3 <= 0 )
    return 0;
  *(_QWORD *)(a1 + 304) -= v3;
  v6 = read(*(_DWORD *)(a1 + 24), *(void **)(a1 + 204), v3);
  if ( dword_29F58 )
    sub_14604((int *)"fill_connection: %d %zd %d %d", *(_DWORD *)(v5 + 24), v8[4] - *v8, nbytes, v6);
  if ( v6 == nbytes )
  {
    v8[4] += nbytes;
    *(_QWORD *)(v5 + 368) += nbytes;
    v1 = nbytes;
  }
  else
  {
    if ( v6 == -1 )
      sub_14840("read");
    else
      sub_14604((int *)"premature end of file %s", *(_DWORD *)(v5 + 12) + 836);
    v1 = -1;
  }
  return v1;
}
// 29F58: using guessed type int dword_29F58;

//----- (000103E8) --------------------------------------------------------
int *__fastcall sub_103E8(int a1)
{
  int *result; // r0

  if ( *(_DWORD *)(a1 + 272) )
    result = (int *)sub_F4DC(a1);
  else
    result = sub_F5FC(a1);
  return result;
}

//----- (00010424) --------------------------------------------------------
int *__fastcall sub_10424(int a1)
{
  int *result; // r0
  int v2; // [sp+Ch] [bp-18h]
  int v3; // [sp+14h] [bp-10h]
  signed int n; // [sp+18h] [bp-Ch]
  ssize_t v5; // [sp+1Ch] [bp-8h]

  v2 = a1;
  v3 = a1 + 188;
  while ( 1 )
  {
    n = *(_DWORD *)(v3 + 16) - *(_DWORD *)(v3 + 8);
    if ( *(_DWORD *)(v3 + 16) == *(_DWORD *)(v3 + 8) )
    {
      *(_DWORD *)(v3 + 16) = *(_DWORD *)v3;
      *(_DWORD *)(v3 + 8) = *(_DWORD *)(v3 + 16);
      n = sub_101DC(v2);
      if ( n == -1 )
        return sub_F5FC(v2);
      if ( !n )
        return sub_103E8(v2);
    }
    if ( *(_DWORD *)(*(_DWORD *)(v2 + 16) + 48) == 2 )
    {
      v5 = n;
      sub_14604((int *)"%s: ignore the response to [%s]", 130276, v2 + 92);
    }
    else
    {
      v5 = write(*(_DWORD *)(v2 + 20), *(const void **)(v3 + 8), n);
    }
    if ( dword_29F58 )
      sub_14604(
        (int *)"write_connection: %d %zd %d %d",
        *(_DWORD *)(v2 + 20),
        *(_DWORD *)(v3 + 8) - *(_DWORD *)v3,
        n,
        v5);
    if ( v5 == -1 )
      break;
    *(_DWORD *)(v2 + 156) = dword_29F24;
    result = (int *)v2;
    *(_QWORD *)(v2 + 296) += v5;
    *(_DWORD *)(v3 + 8) += v5;
    if ( n != v5 || !dword_29F14 )
      return result;
  }
  result = _errno_location();
  if ( *result != 11 )
  {
    if ( dword_29F58 )
      sub_14840("write");
    result = sub_F5FC(v2);
  }
  return result;
}
// 29F14: using guessed type int dword_29F14;
// 29F24: using guessed type int dword_29F24;
// 29F58: using guessed type int dword_29F58;

//----- (00010658) --------------------------------------------------------
signed int __fastcall sub_10658(int a1)
{
  signed int v1; // r3
  const char *v2; // r0
  int v4; // [sp+14h] [bp-20h]
  socklen_t salen; // [sp+18h] [bp-1Ch]
  int ecode; // [sp+1Ch] [bp-18h]
  size_t n; // [sp+20h] [bp-14h]
  int v8; // [sp+24h] [bp-10h]
  ssize_t v9; // [sp+28h] [bp-Ch]
  size_t nbytes; // [sp+2Ch] [bp-8h]

  v4 = a1;
  nbytes = *(_DWORD *)(a1 + 164) - *(_DWORD *)(a1 + 176);
  if ( !nbytes )
  {
    v8 = *(_DWORD *)(a1 + 168) - *(_DWORD *)(a1 + 160);
    if ( !v8 )
    {
      sub_14604((int *)"input buffer full");
      sub_F5FC(v4);
      return -1;
    }
    n = *(_DWORD *)(a1 + 176) - *(_DWORD *)(a1 + 168);
    memmove(*(void **)(a1 + 160), *(const void **)(a1 + 168), n);
    *(_DWORD *)(v4 + 168) -= v8;
    *(_DWORD *)(v4 + 172) -= v8;
    *(_DWORD *)(v4 + 176) -= v8;
    nbytes = *(_DWORD *)(v4 + 164) - *(_DWORD *)(v4 + 176);
  }
  if ( *(_DWORD *)(*(_DWORD *)(v4 + 16) + 48) == 2 )
  {
    salen = 128;
    v9 = recvfrom(*(_DWORD *)(v4 + 20), *(void **)(v4 + 176), nbytes, 0, (struct sockaddr *)(v4 + 380), &salen);
    if ( v9 )
    {
      ecode = getnameinfo(
                (const struct sockaddr *)(v4 + 380),
                salen,
                (char *)(v4 + 28),
                0x3Au,
                (char *)(v4 + 86),
                6u,
                3u);
      if ( ecode )
      {
        v2 = gai_strerror(ecode);
        sub_14604((int *)"read_connection: unable to get peer info: %s", v2);
        sub_F5FC(v4);
        return -1;
      }
    }
  }
  else
  {
    v9 = read(*(_DWORD *)(v4 + 20), *(void **)(v4 + 176), nbytes);
  }
  if ( dword_29F58 )
    sub_14604(
      (int *)"read_connection: %d %zd %zu %zd",
      *(_DWORD *)(v4 + 20),
      *(_DWORD *)(v4 + 176) - *(_DWORD *)(v4 + 160),
      nbytes,
      v9);
  if ( v9 == -1 )
  {
    if ( *_errno_location() == 11 )
    {
      v1 = 0;
    }
    else
    {
      if ( dword_29F58 )
        sub_14840("read");
      sub_F5FC(v4);
      v1 = -1;
    }
  }
  else if ( v9 )
  {
    *(_QWORD *)(v4 + 288) += v9;
    *(_DWORD *)(v4 + 176) += v9;
    *(_DWORD *)(v4 + 156) = dword_29F24;
    v1 = 0;
  }
  else
  {
    sub_F5FC(v4);
    v1 = -1;
  }
  return v1;
}
// 29F24: using guessed type int dword_29F24;
// 29F58: using guessed type int dword_29F58;

//----- (000109BC) --------------------------------------------------------
signed int __fastcall sub_109BC(int a1)
{
  signed int v1; // r3
  int v2; // r1
  int v4; // [sp+Ch] [bp-8h]

  v4 = a1;
  if ( *(_DWORD *)(a1 + 24) == -1 )
  {
    *(_QWORD *)(a1 + 304) = 0LL;
    v1 = 0;
  }
  else
  {
    *(_DWORD *)(a1 + 376) = 1;
    *(_QWORD *)(a1 + 304) = *(_QWORD *)(*(_DWORD *)(a1 + 12) + 2448);
    if ( *(_QWORD *)(a1 + 368)
      && lseek64(*(_DWORD *)(a1 + 24), *(_DWORD *)(a1 + 24), *(_QWORD *)(a1 + 368), *(_QWORD *)(a1 + 368) >> 32, 0) == -1
      && v2 == -1 )
    {
      sub_14840("lseek");
      v1 = -1;
    }
    else
    {
      v1 = sub_101DC(v4);
    }
  }
  return v1;
}
// 98FC: using guessed type int __fastcall lseek64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00010AAC) --------------------------------------------------------
signed int __fastcall sub_10AAC(int a1)
{
  int v3; // [sp+4h] [bp-18h]
  signed int v4; // [sp+Ch] [bp-10h]
  signed int v5; // [sp+10h] [bp-Ch]
  unsigned __int8 *v6; // [sp+14h] [bp-8h]

  v3 = a1;
  v6 = *(unsigned __int8 **)(a1 + 172);
  v5 = *(unsigned __int8 *)(a1 + 180);
LABEL_55:
  while ( v5 != 8 && *(_DWORD *)(v3 + 176) > (unsigned int)v6 )
  {
    v4 = *v6++;
    if ( !v4 )
    {
      sub_14604((int *)"read_connection: NUL in headers");
      sub_F5FC(v3);
      return -1;
    }
    switch ( v5 )
    {
      case 0:
        switch ( v4 )
        {
          case 9:
          case 32:
            v5 = 2;
            break;
          case 10:
          case 13:
            break;
          default:
            v5 = 1;
            break;
        }
        if ( v5 )
        {
          gettimeofday((struct timeval *)(v3 + 316), 0);
          sub_F38C((int *)v3, 3);
        }
        break;
      case 1:
        switch ( v4 )
        {
          case 9:
          case 32:
            v5 = 2;
            break;
          case 10:
            v5 = 8;
            break;
          case 13:
            v5 = 3;
            break;
          default:
            goto LABEL_55;
        }
        break;
      case 2:
        if ( v4 == 13 )
        {
          v5 = 3;
        }
        else if ( v4 > 13 )
        {
          if ( v4 != 32 )
          {
            if ( v4 != 72 )
              goto LABEL_23;
            v5 = 4;
          }
        }
        else if ( v4 != 9 )
        {
          if ( v4 == 10 )
            v5 = 8;
          else
LABEL_23:
            v5 = 1;
        }
        break;
      case 3:
        switch ( v4 )
        {
          case 9:
          case 32:
            v5 = 2;
            break;
          case 10:
            v5 = 8;
            break;
          case 13:
            goto LABEL_55;
          default:
            v5 = 1;
            break;
        }
        break;
      case 4:
        if ( v4 == 10 )
        {
          v5 = 6;
        }
        else if ( v4 == 13 )
        {
          v5 = 5;
        }
        break;
      case 5:
        if ( v4 == 10 )
        {
          v5 = 6;
        }
        else if ( v4 != 13 )
        {
          v5 = 4;
        }
        break;
      case 6:
        if ( v4 == 10 )
        {
          v5 = 8;
        }
        else if ( v4 == 13 )
        {
          v5 = 7;
        }
        else
        {
          v5 = 4;
        }
        break;
      case 7:
        if ( v4 == 10 )
        {
          v5 = 8;
        }
        else if ( v4 != 13 )
        {
          v5 = 4;
        }
        break;
      default:
        goto LABEL_55;
    }
  }
  *(_BYTE *)(v3 + 180) = v5;
  *(_DWORD *)(v3 + 172) = v6;
  if ( v5 != 8 )
    return 0;
  if ( sub_1B0F8(*(_DWORD *)(v3 + 12)) != -1 )
  {
    if ( sub_109BC(v3) == -1 )
    {
      sub_F5FC(v3);
      return -1;
    }
    sub_F38C((int *)v3, 4);
    return 0;
  }
  if ( *(_DWORD *)(v3 + 8) == 2 )
    return 0;
  sub_F5FC(v3);
  return -1;
}

//----- (00010F5C) --------------------------------------------------------
int __fastcall sub_10F5C(int a1)
{
  int v2; // [sp+4h] [bp-10h]
  _DWORD *i; // [sp+Ch] [bp-8h]

  v2 = a1;
  for ( i = (_DWORD *)dword_29EC0; i; i = (_DWORD *)i[5] )
  {
    if ( *i == -1 )
    {
      i[6] = -1;
    }
    else
    {
      *(_WORD *)(dword_29F48 + 8 * v2 + 4) = 1;
      *(_DWORD *)(dword_29F48 + 8 * v2) = *i;
      i[6] = v2++;
    }
  }
  return v2;
}
// 29EC0: using guessed type int dword_29EC0;
// 29F48: using guessed type int dword_29F48;

//----- (00011028) --------------------------------------------------------
int __fastcall sub_11028(int a1)
{
  int v2; // [sp+4h] [bp-10h]
  _DWORD *i; // [sp+Ch] [bp-8h]
  _DWORD *j; // [sp+Ch] [bp-8h]
  _DWORD *k; // [sp+Ch] [bp-8h]

  v2 = a1;
  for ( i = (_DWORD *)dword_29E84; i; i = (_DWORD *)*i )
  {
    *(_DWORD *)(dword_29F48 + 8 * v2) = i[5];
    *(_WORD *)(dword_29F48 + 8 * v2 + 4) = 1;
    i[69] = v2++;
  }
  for ( j = (_DWORD *)dword_29E8C; j; j = (_DWORD *)*j )
  {
    *(_DWORD *)(dword_29F48 + 8 * v2) = j[5];
    *(_WORD *)(dword_29F48 + 8 * v2 + 4) = 1;
    j[69] = v2++;
  }
  for ( k = (_DWORD *)dword_29E94; k; k = (_DWORD *)*k )
  {
    *(_DWORD *)(dword_29F48 + 8 * v2) = k[5];
    *(_WORD *)(dword_29F48 + 8 * v2 + 4) = 4;
    k[69] = v2++;
  }
  return v2;
}
// 29E84: using guessed type int dword_29E84;
// 29E8C: using guessed type int dword_29E8C;
// 29E94: using guessed type int dword_29E94;
// 29F48: using guessed type int dword_29F48;

//----- (000111E4) --------------------------------------------------------
signed int sub_111E4()
{
  int *i; // [sp+4h] [bp-8h]

  for ( i = (int *)dword_29EC0; i; i = (int *)i[5] )
  {
    if ( i[6] != -1 && *(_WORD *)(dword_29F48 + 8 * i[6] + 6) & 1 && sub_FDB8(i) == -1 )
      return -1;
  }
  return 0;
}
// 29EC0: using guessed type int dword_29EC0;
// 29F48: using guessed type int dword_29F48;

//----- (0001128C) --------------------------------------------------------
int *__fastcall sub_1128C(int *result)
{
  int v1; // [sp+4h] [bp-10h]
  int v2; // [sp+8h] [bp-Ch]
  __int16 v3; // [sp+Eh] [bp-6h]
  __int16 v4; // [sp+Eh] [bp-6h]

  v1 = (int)result;
  v2 = result[69];
  if ( v2 != -1 )
  {
    v3 = *(_WORD *)(dword_29F48 + 8 * v2 + 6);
    if ( v3 & 8 || v3 == 16 )
    {
      result = sub_F5FC((int)result);
    }
    else if ( v3 & 1 )
    {
      result = (int *)sub_10658((int)result);
      if ( result != (int *)-1 )
      {
        result = (int *)sub_10AAC(v1);
        if ( result != (int *)-1 )
        {
          v4 = v3 & 0xFFFE;
          if ( *(_DWORD *)(v1 + 8) == 4 )
            v4 |= 4u;
          *(_WORD *)(dword_29F48 + 8 * v2 + 6) = v4;
        }
      }
    }
  }
  return result;
}
// 29F48: using guessed type int dword_29F48;

//----- (000113A0) --------------------------------------------------------
int *__fastcall sub_113A0(int *result)
{
  __int16 v1; // [sp+Ah] [bp-Ah]
  int v2; // [sp+Ch] [bp-8h]

  v2 = result[69];
  if ( v2 != -1 )
  {
    v1 = *(_WORD *)(dword_29F48 + 8 * v2 + 6);
    if ( v1 & 8 || v1 == 16 )
    {
      result = sub_F5FC((int)result);
    }
    else if ( v1 & 4 )
    {
      result = sub_10424((int)result);
    }
  }
  return result;
}
// 29F48: using guessed type int dword_29F48;

//----- (00011438) --------------------------------------------------------
int *sub_11438()
{
  int v0; // ST00_4
  int *result; // r0
  int v2; // ST00_4
  int v3; // ST00_4
  _DWORD *v4; // ST00_4
  int *i; // [sp+4h] [bp-8h]
  int *j; // [sp+4h] [bp-8h]
  int *k; // [sp+4h] [bp-8h]
  _DWORD *l; // [sp+4h] [bp-8h]

  for ( i = (int *)dword_29E84; i; i = (int *)v0 )
  {
    v0 = *i;
    result = sub_1128C(i);
  }
  for ( j = (int *)dword_29E8C; j; j = (int *)v2 )
  {
    v2 = *j;
    result = sub_1128C(j);
  }
  for ( k = (int *)dword_29E94; k; k = (int *)v3 )
  {
    v3 = *k;
    result = sub_113A0(k);
  }
  for ( l = (_DWORD *)dword_29E9C; l; l = v4 )
  {
    v4 = (_DWORD *)*l;
    result = sub_1D54C(l);
  }
  return result;
}
// 29E84: using guessed type int dword_29E84;
// 29E8C: using guessed type int dword_29E8C;
// 29E94: using guessed type int dword_29E94;
// 29E9C: using guessed type int dword_29E9C;

//----- (0001153C) --------------------------------------------------------
int *__fastcall sub_1153C(int *result, int a2, int a3)
{
  int v3; // [sp+4h] [bp-18h]
  int v4; // [sp+8h] [bp-14h]
  int *v5; // [sp+Ch] [bp-10h]
  int *v6; // [sp+14h] [bp-8h]

  v5 = result;
  v4 = a2;
  v3 = a3;
  while ( v5 )
  {
    v6 = (int *)*v5;
    if ( v5[39] + v4 <= dword_29F24 )
    {
      if ( v3 )
        sub_14604((int *)"%s timeout to %s[%s]", v3, v5 + 7, (char *)v5 + 86);
      result = sub_F5FC((int)v5);
    }
    v5 = v6;
  }
  return result;
}
// 29F24: using guessed type int dword_29F24;

//----- (000115D8) --------------------------------------------------------
int *sub_115D8()
{
  int v0; // r3

  if ( dword_29F58 )
    v0 = 129772;
  else
    v0 = 0;
  sub_1153C((int *)dword_29E84, dword_29F0C, v0);
  sub_1153C((int *)dword_29E8C, dword_29EF4, 129500);
  sub_1153C((int *)dword_29E94, dword_29EF4, 129600);
  return sub_1153C((int *)dword_29E9C, dword_29F00, 129780);
}
// 29E84: using guessed type int dword_29E84;
// 29E8C: using guessed type int dword_29E8C;
// 29E94: using guessed type int dword_29E94;
// 29E9C: using guessed type int dword_29E9C;
// 29EF4: using guessed type int dword_29EF4;
// 29F00: using guessed type int dword_29F00;
// 29F0C: using guessed type int dword_29F0C;
// 29F58: using guessed type int dword_29F58;

//----- (000116B8) --------------------------------------------------------
int *sub_116B8()
{
  int *result; // r0
  int stat_loc; // [sp+4h] [bp-28h]
  int v2; // [sp+8h] [bp-24h]
  int v3; // [sp+Ch] [bp-20h]
  int v4; // [sp+10h] [bp-1Ch]
  int v5; // [sp+14h] [bp-18h]
  int v6; // [sp+18h] [bp-14h]
  int v7; // [sp+1Ch] [bp-10h]
  __pid_t v8; // [sp+20h] [bp-Ch]
  int v9; // [sp+24h] [bp-8h]

  v9 = *_errno_location();
  while ( 1 )
  {
    v8 = waitpid(-1, &stat_loc, 1);
    if ( v8 <= 0 )
      break;
    v2 = stat_loc;
    if ( stat_loc & 0x7F )
    {
      v4 = stat_loc;
      if ( (char)((char)((stat_loc & 0x7F) + 1) >> 1) <= 0 )
      {
        sub_14604((int *)"child process %d stopped!?", v8);
      }
      else
      {
        ++dword_29F3C;
        v5 = stat_loc;
        v6 = stat_loc & 0x7F;
        sub_14604((int *)"child process %d killed by signal %d", v8, v6);
      }
    }
    else
    {
      ++dword_29F3C;
      v3 = stat_loc;
      v7 = (stat_loc & 0xFF00) >> 8;
      if ( v7 || dword_29F58 )
        sub_14604((int *)"child process %d exited with status %d", v8, v7);
    }
  }
  if ( v8 < 0 && *_errno_location() != 10 )
    sub_14840("waitpid");
  result = _errno_location();
  *result = v9;
  return result;
}
// 29F3C: using guessed type int dword_29F3C;
// 29F58: using guessed type int dword_29F58;

//----- (00011884) --------------------------------------------------------
void __fastcall sub_11884(int a1, int a2)
{
  int v2; // [sp+0h] [bp-1Ch]
  int v3; // [sp+4h] [bp-18h]
  char *dest; // [sp+Ch] [bp-10h]
  int j; // [sp+10h] [bp-Ch]
  int k; // [sp+10h] [bp-Ch]
  int i; // [sp+10h] [bp-Ch]
  char *s; // [sp+14h] [bp-8h]
  char *sa; // [sp+14h] [bp-8h]
  char *sb; // [sp+14h] [bp-8h]

  v3 = a1;
  v2 = a2;
  dest = (char *)malloc(5 * a1 + 10);
  if ( dest )
  {
    if ( v2 )
    {
      strcpy(dest, "revents: ");
      sb = dest + 9;
      for ( i = 0; i < v3; ++i )
        sb += sprintf(sb, " %4hd", *(signed __int16 *)(dword_29F48 + 8 * i + 6));
      sub_14604((int *)dest);
    }
    else
    {
      strcpy(dest, "fds:     ");
      s = dest + 9;
      for ( j = 0; j < v3; ++j )
        s += sprintf(s, " %4d", *(_DWORD *)(dword_29F48 + 8 * j));
      sub_14604((int *)dest);
      strcpy(dest, "events:  ");
      sa = dest + 9;
      for ( k = 0; k < v3; ++k )
        sa += sprintf(sa, " %4hd", *(signed __int16 *)(dword_29F48 + 8 * k + 4));
      sub_14604((int *)dest);
    }
    free(dest);
  }
}
// 29F48: using guessed type int dword_29F48;

//----- (00011AB4) --------------------------------------------------------
int *sub_11AB4()
{
  _BOOL4 v0; // r2
  int v1; // r0
  signed int v2; // r3
  int v4; // [sp+4h] [bp-20h]
  int v5; // [sp+8h] [bp-1Ch]
  int timeout; // [sp+Ch] [bp-18h]
  int v7; // [sp+10h] [bp-14h]
  int v8; // [sp+14h] [bp-10h]
  signed int v9; // [sp+18h] [bp-Ch]
  nfds_t nfds; // [sp+1Ch] [bp-8h]
  int nfdsa; // [sp+1Ch] [bp-8h]

  v9 = 1;
  dword_29F28 = time(0);
  dword_29F24 = dword_29F28;
  v7 = dword_29F28;
  v8 = dword_29F28 / 3600;
  sub_14604((int *)"*** %s starting", 131804);
  while ( !dword_29F60 )
  {
    if ( dword_29F50 )
    {
      dword_29F50 = 0;
      sub_14538(0);
      if ( dword_29F58 )
        sub_14604((int *)"logs reopened");
    }
    if ( dword_29F78 )
    {
      dword_29F78 = 0;
      sub_F798();
      sub_14604((int *)"connections closed");
    }
    if ( dword_29F80 )
    {
      dword_29F80 = 0;
      sub_F72C();
      sub_14604((int *)"servers closed");
    }
    if ( dword_29F6C )
    {
      dword_29F6C = 0;
      sub_116B8();
    }
    if ( dword_29F54 )
    {
      dword_29F54 = 0;
      v0 = dword_29F58 == 0;
      dword_29F58 = dword_29F58 == 0;
      if ( v0 )
        sub_14604((int *)"debugging turned on");
      else
        sub_14604((int *)"debugging turned off");
    }
    if ( dword_29F64 )
    {
      dword_29F64 = 0;
      sub_14604((int *)"performing internal dump");
      sub_12B30();
    }
    nfds = 0;
    if ( v9 && sub_F89C() )
      nfds = sub_10F5C(0);
    v1 = sub_11028(nfds);
    nfdsa = sub_1DB94(v1, (int *)dword_29E9C);
    if ( !nfdsa && v9 && !dword_29F2C )
    {
      sub_14604((int *)"no more sockets to poll from");
      return sub_14604((int *)"*** shutting down");
    }
    if ( v9 )
      v2 = 60000;
    else
      v2 = 1000;
    timeout = v2;
    if ( dword_29F58 )
      sub_11884(nfdsa, 0);
    v5 = poll((struct pollfd *)dword_29F48, nfdsa, timeout);
    v4 = *_errno_location();
    dword_29F24 = time(0);
    if ( v5 == -1 )
    {
      if ( v4 != 4 )
      {
        sub_14840("poll");
        return sub_14604((int *)"*** shutting down");
      }
      if ( dword_29F58 )
        sub_14604((int *)"poll interrupted");
    }
    else
    {
      if ( dword_29F58 )
        sub_11884(nfdsa, 1);
      if ( dword_29F24 != v7 )
      {
        if ( !v9 )
          v9 = 1;
        if ( dword_29F24 / 3600 != v8 )
        {
          v8 = dword_29F24 / 3600;
          sub_14538(0);
          if ( dword_29F58 )
            sub_14604((int *)"logs rotated");
        }
      }
      if ( v5 )
      {
        if ( v9 && sub_111E4() == -1 )
          v9 = 0;
        sub_11438();
      }
      if ( dword_29F24 != v7 )
      {
        sub_115D8();
        v7 = dword_29F24;
      }
    }
  }
  return sub_14604((int *)"*** shutting down");
}
// 29E9C: using guessed type int dword_29E9C;
// 29F24: using guessed type int dword_29F24;
// 29F28: using guessed type int dword_29F28;
// 29F2C: using guessed type int dword_29F2C;
// 29F48: using guessed type int dword_29F48;
// 29F50: using guessed type int dword_29F50;
// 29F54: using guessed type int dword_29F54;
// 29F58: using guessed type int dword_29F58;
// 29F60: using guessed type int dword_29F60;
// 29F64: using guessed type int dword_29F64;
// 29F6C: using guessed type int dword_29F6C;
// 29F78: using guessed type int dword_29F78;
// 29F80: using guessed type int dword_29F80;

//----- (00011FA0) --------------------------------------------------------
signed int __fastcall sub_11FA0(int a1)
{
  if ( !a1 )
    return 0;
  dword_29F48 = (int)malloc(8 * a1);
  if ( dword_29F48 )
    return 0;
  sub_14604((int *)"init_pollfds: out of memory");
  return -1;
}
// 29F48: using guessed type int dword_29F48;

//----- (00012020) --------------------------------------------------------
signed int __fastcall sub_12020(_DWORD *a1, size_t a2)
{
  signed int v2; // r3
  size_t size; // [sp+0h] [bp-14h]
  _DWORD *v5; // [sp+4h] [bp-10h]
  char *v6; // [sp+Ch] [bp-8h]

  v5 = a1;
  size = a2;
  v6 = (char *)malloc(a2);
  if ( v6 )
  {
    v5[4] = v6;
    v5[3] = v5[4];
    v5[2] = v5[3];
    *v5 = v5[2];
    v5[1] = &v6[size];
    v5[6] = size;
    v2 = 0;
  }
  else
  {
    sub_14604((int *)"new_pool: out of memory");
    v2 = -1;
  }
  return v2;
}

//----- (000120D0) --------------------------------------------------------
signed int __fastcall sub_120D0(unsigned int a1)
{
  signed int v1; // r3
  int v2; // r4
  unsigned int v4; // [sp+4h] [bp-18h]
  int *v5; // [sp+8h] [bp-14h]
  unsigned int i; // [sp+Ch] [bp-10h]

  v4 = a1;
  dword_29F4C = (int)malloc(640 * a1);
  if ( dword_29F4C )
  {
    for ( i = 0; i < v4; ++i )
    {
      v5 = (int *)(dword_29F4C + 640 * i);
      v5[3] = (int)malloc(0x1278u);
      if ( !v5[3] )
      {
        sub_14604((int *)"init_connections: out of memory");
        return -1;
      }
      if ( dword_29EFC )
      {
        v2 = v5[3];
        *(_DWORD *)(v2 + 3440) = malloc(8 * dword_29EFC);
        if ( !*(_DWORD *)(v2 + 3440) )
        {
          sub_14604((int *)"init_connections: out of memory");
          return -1;
        }
      }
      else
      {
        *(_DWORD *)(v5[3] + 3440) = 0;
      }
      if ( sub_12020(v5 + 40, dword_29EEC) == -1 )
        return -1;
      if ( sub_12020(v5 + 47, dword_29EE8) == -1 )
        return -1;
      if ( sub_12020(v5 + 54, dword_29F04) == -1 )
        return -1;
      if ( sub_12020(v5 + 61, dword_29F04) == -1 )
        return -1;
      *(_DWORD *)v5[3] = v5;
      v5[2] = 0;
      sub_F38C(v5, 1);
    }
    v1 = 0;
  }
  else
  {
    sub_14604((int *)"init_connections: out of memory");
    v1 = -1;
  }
  return v1;
}
// 29EE8: using guessed type int dword_29EE8;
// 29EEC: using guessed type int dword_29EEC;
// 29EFC: using guessed type int dword_29EFC;
// 29F04: using guessed type int dword_29F04;
// 29F4C: using guessed type int dword_29F4C;

//----- (0001233C) --------------------------------------------------------
int __fastcall sub_1233C(FILE *a1)
{
  int v1; // ST14_4
  FILE *s; // [sp+Ch] [bp-28h]
  int *v4; // [sp+14h] [bp-20h]
  unsigned int i; // [sp+18h] [bp-1Ch]
  int v6; // [sp+1Ch] [bp-18h]
  int v7; // [sp+20h] [bp-14h]
  int v8; // [sp+24h] [bp-10h]
  int v9; // [sp+28h] [bp-Ch]
  signed int v10; // [sp+2Ch] [bp-8h]

  s = a1;
  v9 = 0;
  v8 = 0;
  v7 = 0;
  v6 = 0;
  v10 = -1;
  fwrite("Connections:\n", 1u, 0xDu, a1);
  for ( i = 0; dword_29EF0 > i; ++i )
  {
    v4 = (int *)(dword_29F4C + 640 * i);
    if ( ++v10 == 50 )
    {
      fputc(10, s);
      v10 = 0;
    }
    switch ( v4[2] )
    {
      case 1:
        fputc(46, s);
        break;
      case 2:
        fputc(70, s);
        ++v6;
        break;
      case 3:
        fputc(114, s);
        ++v9;
        break;
      case 4:
        fputc(87, s);
        ++v8;
        break;
      case 5:
        fputc(45, s);
        ++v7;
        break;
      default:
        fputc(63, s);
        break;
    }
    v1 = *v4;
  }
  return fprintf(s, "\nReading: %d, Writing: %d, Waiting: %d, Forked: %d\n", v9, v8, v7, v6);
}
// 29EF0: using guessed type int dword_29EF0;
// 29F4C: using guessed type int dword_29F4C;

//----- (00012510) --------------------------------------------------------
_DWORD *__fastcall sub_12510(_DWORD *result, _DWORD *a2, _DWORD *a3)
{
  int v3; // [sp+14h] [bp-8h]

  *a3 = *result + *a2;
  v3 = result[1] + a2[1];
  if ( v3 > 999999 )
  {
    v3 -= 1000000;
    ++*a3;
  }
  a3[1] = v3;
  return result;
}

//----- (000125AC) --------------------------------------------------------
size_t __fastcall sub_125AC(FILE *a1)
{
  FILE *stream; // ST04_4
  int v3; // [sp+8h] [bp-54h]
  int v4; // [sp+Ch] [bp-50h]
  struct rusage usage; // [sp+10h] [bp-4Ch]

  stream = a1;
  fprintf(a1, "Uptime: %d seconds\n", dword_29F24 - dword_29F28);
  fprintf(stream, "Active connections: %d out of %lu\n", dword_29F2C, dword_29EF0);
  fprintf(stream, "Max simultaneous connections since last dump: %d\n", dword_29F30);
  fprintf(stream, "Forked child processes: %lu\n", dword_29F38);
  fprintf(stream, "Exited child processes: %lu\n", dword_29F3C);
  fprintf(stream, "Requests executed: %lu\n", dword_29F34);
  fprintf(stream, "Accepted connections: %lu\n", dword_29F40);
  fprintf(stream, "Pipelined requests: %lu\n", dword_29F44);
  fputc(10, stream);
  getrusage(0, &usage);
  sub_12510(&usage, &usage.ru_stime.tv_sec, &v3);
  fprintf(stream, "CPU time used by this process: %8ld.%02ld\n", v3, v4 / 10000);
  getrusage(-1, &usage);
  sub_12510(&usage, &usage.ru_stime.tv_sec, &v3);
  fprintf(stream, "                     children: %8ld.%02ld\n\n", v3, v4 / 10000);
  dword_29F30 = dword_29F2C;
  sub_1233C(stream);
  return fwrite("*** End of dump\n", 1u, 0x10u, stream);
}
// 29EF0: using guessed type int dword_29EF0;
// 29F24: using guessed type int dword_29F24;
// 29F28: using guessed type int dword_29F28;
// 29F2C: using guessed type int dword_29F2C;
// 29F30: using guessed type int dword_29F30;
// 29F34: using guessed type int dword_29F34;
// 29F38: using guessed type int dword_29F38;
// 29F3C: using guessed type int dword_29F3C;
// 29F40: using guessed type int dword_29F40;
// 29F44: using guessed type int dword_29F44;

//----- (00012808) --------------------------------------------------------
signed int __fastcall sub_12808(int a1)
{
  signed int v1; // r3
  _DWORD *v3; // [sp+Ch] [bp-38h]
  char dest; // [sp+14h] [bp-30h]
  FILE *stream; // [sp+34h] [bp-10h]
  int v6; // [sp+38h] [bp-Ch]
  int fd; // [sp+3Ch] [bp-8h]

  v3 = (_DWORD *)a1;
  if ( *(_DWORD *)(a1 + 2492) == 2 || *(_DWORD *)(a1 + 2492) == 1 )
  {
    if ( *(_BYTE *)(a1 + 1636) )
    {
      *(_DWORD *)(a1 + 2612) = *(_DWORD *)(*(_DWORD *)(a1 + 2500) + 44);
      *(_DWORD *)(a1 + 2496) = 404;
      v1 = 1;
    }
    else
    {
      strcpy(&dest, "/tmp/mathop-dump.XXXXXXXX");
      fd = mkstemp64(&dest);
      if ( fd == -1 )
      {
        v3[624] = 500;
        v1 = 0;
      }
      else
      {
        fcntl64(fd, 2, 1);
        if ( remove(&dest) == -1 )
        {
          sub_14604((int *)"cannot remove temporary file %s", &dest);
          sub_14840("remove");
          close(fd);
          v3[624] = 500;
          v1 = 0;
        }
        else
        {
          v6 = dup(fd);
          if ( v6 == -1 )
          {
            sub_14840("dup");
            close(fd);
            v3[624] = 500;
            v1 = 0;
          }
          else
          {
            fcntl64(v6, 2, 1);
            stream = fdopen(v6, "a+");
            if ( stream )
            {
              sub_125AC(stream);
              if ( fclose(stream) == -1 )
              {
                sub_14840("fclose");
                close(v6);
                close(fd);
                v3[624] = 500;
                v1 = 0;
              }
              else if ( fstat64(fd, v3 + 626) == -1 )
              {
                sub_14840("fstat");
                close(fd);
                v3[624] = 500;
                v1 = 0;
              }
              else
              {
                *((_QWORD *)v3 + 306) = *((_QWORD *)v3 + 319);
                v3[614] = v3[646];
                if ( v3[623] == 2 )
                {
                  lseek64(fd, 2448, 0, 0, 0);
                  *(_QWORD *)(*v3 + 368) = 0LL;
                  *(_DWORD *)(*v3 + 24) = fd;
                }
                else
                {
                  close(fd);
                }
                v3[609] = 130944;
                v3[610] = 0;
                v3[624] = 200;
                v1 = 0;
              }
            }
            else
            {
              sub_14604((int *)"dump: failed to associate stream with descriptor %d", v6);
              close(v6);
              close(fd);
              v3[624] = 500;
              v1 = 0;
            }
          }
        }
      }
    }
  }
  else
  {
    *(_DWORD *)(a1 + 2496) = 405;
    v1 = 0;
  }
  return v1;
}
// 9470: using guessed type int __fastcall mkstemp64(_DWORD);
// 953C: using guessed type int __fastcall fcntl64(_DWORD, _DWORD, _DWORD);
// 9650: using guessed type int __fastcall fstat64(_DWORD, _DWORD);
// 98FC: using guessed type int __fastcall lseek64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00012B30) --------------------------------------------------------
int *sub_12B30()
{
  int *result; // r0
  struct timeval tv; // [sp+0h] [bp-3Ch]
  char s; // [sp+8h] [bp-34h]
  FILE *stream; // [sp+30h] [bp-Ch]
  int fd; // [sp+34h] [bp-8h]

  sprintf(&s, "/tmp/mathopd-%d-dump.XXXXXXX", dword_29F70);
  fd = mkstemp64(&s);
  if ( fd == -1 )
    return sub_14840("mkstemp");
  stream = fdopen(fd, "a");
  if ( stream )
  {
    gettimeofday(&tv, 0);
    fprintf(stream, "*** Dump performed at %ld.%06ld\n", tv.tv_sec, tv.tv_usec);
    sub_125AC(stream);
    result = (int *)fclose(stream);
  }
  else
  {
    sub_14840("fdopen");
    result = (int *)close(fd);
  }
  return result;
}
// 9470: using guessed type int __fastcall mkstemp64(_DWORD);
// 29F70: using guessed type int dword_29F70;

//----- (00012C0C) --------------------------------------------------------
bool __fastcall sub_12C0C(int a1, int a2, _DWORD *a3)
{
  return (*a3 >= a1) ^ (a3[2] >= a1) && (a3[1] >= a2) ^ (a3[3] >= a2);
}

//----- (00012CD8) --------------------------------------------------------
int __fastcall sub_12CD8(int a1)
{
  return a1 * a1;
}

//----- (00012D04) --------------------------------------------------------
bool __fastcall sub_12D04(int a1, int a2, _DWORD *a3)
{
  int v3; // ST0C_4
  _DWORD *v4; // ST04_4
  int v5; // r4
  int v6; // r4
  int v7; // r5

  v3 = a2;
  v4 = a3;
  v5 = sub_12CD8(*a3 - a1);
  v6 = v5 + sub_12CD8(v4[1] - v3);
  v7 = sub_12CD8(*v4 - v4[2]);
  return v6 <= v7 + sub_12CD8(v4[1] - v4[3]);
}

//----- (00012DBC) --------------------------------------------------------
int __fastcall sub_12DBC(int a1, int a2, _DWORD *a3, signed int a4)
{
  signed int v5; // r3
  unsigned int v7; // [sp+20h] [bp-14h]
  _DWORD *v8; // [sp+24h] [bp-10h]
  _DWORD *v9; // [sp+28h] [bp-Ch]
  int v10; // [sp+2Ch] [bp-8h]

  if ( a4 <= 2 )
    return 0;
  v10 = 0;
  v8 = a3;
  v7 = (unsigned int)&a3[2 * a4];
  v9 = &a3[2 * a4 - 2];
  while ( (unsigned int)v8 < v7 )
  {
    if ( v8[1] >= a2 != v9[1] >= a2 )
    {
      if ( v9[1] >= a2 )
        v5 = -1;
      else
        v5 = 1;
      if ( *v8 >= a1 == *v9 >= a1 )
      {
        if ( *v9 >= a1 )
          v10 += v5;
      }
      else if ( v5 * ((v8[1] - v9[1]) * (*v9 - a1) + (*v9 - *v8) * (v9[1] - a2)) >= 0 )
      {
        v10 += v5;
      }
    }
    v8 += 2;
    v9 += 2;
    if ( v9 == (_DWORD *)v7 )
      v9 = a3;
  }
  return v10;
}

//----- (00012FA4) --------------------------------------------------------
signed int __fastcall sub_12FA4(_BYTE *a1, signed int a2, FILE *a3)
{
  FILE *stream; // [sp+4h] [bp-18h]
  signed int v6; // [sp+8h] [bp-14h]
  _BYTE *v7; // [sp+Ch] [bp-10h]
  int v8; // [sp+14h] [bp-8h]

  v7 = a1;
  v6 = a2;
  stream = a3;
  do
  {
    v8 = fgetc(stream);
    if ( v8 == -1 )
      return -1;
    if ( v6 > 1 )
    {
      --v6;
      *v7++ = v8;
    }
  }
  while ( v8 != 10 );
  *(v7 - 1) = 0;
  return 0;
}

//----- (0001303C) --------------------------------------------------------
int __fastcall sub_1303C(int a1, int a2, int a3)
{
  int v5; // [sp+14h] [bp-18h]
  signed int v6; // [sp+18h] [bp-14h]
  int v7; // [sp+1Ch] [bp-10h]
  int v8; // [sp+20h] [bp-Ch]
  int v9; // [sp+24h] [bp-8h]

  v9 = 0;
  v8 = 0;
  v7 = 0;
  v6 = 0;
  while ( v7 < a3 )
  {
    v5 = *(unsigned __int8 *)(a1 + v9);
    if ( v6 )
    {
      if ( v6 == 1 )
      {
        switch ( v5 )
        {
          case 0:
          case 10:
          case 13:
          case 35:
            *(_DWORD *)(a2 + 8 * v7) = v8;
            *(_DWORD *)(a2 + 8 * v7 + 4) = v9 - v8;
            return v7 + 1;
          case 9:
          case 32:
          case 40:
          case 41:
          case 44:
            *(_DWORD *)(a2 + 8 * v7) = v8;
            *(_DWORD *)(a2 + 8 * v7++ + 4) = v9 - v8;
            v6 = 0;
            break;
          default:
            break;
        }
      }
    }
    else
    {
      switch ( v5 )
      {
        case 0:
        case 10:
        case 13:
        case 35:
          return v7;
        case 9:
        case 32:
        case 40:
        case 41:
        case 44:
          break;
        default:
          v8 = v9;
          v6 = 1;
          break;
      }
    }
    ++v9;
  }
  return v7;
}

//----- (0001331C) --------------------------------------------------------
int __fastcall sub_1331C(int a1, FILE *a2)
{
  const char *v2; // r3
  __int32 v3; // r0
  const char *v4; // r3
  __int32 v5; // r0
  int v6; // r4
  FILE *v8; // [sp+0h] [bp-FFCh]
  int v9; // [sp+4h] [bp-FF8h]
  int v10; // [sp+8h] [bp-FF4h]
  int v11; // [sp+Ch] [bp-FF0h]
  int v12; // [sp+328h] [bp-CD4h]
  int v13; // [sp+32Ch] [bp-CD0h]
  int v14; // [sp+330h] [bp-CCCh]
  int v15; // [sp+334h] [bp-CC8h]
  int v16; // [sp+338h] [bp-CC4h]
  int v17; // [sp+33Ch] [bp-CC0h]
  char v18; // [sp+980h] [bp-67Ch]
  char v19[800]; // [sp+CA0h] [bp-35Ch]
  int v20; // [sp+FC0h] [bp-3Ch]
  char *src; // [sp+FC4h] [bp-38h]
  int v22; // [sp+FC8h] [bp-34h]
  char *nptr; // [sp+FCCh] [bp-30h]
  int v24; // [sp+FD0h] [bp-2Ch]
  char *v25; // [sp+FD4h] [bp-28h]
  int v26; // [sp+FD8h] [bp-24h]
  int v27; // [sp+FDCh] [bp-20h]
  int v28; // [sp+FE0h] [bp-1Ch]
  int v29; // [sp+FE4h] [bp-18h]
  int v30; // [sp+FE8h] [bp-14h]
  int v31; // [sp+FECh] [bp-10h]
  char v32[12]; // [sp+FF0h] [bp-Ch]

  v9 = a1;
  v8 = a2;
  v12 = 0;
  v13 = 0;
  v26 = 1;
  if ( *(_DWORD *)(a1 + 2476) )
  {
    nptr = strchr(*(const char **)(a1 + 2476), 44);
    if ( !nptr || (++nptr, !*nptr) )
    {
      *(_DWORD *)(v9 + 2496) = 400;
      return 0;
    }
    v12 = atol(*(const char **)(v9 + 2476));
    v13 = atol(nptr);
    if ( v12 || v13 )
      v26 = 0;
  }
  v28 = 0;
  v27 = 0;
  v18 = 0;
  v31 = 0;
  v24 = 0;
  v25 = 0;
  while ( sub_12FA4(v19, 800, v8) != -1 )
  {
    if ( ++v28 > 1000 )
    {
      v24 = 131096;
      break;
    }
    v22 = sub_1303C((int)v19, (int)&v14, 202);
    if ( v22 > 1 )
    {
      if ( v22 & 1 )
      {
        v24 = 131112;
        break;
      }
      nptr = &v19[v14];
      v19[v14 + v15] = 0;
      src = &v19[v16];
      v19[v16 + v17] = 0;
      v30 = 2;
      v29 = 0;
      while ( v30 < v22 )
      {
        v2 = &v19[*(_DWORD *)&v32[8 * v30++ - 3264]];
        v3 = atol(v2);
        *(_DWORD *)&v32[8 * v29 - 4072] = v3;
        v4 = &v19[*(_DWORD *)&v32[8 * v30++ - 3264]];
        v5 = atol(v4);
        *(_DWORD *)&v32[8 * v29++ - 4068] = v5;
      }
      if ( v29 > 99 )
      {
        v24 = 131136;
        break;
      }
      if ( !strcmp(nptr, "default") )
      {
        strcpy(&v18, src);
      }
      else if ( !strcmp(nptr, "text") )
      {
        if ( v26 )
        {
          v25 = src;
          break;
        }
      }
      else if ( !strcmp(nptr, "point") )
      {
        if ( v29 <= 0 )
        {
          v24 = 131176;
          break;
        }
        if ( !v26 )
        {
          v6 = sub_12CD8(v10 - v12);
          v20 = v6 + sub_12CD8(v11 - v13);
          if ( !v27 || v20 < v31 )
          {
            v27 = 1;
            v31 = v20;
            strcpy(&v18, src);
          }
        }
      }
      else if ( !strcmp(nptr, "rect") )
      {
        if ( v29 <= 1 )
        {
          v24 = 131196;
          break;
        }
        if ( !v26 && sub_12C0C(v12, v13, &v10) )
        {
          v25 = src;
          break;
        }
      }
      else if ( !strcmp(nptr, "circle") )
      {
        if ( v29 <= 1 )
        {
          v24 = 131224;
          break;
        }
        if ( !v26 && sub_12D04(v12, v13, &v10) )
        {
          v25 = src;
          break;
        }
      }
      else if ( !strcmp(nptr, "spoly") )
      {
        if ( v29 <= 2 )
        {
          v24 = 131256;
          break;
        }
        if ( !v26 && sub_12DBC(v12, v13, &v10, v29) )
        {
          v25 = src;
          break;
        }
      }
      else
      {
        if ( strcmp(nptr, "poly") )
        {
          v24 = 131308;
          break;
        }
        if ( v29 <= 2 )
        {
          v24 = 131288;
          break;
        }
        if ( !v26 && sub_12DBC(v12, v13, &v10, v29) & 1 )
        {
          v25 = src;
          break;
        }
      }
    }
  }
  if ( v24 )
  {
    sub_14604((int *)"imagemap: %s on line %d of %s", v24, v28, v9 + 836, v8);
    *(_DWORD *)(v9 + 2496) = 500;
  }
  else
  {
    if ( !v25 && v18 )
      v25 = &v18;
    if ( v25 )
    {
      v22 = snprintf((char *)(v9 + 2632), 0x320u, "%s", v25, v8);
      if ( v22 <= 799 )
      {
        *(_DWORD *)(v9 + 2464) = v9 + 2632;
        *(_DWORD *)(v9 + 2496) = 302;
      }
      else
      {
        sub_14604((int *)"imagemap: url too large");
        *(_DWORD *)(v9 + 2496) = 500;
      }
    }
    else
    {
      *(_DWORD *)(v9 + 2496) = 204;
    }
  }
  return 0;
}
// 1331C: using guessed type char var_35C[800];
// 1331C: using guessed type char var_C[12];

//----- (00013A78) --------------------------------------------------------
int __fastcall sub_13A78(int a1)
{
  int v1; // r3
  int v2; // ST0C_4
  int v4; // [sp+4h] [bp-18h]
  FILE *stream; // [sp+10h] [bp-Ch]
  int fd; // [sp+14h] [bp-8h]

  v4 = a1;
  if ( *(_DWORD *)(a1 + 2492) == 1 )
  {
    *(_DWORD *)(a1 + 2496) = 204;
    v1 = 0;
  }
  else if ( *(_DWORD *)(a1 + 2492) == 2 )
  {
    fd = open64(a1 + 836, 2048);
    if ( fd == -1 )
    {
      sub_14604((int *)"cannot open map file %s", v4 + 836);
      sub_14840("open");
      *(_DWORD *)(v4 + 2496) = 500;
      v1 = 0;
    }
    else
    {
      fcntl64(fd, 2, 1);
      stream = fdopen(fd, "r");
      if ( stream )
      {
        v2 = sub_1331C(v4, stream);
        fclose(stream);
        v1 = v2;
      }
      else
      {
        sub_14604((int *)"process_imap: fdopen failed");
        close(fd);
        *(_DWORD *)(v4 + 2496) = 500;
        v1 = 0;
      }
    }
  }
  else
  {
    *(_DWORD *)(a1 + 2496) = 405;
    v1 = 0;
  }
  return v1;
}
// 953C: using guessed type int __fastcall fcntl64(_DWORD, _DWORD, _DWORD);
// 97F4: using guessed type int __fastcall open64(_DWORD, _DWORD);

//----- (00013BAC) --------------------------------------------------------
signed int __fastcall sub_13BAC(size_t a1)
{
  dword_29EA8 = a1;
  if ( !a1 )
    return 0;
  dword_29EA4 = (int)malloc(a1);
  if ( dword_29EA4 )
    return 0;
  sub_14604((int *)"init_log_buffer: out of memory");
  return -1;
}
// 29EA4: using guessed type int dword_29EA4;
// 29EA8: using guessed type int dword_29EA8;

//----- (00013C34) --------------------------------------------------------
_DWORD *__fastcall sub_13C34(_DWORD *result, _DWORD *a2, _DWORD *a3)
{
  int v3; // [sp+14h] [bp-8h]

  *a3 = *result - *a2;
  v3 = result[1] - a2[1];
  if ( v3 < 0 )
  {
    v3 += 1000000;
    --*a3;
  }
  a3[1] = v3;
  return result;
}

//----- (00013CC8) --------------------------------------------------------
int *__fastcall sub_13CC8(int *result)
{
  struct tm *v1; // r3
  int *v2; // [sp+4h] [bp-58h]
  time_t timer; // [sp+8h] [bp-54h]
  int v4; // [sp+Ch] [bp-50h]
  int v5; // [sp+10h] [bp-4Ch]
  struct timeval tv; // [sp+14h] [bp-48h]
  char s; // [sp+1Ch] [bp-40h]
  struct tm *tp; // [sp+30h] [bp-2Ch]
  void *dest; // [sp+34h] [bp-28h]
  int v10; // [sp+38h] [bp-24h]
  size_t n; // [sp+3Ch] [bp-20h]
  int v12; // [sp+40h] [bp-1Ch]
  int i; // [sp+44h] [bp-18h]
  int v14; // [sp+48h] [bp-14h]
  char *v15; // [sp+4Ch] [bp-10h]

  v2 = result;
  if ( dword_29E34 != -1 )
  {
    if ( dword_29EDC > 0 )
    {
      v10 = dword_29EA8 - dword_29EDC;
      if ( dword_29EA8 - dword_29EDC >= 0 )
      {
        dest = (void *)dword_29EA4;
        gettimeofday(&tv, 0);
        timer = tv.tv_sec;
        for ( i = 0; i < dword_29EDC; ++i )
        {
          v12 = dword_29EA8;
          v15 = 0;
          switch ( *(_DWORD *)(dword_29ECC + 4 * i) )
          {
            case 0:
              if ( dword_29ED8 )
                v1 = gmtime(&timer);
              else
                v1 = localtime(&timer);
              tp = v1;
              v15 = asctime(v1);
              v12 = 24;
              break;
            case 1:
              v15 = (char *)(v2 + 654);
              break;
            case 2:
              v15 = (char *)(*v2 + 28);
              break;
            case 3:
              v15 = (char *)(*v2 + 86);
              break;
            case 4:
              v15 = (char *)(*v2 + 92);
              break;
            case 5:
              v15 = (char *)(*v2 + 150);
              break;
            case 6:
              v15 = (char *)v2[5];
              break;
            case 7:
              v15 = (char *)v2[617];
              break;
            case 8:
              v15 = (char *)v2[618];
              break;
            case 9:
              v15 = (char *)v2[620];
              break;
            case 0xA:
              sprintf(&s, "%d", v2[624]);
              v15 = &s;
              break;
            case 0xB:
              v14 = v2[610];
              if ( v14 >= 0 )
                v14 = *((_QWORD *)v2 + 306);
              if ( v14 < 0 )
                v14 = 0;
              sprintf(&s, "%ld", v14);
              v15 = &s;
              break;
            case 0xC:
              v15 = (char *)v2[3];
              break;
            case 0xD:
              v15 = (char *)v2[2];
              break;
            case 0xE:
              sprintf(&s, "%ju", *(_QWORD *)(*v2 + 288));
              v15 = &s;
              break;
            case 0xF:
              sprintf(&s, "%ju", *(_QWORD *)(*v2 + 296));
              v15 = &s;
              break;
            case 0x10:
              v15 = (char *)v2[619];
              break;
            case 0x11:
              sub_13C34(&tv, (_DWORD *)(*v2 + 316), &v4);
              sprintf(&s, "%ld.%06ld", v4, v5);
              v15 = &s;
              break;
            case 0x12:
              sprintf(&s, "%ld.%06ld", tv.tv_sec, tv.tv_usec);
              v15 = &s;
              break;
            case 0x13:
              sprintf(&s, "%d", dword_29F70);
              v15 = &s;
              break;
            default:
              break;
          }
          if ( v15 && *v15 )
          {
            n = strlen(v15);
            if ( (signed int)n > v12 )
              n = v12;
            if ( (signed int)n > v10 )
              n = v10;
            memcpy(dest, v15, n);
            v10 -= n;
            dest = (char *)dest + n;
          }
          else if ( v10 )
          {
            *(_BYTE *)dest = 45;
            dest = (char *)dest + 1;
            --v10;
          }
          *(_BYTE *)dest = 9;
          dest = (char *)dest + 1;
        }
        *((char *)dest - 1) = 10;
        result = (int *)write(dword_29E34, (const void *)dword_29EA4, (size_t)dest - dword_29EA4);
        if ( result == (int *)-1 )
        {
          dword_29F60 = 1;
          sub_14604((int *)"log_request: cannot write to log file");
          result = sub_14840("write");
        }
      }
      else if ( !dword_29EB0 )
      {
        dword_29EB0 = 1;
        result = sub_14604((int *)"log_request: buffer too small!?!?");
      }
    }
    else if ( !dword_29EAC )
    {
      dword_29EAC = 1;
      result = sub_14604((int *)"log_request: nothing to log!");
    }
  }
  return result;
}
// 29E34: using guessed type int dword_29E34;
// 29EA4: using guessed type int dword_29EA4;
// 29EA8: using guessed type int dword_29EA8;
// 29EAC: using guessed type int dword_29EAC;
// 29EB0: using guessed type int dword_29EB0;
// 29ECC: using guessed type int dword_29ECC;
// 29ED8: using guessed type int dword_29ED8;
// 29EDC: using guessed type int dword_29EDC;
// 29F60: using guessed type int dword_29F60;
// 29F70: using guessed type int dword_29F70;

//----- (000142EC) --------------------------------------------------------
int __fastcall sub_142EC(const char *a1)
{
  char *s; // [sp+4h] [bp-338h]
  char v3; // [sp+Ch] [bp-330h]
  int v4; // [sp+32Ch] [bp-10h]
  struct tm *tp; // [sp+330h] [bp-Ch]
  char *v6; // [sp+334h] [bp-8h]

  s = (char *)a1;
  v6 = (char *)a1;
  if ( strchr(a1, 37) )
  {
    dword_29F24 = time(0);
    tp = dword_29ED8 ? gmtime((const time_t *)&dword_29F24) : localtime((const time_t *)&dword_29F24);
    if ( tp && strftime(&v3, 0x31Fu, s, tp) )
      v6 = &v3;
  }
  v4 = open64(v6, 1089);
  if ( v4 == -1 )
  {
    sub_14604((int *)"cannot open %s", v6);
    sub_14840("open");
  }
  return v4;
}
// 97F4: using guessed type int __fastcall open64(_DWORD, _DWORD);
// 29ED8: using guessed type int dword_29ED8;
// 29F24: using guessed type int dword_29F24;

//----- (000143F0) --------------------------------------------------------
signed int __fastcall sub_143F0(const char *a1, int *a2)
{
  signed int v2; // r3
  int *v4; // [sp+0h] [bp-14h]
  char *s1; // [sp+4h] [bp-10h]
  int fd2; // [sp+8h] [bp-Ch]
  int fd; // [sp+Ch] [bp-8h]

  s1 = (char *)a1;
  v4 = a2;
  if ( !a1 )
    return 0;
  fd2 = *a2;
  if ( !strcmp(a1, "/dev/stdout") )
  {
    if ( fd2 != -1 )
      return 0;
    fd = dup(1);
  }
  else if ( !strcmp(s1, "/dev/stderr") )
  {
    if ( fd2 != -1 )
      return 0;
    fd = dup(2);
  }
  else
  {
    fd = sub_142EC(s1);
  }
  if ( fd != -1 )
  {
    if ( fd2 == -1 )
    {
      *v4 = fd;
    }
    else if ( fd != fd2 )
    {
      dup2(fd, fd2);
      close(fd);
      fd = fd2;
    }
    fcntl64(fd, 2, 1);
    return 0;
  }
  if ( fd2 == -1 )
    v2 = -1;
  else
    v2 = 0;
  return v2;
}
// 953C: using guessed type int __fastcall fcntl64(_DWORD, _DWORD, _DWORD);

//----- (00014538) --------------------------------------------------------
signed int __fastcall sub_14538(int a1)
{
  if ( a1 )
  {
    if ( dword_29E3C == -1 )
    {
      dword_29E3C = dup(2);
      if ( dword_29E3C == -1 )
        return -1;
    }
  }
  if ( sub_143F0((const char *)dword_29F1C, &dword_29E38) != -1
    && sub_143F0((const char *)dword_29EE0, &dword_29E34) != -1 )
  {
    return 0;
  }
  return -1;
}
// 29E34: using guessed type int dword_29E34;
// 29E38: using guessed type int dword_29E38;
// 29E3C: using guessed type int dword_29E3C;
// 29EE0: using guessed type int dword_29EE0;
// 29F1C: using guessed type int dword_29F1C;

//----- (00014604) --------------------------------------------------------
int *sub_14604(int *result, ...)
{
  size_t v1; // r3
  int v2; // [sp+4h] [bp-408h]
  __gnuc_va_list arg; // [sp+3ECh] [bp-20h]
  int v4; // [sp+3F0h] [bp-1Ch]
  size_t maxlen; // [sp+3F4h] [bp-18h]
  size_t n; // [sp+3F8h] [bp-14h]
  char *v7; // [sp+3FCh] [bp-10h]
  int v8; // [sp+400h] [bp-Ch]
  struct tm *tp; // [sp+404h] [bp-8h]
  char var4[8]; // [sp+408h] [bp-4h]
  const char *varg_r0; // [sp+410h] [bp+4h]
  va_list varg_r1; // [sp+414h] [bp+8h]

  va_start(varg_r1, result);
  varg_r0 = (const char *)result;
  if ( dword_29E38 != -1 || dword_29E3C != -1 )
  {
    va_copy((int **)arg, varg_r1);
    v8 = *_errno_location();
    if ( dword_29ED8 )
      tp = gmtime((const time_t *)&dword_29F24);
    else
      tp = localtime((const time_t *)&dword_29F24);
    v7 = asctime(tp);
    n = sprintf((char *)&v2, "%.24s [%d] ", v7, dword_29F70);
    maxlen = 999 - n;
    v4 = vsnprintf((char *)&v2 + n, 999 - n, varg_r0, arg);
    if ( v4 >= (signed int)maxlen )
      v1 = maxlen - 1;
    else
      v1 = v4;
    n += v1;
    var4[n++ - 1028] = 10;
    if ( dword_29E38 != -1 )
      write(dword_29E38, &v2, n);
    if ( dword_29E3C != -1 && write(dword_29E3C, &v2, n) == -1 )
    {
      close(dword_29E3C);
      dword_29E3C = -1;
    }
    result = _errno_location();
    *result = v8;
  }
  return result;
}
// 29E38: using guessed type int dword_29E38;
// 29E3C: using guessed type int dword_29E3C;
// 29ED8: using guessed type int dword_29ED8;
// 29F24: using guessed type int dword_29F24;
// 29F70: using guessed type int dword_29F70;
// 14604: using guessed type char var_4[8];

//----- (00014840) --------------------------------------------------------
int *__fastcall sub_14840(_BYTE *a1)
{
  int *v1; // r0
  signed int v2; // r3
  signed int v3; // r3
  int *result; // r0
  _BYTE *v5; // [sp+4h] [bp-10h]
  char *v6; // [sp+8h] [bp-Ch]
  int v7; // [sp+Ch] [bp-8h]

  v5 = a1;
  v7 = *_errno_location();
  v1 = _errno_location();
  v6 = strerror(*v1);
  if ( v5 && *v5 )
  {
    if ( v6 )
      v2 = (signed int)v6;
    else
      v2 = 131732;
    sub_14604((int *)"%s: %s", v5, v2);
  }
  else
  {
    if ( v6 )
      v3 = (signed int)v6;
    else
      v3 = 131732;
    sub_14604((int *)"%s", v3);
  }
  result = _errno_location();
  *result = v7;
  return result;
}

//----- (0001490C) --------------------------------------------------------
int __fastcall sub_1490C(int a1, int a2)
{
  int sig; // ST04_4
  int v4; // [sp+Ch] [bp-18h]
  int v5; // [sp+10h] [bp-14h]
  int v6; // [sp+18h] [bp-Ch]

  sig = a1;
  v4 = a2;
  sigemptyset((sigset_t *)&v6);
  v5 = 0;
  return sigaction(sig, (const struct sigaction *)&v4, 0);
}

//----- (00014964) --------------------------------------------------------
void __noreturn sub_14964(char *a1, const char *a2, ...)
{
  char *s; // [sp+4h] [bp-14h]
  const char *varg_r1; // [sp+1Ch] [bp+4h]
  va_list varg_r2; // [sp+20h] [bp+8h]

  va_start(varg_r2, a2);
  varg_r1 = a2;
  s = a1;
  if ( a2 )
  {
    fprintf((FILE *)stderr, "%s: ", dword_29EB8);
    vfprintf((FILE *)stderr, varg_r1, varg_r2);
    fputc(10, (FILE *)stderr);
  }
  if ( s )
    perror(s);
  if ( dword_29ED0 )
    unlink((const char *)dword_29ED0);
  exit(1);
}
// 29E50: using guessed type int stderr;
// 29EB8: using guessed type int dword_29EB8;
// 29ED0: using guessed type int dword_29ED0;

//----- (00014A30) --------------------------------------------------------
int __fastcall sub_14A30(int *a1)
{
  int result; // r0
  signed int v2; // r3
  int *v3; // [sp+Ch] [bp-80h]
  char v4; // [sp+10h] [bp-7Ch]
  int v5; // [sp+24h] [bp-68h]
  char dest; // [sp+30h] [bp-5Ch]
  in_addr_t v7; // [sp+50h] [bp-3Ch]
  int v8; // [sp+54h] [bp-38h]
  struct in_addr inp; // [sp+58h] [bp-34h]
  char s; // [sp+5Ch] [bp-30h]
  int v11; // [sp+6Ch] [bp-20h]
  unsigned __int8 buf; // [sp+70h] [bp-1Ch]
  int optval; // [sp+80h] [bp-Ch]
  int i; // [sp+84h] [bp-8h]

  v3 = a1;
  *a1 = socket(a1[11], a1[12], a1[13]);
  if ( *v3 == -1 )
    sub_14964("socket", 0);
  optval = 1;
  if ( setsockopt(*v3, 1, 2, &optval, 4u) == -1 )
    sub_14964("setsockopt", "cannot set re-use flag");
  if ( dword_29EC8 == 1 && v3[12] == 1 && setsockopt(*v3, 6, 1, &dword_29EC8, 4u) == -1 )
    fwrite("set socket option error for tcp nodelay on\n", 1u, 0x2Bu, (FILE *)stderr);
  for ( i = v3[14]; i; i = *(_DWORD *)(i + 16) )
  {
    if ( setsockopt(*v3, *(_DWORD *)i, *(_DWORD *)(i + 4), *(const void **)(i + 8), *(_DWORD *)(i + 12)) == -1 )
      fprintf((FILE *)stderr, "socket option %d error\n", *(_DWORD *)(i + 4));
  }
  fcntl64(*v3, 2, 1);
  fcntl64(*v3, 4, 2048);
  if ( v3[15] )
  {
    strncpy(&dest, (const char *)v3[15], 0x10u);
    if ( setsockopt(*v3, 1, 25, &dest, 0x20u) < 0 )
      return fprintf((FILE *)stderr, "setsockopt: cannot bind to device %s\n", v3[15]);
  }
  if ( bind(*v3, (const struct sockaddr *)v3[2], v3[1]) == -1 )
  {
    if ( v3[9] )
      v2 = v3[9];
    else
      v2 = 132028;
    result = fprintf((FILE *)stderr, "cannot start up server at %s port %s\n", v2, v3[10]);
  }
  else if ( v3[12] == 2 && v3[9] )
  {
    if ( v3[11] == 10 )
    {
      result = inet_pton(10, (const char *)v3[9], &buf);
      if ( buf == 255 && v3[15] )
      {
        printf("%s:IPV6, is multicast\n", 132508);
        memset(&s, 0, 0x14u);
        memcpy(&s, &buf, 0x10u);
        v11 = if_nametoindex(v3[15]);
        if ( v11 )
        {
          result = setsockopt(*v3, 41, 20, &s, 0x14u);
          if ( result < 0 )
            sub_14964("setsockopt", "cannot add multicast membership - %s", v3[9]);
        }
        else
        {
          result = printf("httpd: unable to get ipv6 interface index from '%s'.\n", v3[15]);
        }
      }
    }
    else
    {
      inet_aton((const char *)v3[9], &inp);
      result = htonl(inp.s_addr);
      if ( (result & 0xF0000000) == -536870912 && v3[15] )
      {
        memset(&v4, 0, 0x20u);
        strcpy(&v4, (const char *)v3[15]);
        if ( ioctl(*v3, 0x8915u, &v4) )
        {
          result = printf("httpd: unable to get ipaddr from '%s'.\n", v3[15]);
        }
        else
        {
          v7 = inp.s_addr;
          v8 = v5;
          result = setsockopt(*v3, 0, 35, &v7, 8u);
          if ( result < 0 )
            sub_14964("setsockopt", "cannot add multicast membership - %s", v3[9]);
        }
      }
    }
  }
  else
  {
    result = listen(*v3, v3[8]);
    if ( result == -1 )
      sub_14964("listen", 0);
  }
  return result;
}
// 953C: using guessed type int __fastcall fcntl64(_DWORD, _DWORD, _DWORD);
// 96B0: using guessed type int __fastcall if_nametoindex(_DWORD);
// 29E50: using guessed type int stderr;
// 29EC8: using guessed type int dword_29EC8;

//----- (00015150) --------------------------------------------------------
signed int __fastcall sub_15150(int a1, char **a2)
{
  signed int v2; // r3
  int v3; // r1
  __pid_t v4; // r0
  size_t v5; // r0
  signed int result; // r0
  char **argv; // [sp+0h] [bp-54h]
  int argc; // [sp+4h] [bp-50h]
  __int64 v9; // [sp+8h] [bp-4Ch]
  __int64 v10; // [sp+10h] [bp-44h]
  char buf; // [sp+18h] [bp-3Ch]
  char *s; // [sp+24h] [bp-30h]
  int v13; // [sp+28h] [bp-2Ch]
  int v14; // [sp+2Ch] [bp-28h]
  int *i; // [sp+30h] [bp-24h]
  int v16; // [sp+34h] [bp-20h]
  int v17; // [sp+38h] [bp-1Ch]
  int v18; // [sp+3Ch] [bp-18h]
  int v19; // [sp+40h] [bp-14h]
  int fd; // [sp+44h] [bp-10h]

  argc = a1;
  argv = a2;
  dword_29F70 = getpid();
  dword_29EB8 = (int)*argv;
  dword_29EB4 = 1;
  v19 = 0;
  v14 = 0;
  v16 = 0;
  while ( 1 )
  {
    v13 = getopt(argc, argv, "ndvf:t");
    if ( v13 == -1 )
      break;
    switch ( v13 )
    {
      case 100:
        dword_29F58 = 1;
        break;
      case 102:
        if ( v14 )
          sub_14964(0, "You may not specify more than one configuration file.");
        v14 = optarg;
        break;
      case 110:
        dword_29EB4 = 0;
        break;
      case 116:
        v16 = 1;
        break;
      case 118:
        v19 = 1;
        break;
      default:
        sub_14964(0, "usage: %s [ -ndvt ] [ -f configuration_file ]", dword_29EB8);
        return result;
    }
  }
  if ( v19 )
  {
    fprintf((FILE *)stderr, "%s\n", 131804);
    v2 = 0;
  }
  else
  {
    if ( getrlimit64(7, &v9) == -1 )
      sub_14964("getrlimit", 0);
    v9 = v10;
    dword_29F7C = v10;
    setrlimit64(7, &v9);
    if ( dword_29EB4 )
    {
      for ( fd = 3; fd < dword_29F7C; ++fd )
        close(fd);
    }
    v17 = open64(131816, 2);
    if ( v17 == -1 )
      sub_14964("open", "Cannot open %s", 131816);
    while ( v17 <= 2 )
    {
      v17 = dup(v17);
      if ( v17 == -1 )
        sub_14964("dup", 0);
    }
    s = (char *)sub_EE3C(v14);
    if ( s )
      fputs(s, (FILE *)stderr);
    for ( i = (int *)dword_29EC0; i; i = (int *)i[5] )
      sub_14A30(i);
    if ( dword_29F18 )
    {
      if ( chroot((const char *)dword_29F18) == -1 )
        sub_14964("chroot", 0);
      if ( chdir("/") == -1 )
        sub_14964("chdir", 0);
    }
    if ( getrlimit64(4, &v9) == -1 )
      sub_14964("getrlimit", 0);
    if ( dword_29EE4 )
    {
      v9 = v10;
      if ( chdir((const char *)dword_29EE4) == -1 )
        sub_14964("chdir", 0);
    }
    else
    {
      v9 = 0LL;
      chdir("/");
    }
    setrlimit64(4, &v9);
    umask(dword_29F5C);
    if ( dword_29ED0 )
    {
      v18 = open64(dword_29ED0, 65);
      if ( v18 == -1 )
        sub_14964("open", "Cannot open PID file");
    }
    else
    {
      v18 = -1;
    }
    dword_29F24 = time(0);
    if ( sub_14538(v16) == -1 )
      sub_14964("open", "Cannot open log files");
    dup2(v17, 0);
    dup2(v17, 1);
    dup2(v17, 2);
    close(v17);
    if ( dword_29EB4 )
    {
      if ( fork() )
        exit(0);
      setsid();
      if ( fork() )
        exit(0);
      for ( fd = 1; dword_29F10 > fd; ++fd )
      {
        if ( !fork() )
        {
          if ( v18 != -1 )
          {
            close(v18);
            v18 = -1;
          }
          break;
        }
      }
    }
    sub_1490C(17, 86052);
    sub_1490C(1, 86052);
    sub_1490C(15, 86052);
    sub_1490C(2, 86052);
    sub_1490C(3, 86052);
    sub_1490C(10, 86052);
    sub_1490C(12, 86052);
    sub_1490C(13, 1);
    sub_1490C(28, 86052);
    dword_29F70 = getpid();
    if ( v18 != -1 )
    {
      ftruncate64(v18, v3, 0, 0);
      if ( dword_29F10 <= 1 )
      {
        sprintf(&buf, "%d\n", dword_29F70);
      }
      else
      {
        v4 = getpgrp();
        sprintf(&buf, "-%d\n", v4);
      }
      v5 = strlen(&buf);
      write(v18, &buf, v5);
      close(v18);
    }
    if ( sub_F110() == -1 )
    {
      v2 = 1;
    }
    else
    {
      sub_11AB4();
      if ( dword_29ED0 )
        unlink((const char *)dword_29ED0);
      v2 = 0;
    }
  }
  return v2;
}
// 9464: using guessed type int __fastcall setrlimit64(_DWORD, _DWORD);
// 9548: using guessed type int __fastcall getrlimit64(_DWORD, _DWORD);
// 97F4: using guessed type int __fastcall open64(_DWORD, _DWORD);
// 998C: using guessed type int __fastcall ftruncate64(_DWORD, _DWORD, _DWORD, _DWORD);
// 29E48: using guessed type int optarg;
// 29E50: using guessed type int stderr;
// 29EB4: using guessed type int dword_29EB4;
// 29EB8: using guessed type int dword_29EB8;
// 29EC0: using guessed type int dword_29EC0;
// 29ED0: using guessed type int dword_29ED0;
// 29EE4: using guessed type int dword_29EE4;
// 29F10: using guessed type int dword_29F10;
// 29F18: using guessed type int dword_29F18;
// 29F24: using guessed type int dword_29F24;
// 29F58: using guessed type int dword_29F58;
// 29F5C: using guessed type int dword_29F5C;
// 29F70: using guessed type int dword_29F70;
// 29F7C: using guessed type int dword_29F7C;

//----- (000158C4) --------------------------------------------------------
__pid_t __fastcall sub_158C4(int a1, int a2, int a3, char *path, int a5, int a6, int a7, char *patha)
{
  __pid_t v8; // r0
  char *fd; // [sp+0h] [bp-2Ch]
  char **envp; // [sp+4h] [bp-28h]
  char **argv; // [sp+8h] [bp-24h]
  char *v13; // [sp+Ch] [bp-20h]
  __int64 v14; // [sp+10h] [bp-1Ch]
  __int64 v15; // [sp+18h] [bp-14h]
  __pid_t v16; // [sp+24h] [bp-8h]

  v13 = (char *)a1;
  argv = (char **)a2;
  envp = (char **)a3;
  fd = path;
  v8 = fork();
  v16 = v8;
  if ( v8 == -1 )
  {
    sub_14840("spawn: failed to create child process");
  }
  else
  {
    if ( !v8 )
    {
      setpgid(0, 0);
      sub_1490C(13, 0);
      if ( dword_29EE4 )
      {
        v15 = 0LL;
        v14 = 0LL;
        setrlimit64(4, &v14);
      }
      dup2((int)fd, 0);
      dup2((int)fd, 1);
      if ( a5 != -1 )
        dup2(a5, 2);
      if ( chdir(patha) == -1 )
        exit(5);
      execve(v13, argv, envp);
      exit(6);
    }
    ++dword_29F38;
    if ( dword_29F58 )
      sub_14604((int *)"child process %d created", v16);
  }
  return v16;
}
// 9464: using guessed type int __fastcall setrlimit64(_DWORD, _DWORD);
// 29EE4: using guessed type int dword_29EE4;
// 29F38: using guessed type int dword_29F38;
// 29F58: using guessed type int dword_29F58;

//----- (00015A18) --------------------------------------------------------
int __fastcall sub_15A18(_DWORD *a1)
{
  _DWORD *v2; // [sp+4h] [bp-18h]
  ssize_t v3; // [sp+Ch] [bp-10h]
  int fd; // [sp+10h] [bp-Ch]
  char *v5; // [sp+14h] [bp-8h]

  v2 = a1;
  if ( a1[623] == 2 || a1[623] == 1 )
  {
    fd = open64(a1 + 209, 2048);
    if ( fd == -1 )
    {
      sub_14604((int *)"process_redirect: cannot open %s", v2 + 209);
      sub_14840("open");
      v2[624] = 500;
    }
    else
    {
      v3 = read(fd, v2 + 658, 0x31Fu);
      if ( v3 == -1 )
      {
        sub_14604((int *)"process_redirect: cannot read %s", v2 + 209);
        sub_14840("read");
        close(fd);
        v2[624] = 500;
      }
      else
      {
        *((_BYTE *)v2 + v3 + 2632) = 0;
        close(fd);
        v5 = strchr((const char *)v2 + 2632, 10);
        if ( v5 )
        {
          if ( v2 + 658 < (_DWORD *)v5 && *(v5 - 1) == 13 )
            --v5;
          *v5 = 0;
          v2[616] = v2 + 658;
          v2[624] = 302;
        }
        else
        {
          sub_14604((int *)"process_redirect: no newline in %s", v2 + 209);
          v2[624] = 500;
        }
      }
    }
  }
  else
  {
    a1[624] = 405;
  }
  return 0;
}
// 97F4: using guessed type int __fastcall open64(_DWORD, _DWORD);

//----- (00015C10) --------------------------------------------------------
signed int __fastcall sub_15C10(unsigned __int8 *a1)
{
  unsigned int v1; // r3
  char v2; // r3
  char v3; // r3
  char v4; // r3
  char v5; // r3
  signed int v6; // r3
  signed int v7; // r3
  signed int v8; // r3
  signed int v9; // r3
  _BOOL4 v10; // r1
  unsigned __int8 *v12; // [sp+4h] [bp-30h]
  char v13; // [sp+8h] [bp-2Ch]
  char v14; // [sp+9h] [bp-2Bh]
  char v15; // [sp+Ah] [bp-2Ah]
  int v16; // [sp+Ch] [bp-28h]
  char v17; // [sp+11h] [bp-23h]
  char v18; // [sp+12h] [bp-22h]
  char v19; // [sp+13h] [bp-21h]
  unsigned int v20; // [sp+14h] [bp-20h]
  unsigned int v21; // [sp+18h] [bp-1Ch]
  int v22; // [sp+1Ch] [bp-18h]
  unsigned int v23; // [sp+20h] [bp-14h]
  unsigned int v24; // [sp+24h] [bp-10h]
  unsigned int v25; // [sp+28h] [bp-Ch]
  unsigned int v26; // [sp+2Ch] [bp-8h]
  char v27[4]; // [sp+30h] [bp-4h]

  v12 = a1;
  v26 = 60;
  v25 = 60;
  v24 = 24;
  v23 = 32;
  v21 = 1969;
  v17 = 0;
  v13 = 0;
  v18 = 0;
  v20 = 0;
  v19 = 1;
  while ( 2 )
  {
    v16 = *v12++;
    switch ( v18 )
    {
      case 0:
        if ( v16 == 32 )
        {
          v18 = 2;
          v17 = 1;
        }
        else if ( v16 == 44 )
        {
          v18 = 3;
        }
        goto LABEL_42;
      case 2:
        if ( (*_ctype_b_loc())[v16] & 4 )
        {
          if ( v20 <= 2 )
            v27[v20++ - 40] = v16;
        }
        else
        {
          if ( v20 <= 2 )
            return -1;
          v20 = 0;
          if ( v17 )
            v2 = 3;
          else
            v2 = 4;
          v18 = v2;
        }
LABEL_42:
        if ( v18 != 1 && v16 )
          continue;
        switch ( v13 )
        {
          case 0x41:
            if ( v14 == 112 )
              v6 = 4;
            else
              v6 = 8;
            v22 = v6;
            goto LABEL_66;
          case 0x44:
            v22 = 12;
            goto LABEL_66;
          case 0x46:
            v22 = 2;
            goto LABEL_66;
          case 0x4A:
            if ( v14 == 97 )
            {
              v7 = 1;
            }
            else if ( v15 == 108 )
            {
              v7 = 7;
            }
            else
            {
              v7 = 6;
            }
            v22 = v7;
            goto LABEL_66;
          case 0x4D:
            if ( v15 == 114 )
              v8 = 3;
            else
              v8 = 5;
            v22 = v8;
            goto LABEL_66;
          case 0x4E:
            v22 = 11;
            goto LABEL_66;
          case 0x4F:
            v22 = 10;
            goto LABEL_66;
          case 0x53:
            v22 = 9;
LABEL_66:
            if ( v21 <= 0x64 )
            {
              if ( v21 > 0x45 )
                v9 = 1900;
              else
                v9 = 2000;
              v21 += v9;
            }
            --v22;
            --v23;
            if ( v26 <= 0x3B && v25 <= 0x3B && v24 <= 0x3B && v23 <= 0x1E )
            {
              if ( v21 > 0x7B1 )
              {
                v10 = !(v21 & 3) && (v21 % 0x64 || !(v21 % 0x190));
                v1 = 60 * (60 * (24 * (algn_2150C[12 * v10 + v22] + v23 + 365 * v21 + ((v21 - 1969) >> 2)) + v24) + v25)
                   + v26
                   - 1996377856;
              }
              else
              {
                v1 = 0;
              }
            }
            else
            {
              v1 = -1;
            }
            break;
          default:
            v1 = -1;
            break;
        }
        return v1;
      case 3:
        if ( v16 != 32 || !v19 )
        {
          if ( (*_ctype_b_loc())[v16] & 8 )
          {
            v19 = 0;
            v20 = 10 * v20 + v16 - 48;
          }
          else
          {
            v23 = v20;
            v20 = 0;
            if ( v17 )
              v3 = 5;
            else
              v3 = 2;
            v18 = v3;
          }
        }
        goto LABEL_42;
      case 4:
        if ( (*_ctype_b_loc())[v16] & 8 )
        {
          v20 = 10 * v20 + v16 - 48;
        }
        else
        {
          v21 = v20;
          v20 = 0;
          if ( v17 )
            v4 = 1;
          else
            v4 = 5;
          v18 = v4;
        }
        goto LABEL_42;
      case 5:
        if ( (*_ctype_b_loc())[v16] & 8 )
        {
          v20 = 10 * v20 + v16 - 48;
        }
        else
        {
          v24 = v20;
          v20 = 0;
          v18 = 6;
        }
        goto LABEL_42;
      case 6:
        if ( (*_ctype_b_loc())[v16] & 8 )
        {
          v20 = 10 * v20 + v16 - 48;
        }
        else
        {
          v25 = v20;
          v20 = 0;
          v18 = 7;
        }
        goto LABEL_42;
      case 7:
        if ( (*_ctype_b_loc())[v16] & 8 )
        {
          v20 = 10 * v20 + v16 - 48;
        }
        else
        {
          v26 = v20;
          v20 = 0;
          if ( v17 )
            v5 = 4;
          else
            v5 = 1;
          v18 = v5;
        }
        goto LABEL_42;
      default:
        goto LABEL_42;
    }
  }
}
// 15C10: using guessed type char var_4[4];

//----- (00016324) --------------------------------------------------------
char *__fastcall sub_16324(time_t a1, char *a2)
{
  char *dest; // [sp+0h] [bp-14h]
  time_t timer; // [sp+4h] [bp-10h]
  struct tm *tp; // [sp+Ch] [bp-8h]

  timer = a1;
  dest = a2;
  tp = gmtime(&timer);
  if ( tp )
  {
    strftime(dest, 0x1Fu, "%a, %d %b %Y %H:%M:%S GMT", tp);
  }
  else
  {
    sub_14604((int *)"gmtime failed!?!?!?");
    strcpy(dest, "?");
  }
  return dest;
}

//----- (000163B0) --------------------------------------------------------
int __fastcall sub_163B0(int a1, int a2)
{
  int v3; // r3
  int v5; // [sp+Ch] [bp-18h]
  _BYTE *v6; // [sp+10h] [bp-14h]
  signed int v7; // [sp+14h] [bp-10h]
  _BYTE *v8; // [sp+18h] [bp-Ch]
  _BYTE *v9; // [sp+1Ch] [bp-8h]

  v6 = *(_BYTE **)(a1 + 12);
  v9 = *(_BYTE **)(a1 + 8);
  if ( v9 >= v6 )
    return 0;
  v5 = *(_DWORD *)(a1 + 8);
  v8 = *(_BYTE **)(a1 + 8);
  v7 = 0;
  while ( 2 )
  {
    if ( v9 >= v6 )
    {
      sub_14604((int *)"getline: fallen off the end");
      return 0;
    }
    v3 = (unsigned __int8)*v9++;
    switch ( v3 )
    {
      case 9:
      case 13:
        goto LABEL_13;
      case 10:
        if ( v9 != v6 && a2 && (*v9 == 32 || *v9 == 9) )
        {
LABEL_13:
          *(v9 - 1) = 32;
LABEL_14:
          if ( !v7 )
          {
            v7 = 1;
            v8 = v9 - 1;
          }
          continue;
        }
        if ( v7 )
          *v8 = 0;
        else
          *(v9 - 1) = 0;
        *(_DWORD *)(a1 + 8) = v9;
        return v5;
      case 32:
        goto LABEL_14;
      default:
        v7 = 0;
        continue;
    }
  }
}

//----- (00016580) --------------------------------------------------------
int __fastcall sub_16580(char *a1, const char *a2)
{
  char *s; // [sp+0h] [bp-14h]
  char *s1; // [sp+4h] [bp-10h]
  size_t n; // [sp+Ch] [bp-8h]

  s1 = a1;
  s = (char *)a2;
  n = strlen(a2);
  if ( !n )
    return (int)s1;
  if ( strncmp(s1, s, n) || s1[n] != 47 && s1[n] && s1[n - 1] != 126 )
    return 0;
  return (int)&s1[n];
}

//----- (00016640) --------------------------------------------------------
int __fastcall sub_16640(char *a1, const char *a2)
{
  char *s; // ST00_4
  int v3; // r3
  char *s1; // [sp+4h] [bp-10h]
  size_t n; // [sp+Ch] [bp-8h]

  s1 = a1;
  s = (char *)a2;
  n = strlen(a2);
  if ( strncmp(s1, s, n) || s1[n] != 47 || s1[n + 1] )
    v3 = 0;
  else
    v3 = (int)&s1[n];
  return v3;
}

//----- (000166D0) --------------------------------------------------------
signed int __fastcall sub_166D0(_DWORD *a1, const char *a2)
{
  char *s; // [sp+0h] [bp-24h]
  _DWORD *v5; // [sp+4h] [bp-20h]
  signed int v6; // [sp+8h] [bp-1Ch]
  signed int v7; // [sp+Ch] [bp-18h]
  signed int v8; // [sp+10h] [bp-14h]
  int v9; // [sp+14h] [bp-10h]
  int v10; // [sp+18h] [bp-Ch]
  int *i; // [sp+1Ch] [bp-8h]

  v5 = a1;
  s = (char *)a2;
  v10 = 0;
  v9 = 0;
  v8 = 0;
  v7 = strlen(a2);
  for ( i = *(int **)(v5[625] + 16); i; i = (int *)i[3] )
  {
    if ( i[1] )
    {
      v6 = strlen((const char *)i[1]);
      if ( v6 > v8 && v6 <= v7 && !strcasecmp(&s[v7 - v6], (const char *)i[1]) )
      {
        v8 = v6;
        v10 = i[2];
        v9 = *i;
      }
    }
    else if ( !v10 )
    {
      v10 = i[2];
      v9 = *i;
    }
  }
  if ( !v10 )
    return -1;
  if ( dword_29F58 )
    sub_14604((int *)"get_mime: type=%s, class=%d", v10, v9);
  v5[609] = v10;
  v5[611] = v9;
  v5[610] = v8;
  return 0;
}
// 29F58: using guessed type int dword_29F58;

//----- (0001686C) --------------------------------------------------------
int __fastcall sub_1686C(int result)
{
  int v1; // [sp+4h] [bp-8h]

  v1 = result;
  if ( *(_DWORD *)(*(_DWORD *)result + 24) != -1 )
  {
    if ( dword_29F58 )
      sub_14604((int *)"close_rfd: %d", *(_DWORD *)(*(_DWORD *)result + 24));
    result = close(*(_DWORD *)(*(_DWORD *)v1 + 24));
    *(_DWORD *)(*(_DWORD *)v1 + 24) = -1;
  }
  return result;
}
// 29F58: using guessed type int dword_29F58;

//----- (000168F4) --------------------------------------------------------
signed int __fastcall sub_168F4(int a1, int a2)
{
  signed int v2; // r3
  int v4; // [sp+0h] [bp-Ch]
  int v5; // [sp+4h] [bp-8h]

  v5 = a1;
  v4 = a2;
  if ( *(_DWORD *)(*(_DWORD *)a1 + 24) != -1 )
    sub_14604((int *)"assign_rfd: rfd already assigned!?!?");
  fcntl64(v4, 2, 1);
  if ( fstat64(v4, v5 + 2504) == -1 )
  {
    sub_14840("fstat");
    v2 = -1;
  }
  else
  {
    sub_1686C(v5);
    *(_DWORD *)(*(_DWORD *)v5 + 24) = v4;
    v2 = 0;
  }
  return v2;
}
// 953C: using guessed type int __fastcall fcntl64(_DWORD, _DWORD, _DWORD);
// 9650: using guessed type int __fastcall fstat64(_DWORD, _DWORD);

//----- (00016998) --------------------------------------------------------
signed int __fastcall sub_16998(int a1)
{
  size_t v2; // r0
  int v3; // r3
  int v5; // [sp+4h] [bp-30h]
  char *v6; // [sp+Ch] [bp-28h]
  int fd; // [sp+10h] [bp-24h]
  int v8; // [sp+18h] [bp-1Ch]
  unsigned int v9; // [sp+1Ch] [bp-18h]
  char *s; // [sp+20h] [bp-14h]
  int v11; // [sp+24h] [bp-10h]
  signed int v12; // [sp+28h] [bp-Ch]
  char *src; // [sp+2Ch] [bp-8h]

  v5 = a1;
  v11 = *(_DWORD *)(a1 + 3432);
  if ( !v11 )
    return -1;
  s = (char *)(a1 + 836);
  v9 = a1 + 836 + v11;
  v2 = strlen((const char *)(a1 + 836));
  v8 = v5 + 836 + v2;
  *(_BYTE *)(v5 + 1636) = 0;
  src = (char *)(v5 + 836 + v2);
  v12 = 0;
  while ( (unsigned int)src >= v9 && *(src - 1) == 47 )
    --src;
  while ( 1 )
  {
    if ( (unsigned int)src < v9 )
      return -1;
    if ( src != (char *)v8 )
      *src = 0;
    fd = open64(s, 2048);
    if ( dword_29F58 )
      sub_14604((int *)"get_path_info: open(\"%s\") = %d", s, fd);
    if ( fd == -1 )
    {
      v3 = *_errno_location();
      if ( v3 != 2 && v3 != 20 )
      {
        sub_14604((int *)"cannot open %s", s);
        sub_14840("open");
        return -1;
      }
    }
    else
    {
      if ( sub_168F4(v5, fd) == -1 )
      {
        close(fd);
        return -1;
      }
      if ( !*(_BYTE *)(v5 + 3920) )
      {
        v12 = 1;
        strcpy((char *)(v5 + 3920), s);
      }
    }
    if ( src != (char *)v8 )
      *src = 47;
    if ( fd != -1 )
      break;
    if ( !*(_DWORD *)(*(_DWORD *)(v5 + 2500) + 88) )
      return -1;
    do
      --src;
    while ( (unsigned int)src >= v9 && *src != 47 );
  }
  strcpy((char *)(v5 + 1636), src);
  if ( (*(_DWORD *)(v5 + 2520) & 0xF000) == 0x4000 )
  {
    *src++ = 47;
  }
  else if ( v12 )
  {
    v6 = strrchr((const char *)(v5 + 3920), 47);
    if ( v6 )
      *v6 = 0;
  }
  *src = 0;
  if ( dword_29F58 )
    sub_14604((int *)"get_path_info: curdir = \"%s\"", v5 + 3920);
  return 0;
}
// 97F4: using guessed type int __fastcall open64(_DWORD, _DWORD);
// 29F58: using guessed type int dword_29F58;

//----- (00016CA4) --------------------------------------------------------
int *__fastcall sub_16CA4(int *result)
{
  int *v1; // [sp+4h] [bp-18h]
  char v2; // [sp+Bh] [bp-11h]
  signed int v3; // [sp+Ch] [bp-10h]
  int *i; // [sp+10h] [bp-Ch]
  char *v5; // [sp+14h] [bp-8h]

  v1 = result;
  if ( dword_29F58 )
    result = sub_14604((int *)"sanitize_path: old path: %s", result + 9);
  i = v1 + 9;
  v5 = (char *)(v1 + 9);
  v3 = 0;
  do
  {
    v2 = *v5++;
    switch ( v3 )
    {
      case 0:
        if ( v2 == 47 )
          v3 = 1;
        break;
      case 1:
        if ( v2 == 46 )
        {
          v3 = 2;
        }
        else if ( v2 == 47 )
        {
          i = (int *)((char *)i - 1);
        }
        else
        {
          v3 = 0;
        }
        break;
      case 2:
        if ( v2 == 46 )
        {
          v3 = 3;
        }
        else if ( v2 == 47 )
        {
          i = (int *)((char *)i - 2);
          v3 = 1;
        }
        else
        {
          v3 = 0;
        }
        break;
      case 3:
        if ( v2 == 47 )
        {
          for ( i = (int *)((char *)i - 3); v1 + 9 < i && *((_BYTE *)i - 1) != 47; i = (int *)((char *)i - 1) )
            ;
          if ( v1 + 9 < i )
            i = (int *)((char *)i - 1);
          v3 = 1;
        }
        else
        {
          v3 = 0;
        }
        break;
      default:
        break;
    }
    *(_BYTE *)i = v2;
    i = (int *)((char *)i + 1);
  }
  while ( v2 );
  if ( dword_29F58 )
    result = sub_14604((int *)"sanitize_path: new path: %s", v1 + 9);
  return result;
}
// 29F58: using guessed type int dword_29F58;

//----- (00016EBC) --------------------------------------------------------
signed int __fastcall sub_16EBC(int a1)
{
  signed int v1; // r3
  signed int v2; // r3
  signed int v4; // [sp+Ch] [bp-10h]
  char v5; // [sp+13h] [bp-9h]
  char *v6; // [sp+14h] [bp-8h]

  v6 = (char *)(a1 + 36);
  v4 = 0;
  do
  {
    v5 = *v6++;
    switch ( v4 )
    {
      case 0:
        if ( v5 == 47 )
          v4 = 1;
        break;
      case 1:
        if ( v5 == 47 )
        {
          v4 = 4;
        }
        else if ( v5 == 46 )
        {
          if ( *(_DWORD *)(*(_DWORD *)(a1 + 2500) + 72) )
            v1 = 2;
          else
            v1 = 4;
          v4 = v1;
        }
        else
        {
          v4 = 0;
        }
        break;
      case 2:
        if ( v5 && v5 != 47 )
        {
          if ( v5 == 46 )
            v4 = 3;
          else
            v4 = 0;
        }
        else
        {
          v4 = 4;
        }
        break;
      case 3:
        if ( v5 && v5 != 47 )
          v4 = 0;
        else
          v4 = 4;
        break;
      case 4:
        v5 = 0;
        break;
      default:
        break;
    }
  }
  while ( v5 );
  if ( v4 == 4 )
    v2 = -1;
  else
    v2 = 0;
  return v2;
}

//----- (00017048) --------------------------------------------------------
int __fastcall sub_17048(int a1)
{
  int v2; // [sp+Ch] [bp-10h]
  int v3; // [sp+14h] [bp-8h]

  v2 = a1;
  if ( *(_DWORD *)(a1 + 2476) )
    v3 = snprintf((char *)(a1 + 2632), 0x320u, "%s/?%s", *(_DWORD *)(a1 + 2472), *(_DWORD *)(a1 + 2476));
  else
    v3 = snprintf((char *)(a1 + 2632), 0x320u, "%s/", *(_DWORD *)(a1 + 2472));
  if ( v3 <= 799 )
  {
    if ( dword_29F58 )
      sub_14604((int *)"makedir: redirecting to %s", v2 + 2632);
    *(_DWORD *)(v2 + 2464) = v2 + 2632;
    *(_DWORD *)(v2 + 2496) = 302;
  }
  else
  {
    sub_14604((int *)"makedir: url too large");
    *(_DWORD *)(v2 + 2496) = 500;
  }
  return 0;
}
// 29F58: using guessed type int dword_29F58;

//----- (00017170) --------------------------------------------------------
signed int __fastcall sub_17170(int a1)
{
  _DWORD *v3; // [sp+4h] [bp-20h]
  int fd; // [sp+Ch] [bp-18h]
  size_t n; // [sp+10h] [bp-14h]
  size_t v6; // [sp+14h] [bp-10h]
  char *s; // [sp+18h] [bp-Ch]
  int i; // [sp+1Ch] [bp-8h]

  v3 = (_DWORD *)a1;
  s = (char *)(a1 + 836);
  v6 = strlen((const char *)(a1 + 836));
  v3[652] = 1;
  for ( i = *(_DWORD *)(v3[625] + 12); i; i = *(_DWORD *)(i + 4) )
  {
    n = strlen(*(const char **)i);
    if ( v6 + n <= 0x31E )
    {
      memcpy(&s[v6], *(const void **)i, n);
      s[v6 + n] = 0;
      fd = open64(s, 2048);
      if ( dword_29F58 )
        sub_14604((int *)"append_indexes: open(\"%s\") = %d", s, fd);
      if ( fd != -1 )
      {
        if ( sub_168F4((int)v3, fd) == -1 )
        {
          close(fd);
          return -1;
        }
        break;
      }
      if ( *_errno_location() != 2 )
      {
        sub_14604((int *)"append_indexes: cannot open %s", s);
        sub_14840("open");
        s[v6] = 0;
        v3[653] = *(_DWORD *)(v3[625] + 44);
        v3[624] = 404;
        return -1;
      }
    }
  }
  if ( i )
    return 0;
  s[v6] = 0;
  return -1;
}
// 97F4: using guessed type int __fastcall open64(_DWORD, _DWORD);
// 29F58: using guessed type int dword_29F58;

//----- (00017358) --------------------------------------------------------
signed int __fastcall sub_17358(_DWORD *a1)
{
  a1[610] = -1;
  return sub_B80C(a1);
}

//----- (0001738C) --------------------------------------------------------
signed int __fastcall sub_1738C(int a1)
{
  int v1; // r3
  _DWORD *v3; // [sp+4h] [bp-10h]
  char *s1; // [sp+Ch] [bp-8h]

  v3 = (_DWORD *)a1;
  s1 = *(char **)(a1 + 2436);
  *(_DWORD *)(a1 + 2440) = -1;
  if ( !strcasecmp(s1, "CGI") )
    return sub_B80C(v3);
  if ( v3[624] )
    return 0;
  if ( v3[623] == 5 )
  {
    if ( dword_29F58 )
      sub_14604((int *)"POST to specialty rejected");
    v3[624] = 405;
    v1 = 0;
  }
  else if ( !strcasecmp(s1, "Imagemap") )
  {
    v1 = sub_13A78((int)v3);
  }
  else if ( !strcasecmp(s1, "Redirect") )
  {
    v1 = sub_15A18(v3);
  }
  else if ( !strcasecmp(s1, "Dump") )
  {
    v1 = sub_12808((int)v3);
  }
  else
  {
    if ( dword_29F58 )
      sub_14604((int *)"unknown specialty");
    v3[653] = *(_DWORD *)(v3[625] + 44);
    v3[624] = 404;
    v1 = 0;
  }
  return v1;
}
// 29F58: using guessed type int dword_29F58;

//----- (00017510) --------------------------------------------------------
signed int __fastcall sub_17510(int a1)
{
  int v1; // r3

  *(_QWORD *)(a1 + 3488) = *(_QWORD *)(a1 + 2448);
  v1 = *(_DWORD *)(a1 + 3456);
  switch ( v1 )
  {
    case 1:
      if ( *(_QWORD *)(a1 + 3488) <= *(_QWORD *)(a1 + 3464) )
        return -1;
      *(_QWORD *)(a1 + 3472) = *(_QWORD *)(a1 + 3488) - 1LL;
      break;
    case 2:
      if ( *(_QWORD *)(a1 + 3488) <= *(_QWORD *)(a1 + 3464) )
        return -1;
      if ( *(_QWORD *)(a1 + 3488) <= *(_QWORD *)(a1 + 3472) )
        *(_QWORD *)(a1 + 3472) = *(_QWORD *)(a1 + 3488) - 1LL;
      break;
    case -1:
      if ( !*(_QWORD *)(a1 + 3480) )
        return -1;
      *(_QWORD *)(a1 + 3472) = *(_QWORD *)(a1 + 3488) - 1LL;
      if ( *(_QWORD *)(a1 + 3488) <= *(_QWORD *)(a1 + 3480) )
        *(_QWORD *)(a1 + 3464) = 0LL;
      else
        *(_QWORD *)(a1 + 3464) = *(_QWORD *)(a1 + 3488) - *(_QWORD *)(a1 + 3480);
      break;
  }
  if ( !*(_DWORD *)(a1 + 3448) || *(_DWORD *)(a1 + 2456) <= *(_DWORD *)(a1 + 3452) )
    return 0;
  *(_DWORD *)(a1 + 3456) = 0;
  return 0;
}

//----- (000177AC) --------------------------------------------------------
signed int __fastcall sub_177AC(int a1)
{
  int v3; // [sp+4h] [bp-8h]

  v3 = a1;
  if ( *(_BYTE *)(a1 + 1636)
    && !*(_DWORD *)(*(_DWORD *)(a1 + 2500) + 4)
    && (*(_BYTE *)(a1 + 1637) || !*(_DWORD *)(a1 + 2608)) )
  {
    sub_1686C(a1);
    if ( dword_29F58 )
      sub_14604((int *)"process_fd: path_args is not empty");
    *(_DWORD *)(v3 + 2612) = *(_DWORD *)(*(_DWORD *)(v3 + 2500) + 44);
    *(_DWORD *)(v3 + 2496) = 404;
    return 1;
  }
  if ( *(_DWORD *)(a1 + 2492) == 5 || *(_DWORD *)(a1 + 2492) == 3 || *(_DWORD *)(a1 + 2492) == 4 )
  {
    sub_1686C(a1);
    if ( dword_29F58 )
      sub_14604((int *)"POST to file rejected");
    *(_DWORD *)(v3 + 2496) = 405;
    return 0;
  }
  *(_QWORD *)(a1 + 2448) = *(_QWORD *)(a1 + 2552);
  *(_QWORD *)(*(_DWORD *)a1 + 368) = 0LL;
  if ( *(_DWORD *)(a1 + 2496) )
    goto LABEL_42;
  *(_DWORD *)(a1 + 2456) = *(_DWORD *)(a1 + 2584);
  if ( *(_DWORD *)(a1 + 2456) > dword_29F24 )
  {
    dword_29F24 = time(0);
    if ( *(_DWORD *)(v3 + 2456) > dword_29F24 )
    {
      sub_14604((int *)"file %s has modification time in the future", v3 + 836);
      *(_DWORD *)(v3 + 2456) = dword_29F24;
    }
  }
  if ( *(_DWORD *)(v3 + 2456) <= *(_DWORD *)(v3 + 2460) )
  {
    sub_1686C(v3);
    *(_DWORD *)(v3 + 2440) = -1;
    if ( dword_29F58 )
      sub_14604((int *)"file not modified (%ld <= %ld)", *(_DWORD *)(v3 + 2456), *(_DWORD *)(v3 + 2460));
    *(_DWORD *)(v3 + 2496) = 304;
    return 0;
  }
  if ( *(_DWORD *)(v3 + 3500) && *(_DWORD *)(v3 + 2456) > *(_DWORD *)(v3 + 3500) )
  {
    sub_1686C(v3);
    if ( dword_29F58 )
      sub_14604((int *)"file modified (%ld > %ld)", *(_DWORD *)(v3 + 2456), *(_DWORD *)(v3 + 3500));
    *(_DWORD *)(v3 + 2496) = 412;
    return 0;
  }
  if ( !*(_DWORD *)(v3 + 3456) )
  {
    *(_DWORD *)(v3 + 2496) = 200;
LABEL_42:
    if ( *(_DWORD *)(v3 + 2492) != 2 )
      sub_1686C(v3);
    return 0;
  }
  if ( sub_17510(v3) != -1 )
  {
    if ( *(_DWORD *)(v3 + 3456) )
    {
      if ( *(_QWORD *)(v3 + 3464) )
        *(_QWORD *)(*(_DWORD *)v3 + 368) = *(_QWORD *)(v3 + 3464);
      *(_QWORD *)(v3 + 2448) = *(_QWORD *)(v3 + 3472) - *(_QWORD *)(v3 + 3464) + 1LL;
      if ( dword_29F58 )
        sub_14604((int *)"returning partial content");
      *(_DWORD *)(v3 + 2496) = 206;
    }
    else
    {
      if ( dword_29F58 )
        sub_14604((int *)"range covered entire file");
      *(_DWORD *)(v3 + 2496) = 200;
    }
    goto LABEL_42;
  }
  sub_1686C(v3);
  if ( dword_29F58 )
    sub_14604((int *)"satisfy_range failed");
  *(_DWORD *)(v3 + 2496) = 416;
  return 0;
}
// 29F24: using guessed type int dword_29F24;
// 29F58: using guessed type int dword_29F58;

//----- (00017C00) --------------------------------------------------------
signed int __fastcall sub_17C00(_DWORD *a1)
{
  _DWORD *v3; // [sp+4h] [bp-10h]
  int v4; // [sp+8h] [bp-Ch]
  int v5; // [sp+Ch] [bp-8h]

  v3 = a1;
  v4 = 0;
  v5 = *(_DWORD *)(*(_DWORD *)(*a1 + 16) + 12);
  if ( a1[5] )
  {
    while ( v5 )
    {
      if ( *(_DWORD *)v5 )
      {
        if ( !strcmp((const char *)v3[5], *(const char **)v5) )
          break;
      }
      else if ( *(_DWORD *)(v5 + 12) )
      {
        v4 = v5;
      }
      v5 = *(_DWORD *)(v5 + 4);
    }
  }
  else
  {
    while ( v5 && (*(_DWORD *)v5 || *(_DWORD *)(v5 + 12)) )
      v5 = *(_DWORD *)(v5 + 4);
  }
  if ( v5 )
    goto LABEL_19;
  if ( v4 )
  {
    v5 = v4;
LABEL_19:
    v3[1] = v5;
    return 0;
  }
  return -1;
}

//----- (00017D34) --------------------------------------------------------
signed int __fastcall sub_17D34(int a1)
{
  signed int v1; // r3
  int v3; // [sp+Ch] [bp-10h]
  char *s1; // [sp+14h] [bp-8h]
  char *s1a; // [sp+14h] [bp-8h]

  v3 = a1;
  if ( !a1
    || !*(_DWORD *)(a1 + 2500)
    || !*(_DWORD *)(*(_DWORD *)(a1 + 2500) + 32)
    || !*(_DWORD *)(*(_DWORD *)(a1 + 2500) + 36) )
  {
    return 0;
  }
  s1 = *(char **)(a1 + 16);
  if ( !s1 )
    return -1;
  if ( strncasecmp(s1, "basic ", 6u) )
    return -1;
  for ( s1a = s1 + 6; *s1a == 32; ++s1a )
    ;
  if ( sub_A31C(
         (int)s1a,
         *(_DWORD *)(*(_DWORD *)(v3 + 2500) + 36),
         v3 + 2616,
         16,
         *(_DWORD *)(*(_DWORD *)(v3 + 2500) + 48)) )
  {
    v1 = 0;
  }
  else
  {
    v1 = -1;
  }
  return v1;
}

//----- (00017E64) --------------------------------------------------------
unsigned int __fastcall sub_17E64(char *a1, unsigned __int8 *a2, int a3, unsigned int a4)
{
  int v4; // ST14_4
  unsigned int v6; // [sp+0h] [bp-24h]
  int v7; // [sp+4h] [bp-20h]
  unsigned __int8 *v8; // [sp+8h] [bp-1Ch]
  char *s; // [sp+Ch] [bp-18h]
  int v10; // [sp+18h] [bp-Ch]
  unsigned int v11; // [sp+1Ch] [bp-8h]

  s = a1;
  v8 = a2;
  v7 = a3;
  v6 = a4;
  v11 = 0;
  while ( v11 < v6 )
  {
    v10 = *v8++;
    if ( !v10 )
      break;
    if ( v10 == 42 && v7 )
    {
      v4 = sprintf(s, "%.*s", v6 - v11, v7, v6);
      s += v4;
      v11 += v4;
    }
    else
    {
      *s++ = v10;
      ++v11;
    }
  }
  *s = 0;
  return v11;
}

//----- (00017F74) --------------------------------------------------------
int __fastcall sub_17F74(char *a1, char *a2, int a3, int a4, int a5)
{
  int v5; // r3
  char *v6; // r3
  int v8; // [sp+8h] [bp-2Ch]
  int v9; // [sp+Ch] [bp-28h]
  char *v10; // [sp+10h] [bp-24h]
  char *v11; // [sp+14h] [bp-20h]
  struct passwd *v12; // [sp+1Ch] [bp-18h]
  char *v13; // [sp+20h] [bp-14h]
  unsigned int v14; // [sp+24h] [bp-10h]
  size_t v15; // [sp+24h] [bp-10h]
  int v16; // [sp+24h] [bp-10h]
  char *s; // [sp+28h] [bp-Ch]
  int i; // [sp+2Ch] [bp-8h]
  int v19; // [sp+38h] [bp+4h]

  v11 = a1;
  v10 = a2;
  v9 = a3;
  v8 = a4;
  if ( *(_DWORD *)(a3 + 4) )
  {
    for ( i = **(_DWORD **)(*(_DWORD *)(a3 + 4) + 8); i; i = *(_DWORD *)(i + 20) )
    {
      if ( *(_DWORD *)(i + 24) && *(_DWORD *)i )
      {
        v6 = (char *)(*(_DWORD *)(i + 8) ? sub_16640(v11, *(const char **)i) : sub_16580(v11, *(const char **)i));
        s = v6;
        if ( v6 )
        {
          if ( !*(_DWORD *)(i + 76) )
          {
            v14 = sub_17E64(v10, **(unsigned __int8 ***)(i + 24), *(_DWORD *)(v9 + 20), a5 - 1);
            *(_DWORD *)(v9 + 3432) = v14;
            if ( ***(_BYTE ***)(i + 24) == 47 || !*(_DWORD *)(i + 4) )
              sprintf(&v10[v14], "%.*s", ~v14 + a5, s);
            break;
          }
          if ( *v6 == 47 )
            s = v6 + 1;
          v13 = strchr(s, 47);
          if ( v13 )
            *v13 = 0;
          v12 = getpwnam(s);
          if ( v13 )
            *v13 = 47;
          if ( v12 && v12->pw_dir )
          {
            v15 = strlen(v12->pw_dir);
            if ( (signed int)(v15 + 2) > a5 )
            {
              sub_14604((int *)"overflow in faketoreal");
              return 0;
            }
            v16 = sprintf(v10, "%s/%.*s", v12->pw_dir, -2 - v15 + a5, **(_DWORD **)(i + 24));
            *(_DWORD *)(v9 + 3432) = v16;
            v19 = a5 + ~v16;
            if ( v13 && (***(_BYTE ***)(i + 24) == 47 || !*(_DWORD *)(i + 4)) )
              sprintf(&v10[v16], "%.*s", v19, v13);
            break;
          }
        }
      }
    }
    if ( i && v8 )
      *(_DWORD *)(i + 24) = *(_DWORD *)(*(_DWORD *)(i + 24) + 4);
    v5 = i;
  }
  else
  {
    sub_14604((int *)"virtualhost not initialized!");
    v5 = 0;
  }
  return v5;
}

//----- (000182E4) --------------------------------------------------------
int *__fastcall sub_182E4(_DWORD *a1)
{
  int *result; // r0
  signed int v2; // r3
  int v3; // [sp+Ch] [bp-8h]

  v3 = (int)a1;
  result = (int *)sub_17C00(a1);
  if ( result == (int *)-1 )
  {
    if ( dword_29F58 )
    {
      if ( *(_DWORD *)(v3 + 20) )
        v2 = *(_DWORD *)(v3 + 20);
      else
        v2 = 133644;
      result = sub_14604((int *)"find_vs failed (host=%s)", v2);
    }
    *(_DWORD *)(v3 + 2496) = 400;
  }
  else
  {
    if ( **(_DWORD **)(*(_DWORD *)(v3 + 4) + 8) && *(_DWORD *)(**(_DWORD **)(*(_DWORD *)(v3 + 4) + 8) + 100) )
      sub_16CA4((int *)v3);
    result = (int *)sub_17F74((char *)(v3 + 36), (char *)(v3 + 836), v3, 1, 800);
    *(_DWORD *)(v3 + 2500) = result;
    if ( *(_DWORD *)(v3 + 2500) )
    {
      result = (int *)sub_16EBC(v3);
      if ( result == (int *)-1 )
      {
        if ( dword_29F58 )
          result = sub_14604((int *)"check_path failed for %s", v3 + 36);
        *(_DWORD *)(v3 + 2612) = *(_DWORD *)(*(_DWORD *)(v3 + 2500) + 44);
        *(_DWORD *)(v3 + 2496) = 404;
      }
      else if ( *(_DWORD *)(*(_DWORD *)(v3 + 2500) + 32) )
      {
        result = (int *)sub_17D34(v3);
        if ( result == (int *)-1 )
        {
          if ( dword_29F58 )
            result = sub_14604((int *)"login incorrect");
          *(_DWORD *)(v3 + 2612) = *(_DWORD *)(*(_DWORD *)(v3 + 2500) + 40);
          *(_DWORD *)(v3 + 2496) = 401;
        }
      }
    }
    else
    {
      if ( dword_29F58 )
        result = sub_14604((int *)"faketoreal failed");
      *(_DWORD *)(v3 + 2496) = 404;
    }
  }
  return result;
}
// 29F58: using guessed type int dword_29F58;

//----- (000184EC) --------------------------------------------------------
int __fastcall sub_184EC(int a1)
{
  signed int v1; // r3
  int v2; // r3
  int v4; // [sp+4h] [bp-8h]

  v4 = a1;
  if ( *(_DWORD *)(a1 + 2492) == 6 )
  {
    strcpy((void *)(a1 + 3920), "/");
  }
  else
  {
    if ( !*(_BYTE *)(a1 + 836) )
    {
      if ( dword_29F58 )
        sub_14604((int *)"empty path_translated");
      *(_DWORD *)(v4 + 2496) = 500;
      return 0;
    }
    if ( *(_BYTE *)(a1 + 836) != 47 )
    {
      if ( *(_DWORD *)(a1 + 2496) )
        return 0;
      *(_DWORD *)(a1 + 2464) = a1 + 836;
      if ( dword_29F58 )
        sub_14604((int *)"redirecting");
      *(_DWORD *)(v4 + 2496) = 302;
      return 0;
    }
    if ( sub_16998(a1) == -1 )
    {
      if ( dword_29F58 )
        sub_14604((int *)"get_path_info failed for %s", v4 + 836);
      if ( *(_DWORD *)(v4 + 2496) )
        return 0;
      *(_DWORD *)(v4 + 2612) = *(_DWORD *)(*(_DWORD *)(v4 + 2500) + 44);
      *(_DWORD *)(v4 + 2496) = 404;
      return 1;
    }
    if ( (*(_DWORD *)(v4 + 2520) & 0xF000) == 0x4000 )
    {
      sub_1686C(v4);
      if ( *(_DWORD *)(v4 + 2496) )
        return 0;
      if ( *(_BYTE *)(v4 + 1636) != 47 )
        return sub_17048(v4);
      if ( sub_17170(v4) == -1 )
      {
        if ( *(_DWORD *)(v4 + 2496) )
          return 1;
        if ( *(_BYTE *)(v4 + 1637) || !*(_DWORD *)(*(_DWORD *)(v4 + 2500) + 92) )
        {
          if ( dword_29F58 )
            sub_14604((int *)"file not found");
          *(_DWORD *)(v4 + 2612) = *(_DWORD *)(*(_DWORD *)(v4 + 2500) + 44);
          *(_DWORD *)(v4 + 2496) = 404;
          v1 = 1;
        }
        else if ( *(_DWORD *)(v4 + 2492) == 5 )
        {
          if ( dword_29F58 )
            sub_14604((int *)"POST to AutoIndexCommand rejected");
          *(_DWORD *)(v4 + 2496) = 405;
          v1 = 0;
        }
        else
        {
          *(_DWORD *)(v4 + 2612) = *(_DWORD *)(*(_DWORD *)(v4 + 2500) + 92);
          v1 = 1;
        }
        return v1;
      }
    }
    if ( *(_BYTE *)(v4 + 1636) && !*(_DWORD *)(*(_DWORD *)(v4 + 2500) + 88) && !*(_DWORD *)(v4 + 2608) )
    {
      sub_1686C(v4);
      if ( dword_29F58 )
        sub_14604((int *)"nonempty path_args while PathInfo is off");
      *(_DWORD *)(v4 + 2612) = *(_DWORD *)(*(_DWORD *)(v4 + 2500) + 44);
      *(_DWORD *)(v4 + 2496) = 404;
      return 1;
    }
    if ( (*(_DWORD *)(v4 + 2520) & 0xF000) != 0x8000 )
    {
      sub_1686C(v4);
      sub_14604((int *)"%s is not a regular file", v4 + 836);
      *(_DWORD *)(v4 + 2612) = *(_DWORD *)(*(_DWORD *)(v4 + 2500) + 44);
      *(_DWORD *)(v4 + 2496) = 404;
      return 1;
    }
  }
  if ( sub_166D0((_DWORD *)v4, (const char *)(v4 + 836)) == -1 )
  {
    sub_1686C(v4);
    sub_14604((int *)"get_mime failed for %s", v4 + 836);
    *(_DWORD *)(v4 + 2612) = *(_DWORD *)(*(_DWORD *)(v4 + 2500) + 44);
    *(_DWORD *)(v4 + 2496) = 404;
    v1 = 1;
  }
  else
  {
    if ( *(_DWORD *)(v4 + 2444) != 1 )
      sub_1686C(v4);
    v2 = *(_DWORD *)(v4 + 2444);
    switch ( v2 )
    {
      case 2:
        v1 = sub_1738C(v4);
        break;
      case 3:
        v1 = sub_17358((_DWORD *)v4);
        break;
      case 1:
        v1 = sub_177AC(v4);
        break;
      default:
        sub_14604((int *)"unknown class!?");
        *(_DWORD *)(v4 + 2496) = 500;
        v1 = 0;
        break;
    }
  }
  return v1;
}
// 29F58: using guessed type int dword_29F58;

//----- (00018980) --------------------------------------------------------
signed int __fastcall sub_18980(int a1, const char *a2)
{
  signed int v2; // r3
  char *s1; // [sp+0h] [bp-2Ch]
  char *s1a; // [sp+0h] [bp-2Ch]
  char *s1b; // [sp+0h] [bp-2Ch]
  char *s1c; // [sp+0h] [bp-2Ch]
  int v8; // [sp+4h] [bp-28h]
  char *endptr; // [sp+Ch] [bp-20h]
  uintmax_t v10; // [sp+10h] [bp-1Ch]
  uintmax_t v11; // [sp+18h] [bp-14h]
  _BOOL4 v12; // [sp+24h] [bp-8h]

  v8 = a1;
  s1 = (char *)a2;
  if ( strncasecmp(a2, "bytes", 5u) )
    return -1;
  for ( s1a = s1 + 5; *s1a == 32; ++s1a )
    ;
  if ( *s1a != 61 )
    return -1;
  do
    ++s1a;
  while ( *s1a == 32 );
  v12 = *s1a == 45;
  if ( !v12 )
    goto LABEL_42;
  do
    ++s1a;
  while ( *s1a == 32 );
  if ( *s1a == 45 )
    return -1;
LABEL_42:
  v11 = strtoumax(s1a, &endptr, 10);
  if ( endptr == s1a )
    return -1;
  for ( s1b = endptr; *s1b == 32; ++s1b )
    ;
  if ( v12 )
  {
    if ( *s1b )
    {
      v2 = -1;
    }
    else
    {
      *(_DWORD *)(v8 + 3456) = -1;
      *(_QWORD *)(v8 + 3480) = v11;
      v2 = 0;
    }
  }
  else if ( *s1b == 45 )
  {
    do
      ++s1b;
    while ( *s1b == 32 );
    if ( *s1b )
    {
      if ( *s1b == 45 )
      {
        v2 = -1;
      }
      else
      {
        v10 = strtoumax(s1b, &endptr, 10);
        if ( endptr == s1b )
        {
          v2 = -1;
        }
        else
        {
          for ( s1c = endptr; *s1c == 32; ++s1c )
            ;
          if ( *s1c )
          {
            v2 = -1;
          }
          else if ( v11 <= v10 )
          {
            *(_DWORD *)(v8 + 3456) = 2;
            *(_QWORD *)(v8 + 3464) = v11;
            *(_QWORD *)(v8 + 3472) = v10;
            v2 = 0;
          }
          else
          {
            v2 = -1;
          }
        }
      }
    }
    else
    {
      *(_DWORD *)(v8 + 3456) = 1;
      *(_QWORD *)(v8 + 3464) = v11;
      v2 = 0;
    }
  }
  else
  {
    v2 = -1;
  }
  return v2;
}

//----- (00018C88) --------------------------------------------------------
signed int __fastcall sub_18C88(int a1)
{
  int v3; // [sp+4h] [bp-18h]
  char *endptr; // [sp+8h] [bp-14h]
  int v5; // [sp+Ch] [bp-10h]
  int v6; // [sp+10h] [bp-Ch]
  char *s1; // [sp+14h] [bp-8h]

  v3 = a1;
  s1 = *(char **)(a1 + 2480);
  if ( !s1 )
    return 0;
  if ( strncmp(s1, "HTTP", 4u) )
    return -1;
  for ( s1 += 4; *s1 == 32; ++s1 )
    ;
  if ( *s1 != 47 )
    return -1;
  do
    ++s1;
  while ( *s1 == 32 );
  if ( *s1 == 45 )
    return -1;
  v6 = strtoul(s1, &endptr, 10);
  if ( endptr == s1 )
    return -1;
  for ( s1 = endptr; *s1 == 32; ++s1 )
    ;
  if ( *s1 != 46 )
    return -1;
  do
    ++s1;
  while ( *s1 == 32 );
  if ( *s1 == 45 )
    return -1;
  v5 = strtoul(s1, &endptr, 10);
  if ( endptr == s1 || *endptr )
    return -1;
  if ( !v6 || v6 < 0 || v5 < 0 )
    return -1;
  *(_DWORD *)(v3 + 2484) = v6;
  *(_DWORD *)(v3 + 2488) = v5;
  return 0;
}

//----- (00018E90) --------------------------------------------------------
_BYTE *__fastcall sub_18E90(_BYTE *a1, _DWORD *a2)
{
  _BYTE *i; // [sp+4h] [bp-18h]
  char v4; // [sp+Bh] [bp-11h]
  int v5; // [sp+Ch] [bp-10h]
  char v6; // [sp+13h] [bp-9h]
  _BOOL4 v7; // [sp+14h] [bp-8h]

  for ( i = a1; *i == 44 || *i == 32; ++i )
    ;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  while ( 1 )
  {
    v4 = i[v5];
    if ( !v4 || v4 == 44 && !v7 )
      break;
    if ( v4 == 34 && (!v7 || v6 != 92) )
      v7 = v7 == 0;
    v6 = i[v5++];
  }
  while ( v5 && i[v5 - 1] == 32 )
    --v5;
  *a2 = v5;
  return i;
}

//----- (00018FD4) --------------------------------------------------------
const char *__fastcall sub_18FD4(int a1, char *a2)
{
  const char *result; // r0
  char *s1; // [sp+0h] [bp-14h]
  char *s1a; // [sp+0h] [bp-14h]
  int v5; // [sp+4h] [bp-10h]
  size_t n; // [sp+Ch] [bp-8h]

  v5 = a1;
  for ( s1 = a2; ; s1 = &s1a[n] )
  {
    result = sub_18E90(s1, &n);
    s1a = (char *)result;
    if ( !n )
      break;
    if ( n == 10 && !strncasecmp(result, "keep-alive", 0xAu) )
    {
      *(_DWORD *)(*(_DWORD *)v5 + 272) = 1;
    }
    else if ( n == 5 && !strncasecmp(s1a, "close", 5u) )
    {
      *(_DWORD *)(*(_DWORD *)v5 + 272) = 0;
    }
  }
  return result;
}

//----- (000190AC) --------------------------------------------------------
signed int __fastcall sub_190AC(int a1, char *a2)
{
  char *s1; // [sp+0h] [bp-14h]
  char *s1a; // [sp+0h] [bp-14h]
  int v6; // [sp+4h] [bp-10h]
  size_t n; // [sp+Ch] [bp-8h]

  v6 = a1;
  for ( s1 = a2; ; s1 = &s1a[n] )
  {
    s1a = sub_18E90(s1, &n);
    if ( !n )
      return 0;
    if ( n != 12 || strncasecmp(s1a, "100-continue", 0xCu) )
      break;
    *(_DWORD *)(v6 + 4720) = 1;
  }
  return -1;
}

//----- (00019150) --------------------------------------------------------
signed int __fastcall sub_19150(int a1)
{
  char *v2; // r3
  size_t v3; // r0
  int v5; // [sp+Ch] [bp-28h]
  char *src; // [sp+10h] [bp-24h]
  int v7; // [sp+14h] [bp-20h]
  unsigned __int64 v8; // [sp+18h] [bp-1Ch]
  char *s; // [sp+24h] [bp-10h]
  unsigned int v10; // [sp+28h] [bp-Ch]
  char *s1; // [sp+2Ch] [bp-8h]

  v5 = a1;
  do
  {
    s = (char *)sub_163B0(*(_DWORD *)v5 + 160, 0);
    if ( !s )
      return -1;
  }
  while ( !*s );
  *(_DWORD *)(v5 + 2468) = s;
  src = strchr(s, 32);
  if ( !src )
    return -1;
  v2 = src;
  *src = 0;
  src = v2 + 1;
  *(_DWORD *)(v5 + 2472) = v2 + 1;
  s1 = strrchr(src, 72);
  if ( !s1 || s1 == src || *(s1 - 1) != 32 )
    return -1;
  *(_DWORD *)(v5 + 2480) = s1;
  *(s1 - 1) = 0;
  s1 = strchr(src, 63);
  if ( s1 )
  {
    *(_DWORD *)(v5 + 2476) = s1 + 1;
    *s1 = 0;
  }
  if ( sub_18C88(v5) == -1 )
  {
    if ( dword_29F58 )
      sub_14604((int *)"parse_http_version failed for \"%s\"", *(_DWORD *)(v5 + 2480));
    *(_DWORD *)(v5 + 2496) = 400;
    return 0;
  }
  if ( *(_DWORD *)(v5 + 2484) && *(_DWORD *)(v5 + 2488) )
    *(_DWORD *)(*(_DWORD *)v5 + 272) = 1;
  v10 = 0;
  do
  {
    while ( 1 )
    {
      do
      {
        while ( 1 )
        {
          while ( 1 )
          {
            s = (char *)sub_163B0(*(_DWORD *)v5 + 160, 1);
            if ( !s )
            {
              *(_DWORD *)(v5 + 3436) = v10;
              sub_14604(
                (int *)"%s: method[%s], nheaders=[%d], URL[%s]",
                136444,
                *(_DWORD *)(v5 + 2468),
                v10,
                *(_DWORD *)(v5 + 2472));
              s1 = *(char **)(v5 + 2468);
              if ( !strcmp(s1, "GET") )
              {
                *(_DWORD *)(v5 + 2492) = 2;
              }
              else if ( !strcmp(s1, "HEAD") )
              {
                *(_DWORD *)(v5 + 2492) = 1;
              }
              else if ( !strcmp(s1, "POST") )
              {
                *(_DWORD *)(v5 + 2492) = 5;
              }
              else if ( !strcmp(s1, "PUT") )
              {
                *(_DWORD *)(v5 + 2492) = 3;
              }
              else if ( !strcmp(s1, "DELETE") )
              {
                *(_DWORD *)(v5 + 2492) = 4;
              }
              else if ( !strcmp(s1, "M-SEARCH") )
              {
                *(_DWORD *)(v5 + 2492) = 6;
              }
              else if ( !strcmp(s1, "SUBSCRIBE") )
              {
                *(_DWORD *)(v5 + 2492) = 7;
              }
              else
              {
                if ( strcmp(s1, "UNSUBSCRIBE") )
                {
                  if ( dword_29F58 )
                    sub_14604((int *)"method \"%s\" not implemented", s1);
                  *(_DWORD *)(v5 + 2496) = 501;
                  return 0;
                }
                *(_DWORD *)(v5 + 2492) = 8;
              }
              s1 = *(char **)(v5 + 2472);
              if ( strlen(s1) > 0x190 )
              {
                if ( dword_29F58 )
                {
                  v3 = strlen(s1);
                  sub_14604((int *)"url too long (%zu > %d)", v3, 400);
                }
                *(_DWORD *)(v5 + 2496) = 414;
                return 0;
              }
              if ( *(_DWORD *)(v5 + 2492) == 6 )
              {
                if ( strcmp(s1, "*") )
                {
                  if ( dword_29F58 )
                    sub_14604((int *)"M-SEARCH allow accept '*'");
                  *(_DWORD *)(v5 + 2496) = 400;
                  return 0;
                }
              }
              else if ( *s1 != 47 )
              {
                src = strchr(s1, 47);
                if ( !src || src[1] != 47 || !src[2] || src[2] == 47 )
                {
                  if ( dword_29F58 )
                    sub_14604((int *)"absoluteURI \"%s\" should contain a net_loc", *(_DWORD *)(v5 + 2472));
                  *(_DWORD *)(v5 + 2496) = 400;
                  return 0;
                }
                src += 2;
                s1 = strchr(src, 47);
                if ( s1 )
                {
                  memcpy((void *)(v5 + 3504), src, s1 - src);
                  *(_BYTE *)(v5 + s1 - src + 3504) = 0;
                }
                else
                {
                  strcpy((char *)(v5 + 3504), src);
                }
                *(_DWORD *)(v5 + 20) = v5 + 3504;
                sub_1B89C(*(const char **)(v5 + 20));
              }
              if ( !*(_DWORD *)(v5 + 20) && *(_DWORD *)(v5 + 2488) == 1 )
              {
                if ( dword_29F58 )
                  sub_14604((int *)"HTTP/1.1 request without Host");
                *(_DWORD *)(v5 + 2496) = 400;
                return 0;
              }
              if ( *(_DWORD *)(v5 + 20) && !**(_BYTE **)(v5 + 20) )
              {
                if ( dword_29F58 )
                  sub_14604((int *)"empty Host header");
                *(_DWORD *)(v5 + 2496) = 400;
                return 0;
              }
              if ( s1 )
              {
                if ( sub_1B3EC((unsigned __int8 *)s1, (_BYTE *)(v5 + 36)) == -1 )
                {
                  if ( dword_29F58 )
                    sub_14604((int *)"unescape_url failed for \"%s\"", s1);
                  *(_DWORD *)(v5 + 2496) = 400;
                  return 0;
                }
              }
              else
              {
                strcpy((void *)(v5 + 36), "/");
              }
              if ( *(_DWORD *)(v5 + 2484) > 1 || *(_DWORD *)(v5 + 2484) == 1 && *(_DWORD *)(v5 + 2488) > 1 )
              {
                *(_DWORD *)(v5 + 2496) = 505;
                return 0;
              }
              if ( *(_DWORD *)(v5 + 3904) )
              {
                if ( strcasecmp(*(const char **)(v5 + 3904), "chunked") )
                {
                  sub_14604((int *)"unimplemented transfer-coding \"%s\"", *(_DWORD *)(v5 + 3904));
                  *(_DWORD *)(v5 + 2496) = 501;
                  return 0;
                }
                if ( *(_DWORD *)(v5 + 28) )
                {
                  sub_14604((int *)"ignoring Content-Length header from client");
                  *(_DWORD *)(v5 + 28) = 0;
                }
              }
              s1 = *(char **)(v5 + 28);
              if ( s1 )
              {
                v8 = strtoull(s1, &src, 10);
                if ( src == s1 || *src )
                {
                  sub_14604((int *)"bad Content-Length from client: \"%s\"", s1);
                  *(_DWORD *)(v5 + 2496) = 400;
                  return 0;
                }
                *(_QWORD *)(v5 + 3912) = v8;
              }
              if ( *(_DWORD *)(v5 + 2492) == 2 )
              {
                s1 = *(char **)(v5 + 32);
                if ( s1 )
                {
                  v7 = sub_15C10((unsigned __int8 *)s1);
                  if ( v7 != -1 && v7 <= dword_29F24 )
                    *(_DWORD *)(v5 + 2460) = v7;
                }
                s1 = *(char **)(v5 + 3496);
                if ( s1 )
                {
                  v7 = sub_15C10((unsigned __int8 *)s1);
                  if ( v7 != -1 )
                    *(_DWORD *)(v5 + 3500) = v7;
                }
                s1 = *(char **)(v5 + 3448);
                if ( s1 )
                {
                  v7 = sub_15C10((unsigned __int8 *)s1);
                  if ( v7 != -1 )
                    *(_DWORD *)(v5 + 3452) = v7;
                }
                s1 = *(char **)(v5 + 3444);
                if ( s1 && sub_18980(v5, s1) == -1 )
                  sub_14604((int *)"ignoring Range header \"%s\"", s1);
              }
              else if ( *(_DWORD *)(v5 + 2492) == 5 )
              {
                if ( !*(_DWORD *)(v5 + 28) )
                {
                  if ( dword_29F58 )
                    sub_14604((int *)"POST: length required");
                  *(_DWORD *)(v5 + 2496) = 411;
                  return 0;
                }
              }
              else if ( *(_DWORD *)(v5 + 2492) == 3 && !*(_DWORD *)(v5 + 28) )
              {
                if ( dword_29F58 )
                  sub_14604((int *)"PUT: length required");
                *(_DWORD *)(v5 + 2496) = 411;
                return 0;
              }
              if ( *(_DWORD *)(v5 + 4720) )
              {
                if ( *(_DWORD *)(v5 + 2488) || *(_DWORD *)(v5 + 2484) != 1 )
                {
                  if ( *(_DWORD *)(v5 + 28) && *(_QWORD *)(v5 + 3912) || *(_DWORD *)(v5 + 3904) )
                  {
                    if ( *(_DWORD *)(*(_DWORD *)v5 + 176) > *(_DWORD *)(*(_DWORD *)v5 + 172) )
                    {
                      if ( dword_29F58 )
                        sub_14604((int *)"suppressing '100 Continue' response (more input received)");
                      *(_DWORD *)(v5 + 4720) = 0;
                    }
                  }
                  else
                  {
                    if ( dword_29F58 )
                      sub_14604((int *)"suppressing '100 Continue' response (no body)");
                    *(_DWORD *)(v5 + 4720) = 0;
                  }
                }
                else
                {
                  if ( dword_29F58 )
                    sub_14604((int *)"suppressing '100 Continue' response (HTTP/1.0 client)");
                  *(_DWORD *)(v5 + 4720) = 0;
                }
              }
              return 1;
            }
            s1 = strchr(s, 58);
            if ( s1 )
            {
              *s1++ = 0;
              while ( *s1 == 32 )
                ++s1;
              if ( *s1 )
                break;
            }
          }
          if ( strcasecmp(s, "Connection") )
            break;
          sub_18FD4(v5, s1);
        }
      }
      while ( !strcasecmp(s, "Keep-Alive") );
      if ( !strcasecmp(s, "Expect") )
        break;
      if ( !strcasecmp(s, "Content-Type") )
      {
        *(_DWORD *)(v5 + 24) = s1;
      }
      else if ( !strcasecmp(s, "Content-Length") )
      {
        *(_DWORD *)(v5 + 28) = s1;
      }
      else if ( !strcasecmp(s, "Transfer-Encoding") )
      {
        *(_DWORD *)(v5 + 3904) = s1;
      }
      else
      {
        if ( dword_29EFC > v10 )
        {
          *(_DWORD *)(*(_DWORD *)(v5 + 3440) + 8 * v10) = s;
          *(_DWORD *)(*(_DWORD *)(v5 + 3440) + 8 * v10++ + 4) = s1;
        }
        if ( !strcasecmp(s, "User-agent") )
        {
          *(_DWORD *)(v5 + 8) = s1;
        }
        else if ( !strcasecmp(s, "Referer") )
        {
          *(_DWORD *)(v5 + 12) = s1;
        }
        else if ( !strcasecmp(s, "Authorization") )
        {
          *(_DWORD *)(v5 + 16) = s1;
        }
        else if ( !strcasecmp(s, "Host") )
        {
          sub_1B89C(s1);
          *(_DWORD *)(v5 + 20) = s1;
        }
        else if ( !strcasecmp(s, "If-Modified-Since") )
        {
          *(_DWORD *)(v5 + 32) = s1;
        }
        else if ( !strcasecmp(s, "If-Unmodified-Since") )
        {
          *(_DWORD *)(v5 + 3496) = s1;
        }
        else if ( !strcasecmp(s, "Range") )
        {
          if ( *(_DWORD *)(v5 + 3444) )
          {
            sub_14604((int *)"multiple Range headers");
            *(_DWORD *)(v5 + 2496) = 400;
            return 0;
          }
          *(_DWORD *)(v5 + 3444) = s1;
        }
        else if ( !strcasecmp(s, "If-Range") )
        {
          *(_DWORD *)(v5 + 3448) = s1;
        }
      }
    }
  }
  while ( sub_190AC(v5, s1) != -1 );
  if ( dword_29F58 )
    sub_14604((int *)"parse_expect_header failed for \"%s\"", s1);
  *(_DWORD *)(v5 + 2496) = 417;
  return 0;
}
// 29EFC: using guessed type int dword_29EFC;
// 29F24: using guessed type int dword_29F24;
// 29F58: using guessed type int dword_29F58;

//----- (0001A08C) --------------------------------------------------------
signed int __fastcall sub_1A08C(signed int a1)
{
  signed int v1; // r3

  if ( a1 == 404 )
    return 135116;
  if ( a1 > 404 )
  {
    if ( a1 == 416 )
    {
      v1 = 135228;
    }
    else if ( a1 > 416 )
    {
      if ( a1 == 501 )
      {
        v1 = 135288;
      }
      else if ( a1 > 501 )
      {
        if ( a1 == 503 )
        {
          v1 = 135308;
        }
        else
        {
          if ( a1 != 505 )
            return 135364;
          v1 = 135332;
        }
      }
      else
      {
        if ( a1 != 417 )
          return 135364;
        v1 = 135264;
      }
    }
    else if ( a1 == 411 )
    {
      v1 = 135156;
    }
    else if ( a1 > 411 )
    {
      if ( a1 == 412 )
      {
        v1 = 135176;
      }
      else
      {
        if ( a1 != 414 )
          return 135364;
        v1 = 135200;
      }
    }
    else
    {
      if ( a1 != 405 )
        return 135364;
      v1 = 135132;
    }
  }
  else if ( a1 == 302 )
  {
    v1 = 135032;
  }
  else if ( a1 > 302 )
  {
    if ( a1 == 400 )
    {
      v1 = 135064;
    }
    else if ( a1 > 400 )
    {
      if ( a1 == 401 )
      {
        v1 = 135080;
      }
      else
      {
        if ( a1 != 403 )
          return 135364;
        v1 = 135100;
      }
    }
    else
    {
      if ( a1 != 304 )
        return 135364;
      v1 = 135044;
    }
  }
  else if ( a1 == 200 )
  {
    v1 = 134988;
  }
  else if ( a1 > 200 )
  {
    if ( a1 == 204 )
    {
      v1 = 134996;
    }
    else
    {
      if ( a1 != 206 )
        return 135364;
      v1 = 135012;
    }
  }
  else
  {
    if ( a1 != 100 )
      return 135364;
    v1 = 134972;
  }
  return v1;
}

//----- (0001A2C0) --------------------------------------------------------
signed int sub_1A2C0(int a1, const char *a2, ...)
{
  unsigned int maxlen; // ST14_4
  int v5; // [sp+4h] [bp-1Ch]
  unsigned int v6; // [sp+10h] [bp-10h]
  va_list varg_r2; // [sp+28h] [bp+8h]

  va_start(varg_r2, a2);
  v5 = a1;
  if ( *(_DWORD *)(a1 + 4) <= *(_DWORD *)(a1 + 16) )
    return -1;
  maxlen = *(_DWORD *)(a1 + 4) - *(_DWORD *)(a1 + 16);
  v6 = vsnprintf(*(char **)(a1 + 16), maxlen, a2, varg_r2);
  if ( v6 >= maxlen )
    return -1;
  *(_DWORD *)(v5 + 16) += v6;
  return v6;
}

//----- (0001A380) --------------------------------------------------------
signed int __fastcall sub_1A380(_DWORD *a1)
{
  signed int v1; // r3
  _BOOL4 v2; // r3
  char *v3; // r0
  signed int v4; // r3
  char *v5; // r0
  char *v6; // r0
  signed int v7; // r3
  __int64 v8; // ST00_8
  _DWORD *v10; // [sp+14h] [bp-58h]
  char v11; // [sp+1Ch] [bp-50h]
  time_t v12; // [sp+44h] [bp-28h]
  int v13; // [sp+48h] [bp-24h]
  _BOOL4 v14; // [sp+4Ch] [bp-20h]
  int v15; // [sp+50h] [bp-1Ch]
  _BYTE *v16; // [sp+54h] [bp-18h]
  char *s; // [sp+58h] [bp-14h]
  _DWORD *i; // [sp+5Ch] [bp-10h]

  v10 = a1;
  if ( a1[1181] )
    return 0;
  if ( a1[7] || a1[976] )
  {
    if ( dword_29F58 )
      sub_14604((int *)"client sent request-body; turning off keepalive");
    *(_DWORD *)(*v10 + 272) = 0;
  }
  v15 = *v10 + 188;
  v2 = *(_DWORD *)(*v10 + 24) == -1 && v10[623] != 1 && v10[624] != 204 && v10[624] != 304;
  v14 = v2;
  v13 = sub_1A08C(v10[624]);
  v16 = 0;
  s = 0;
  if ( v14 )
  {
    v10[610] = 0;
    v10[609] = 135440;
    *((_QWORD *)v10 + 306) = *(_DWORD *)(v15 + 4) - *(_DWORD *)v15;
  }
  if ( v10[624] > 399 )
    v10[614] = 0;
  v3 = sub_16324(dword_29F24, &v11);
  if ( sub_1A2C0(v15, "HTTP/1.1 %s\r\nServer: %s\r\nDate: %s\r\n", v13, 131804, v3) == -1 )
    return -1;
  v4 = v10[624];
  if ( v4 == 401 )
  {
    if ( v10[625]
      && *(_DWORD *)(v10[625] + 32)
      && sub_1A2C0(v15, "WWW-Authenticate: Basic realm=\"%s\"\r\n", *(_DWORD *)(v10[625] + 32)) == -1 )
    {
      return -1;
    }
  }
  else if ( v4 > 401 )
  {
    if ( v4 == 405 )
    {
      if ( sub_1A2C0(v15, "Allow: GET, HEAD\r\n") == -1 )
        return -1;
    }
    else if ( v4 == 416 && sub_1A2C0(v15, "Content-Range: bytes */%ju\r\n", *((_QWORD *)v10 + 436)) == -1 )
    {
      return -1;
    }
  }
  else if ( v4 == 206 )
  {
    if ( sub_1A2C0(
           v15,
           "Content-Range: bytes %ju-%ju/%ju\r\n",
           *((_QWORD *)v10 + 433),
           *((_QWORD *)v10 + 434),
           *((_QWORD *)v10 + 436)) == -1 )
      return -1;
  }
  else if ( v4 == 302 && v10[616] && sub_1A2C0(v15, "Location: %s\r\n", v10[616]) == -1 )
  {
    return -1;
  }
  if ( v10[610] >= 0 )
  {
    if ( sub_1A2C0(v15, "Content-Type: %s\r\n", v10[609]) == -1 )
      return -1;
    if ( sub_1A2C0(v15, "Content-Length: ") == -1 )
      return -1;
    s = *(char **)(v15 + 16);
    if ( sub_1A2C0(v15, "%jd", *((_QWORD *)v10 + 306)) == -1 )
      return -1;
    v16 = *(_BYTE **)(v15 + 16);
    if ( sub_1A2C0(v15, "\r\n") == -1 )
      return -1;
    if ( v10[614] )
    {
      v5 = sub_16324(v10[614], &v11);
      if ( sub_1A2C0(v15, "Last-Modified: %s\r\n", v5) == -1 )
        return -1;
    }
  }
  if ( *(_DWORD *)(*v10 + 272) )
  {
    if ( !v10[622] && sub_1A2C0(v15, "Connection: keep-alive\r\n") == -1 )
      return -1;
  }
  else if ( v10[622] && sub_1A2C0(v15, "Connection: close\r\n") == -1 )
  {
    return -1;
  }
  if ( v10[625] && v10[624] == 200 )
  {
    if ( *(_DWORD *)(v10[625] + 96) )
    {
      v12 = *(_DWORD *)(v10[625] + 96) + dword_29F24;
      v6 = sub_16324(v12, &v11);
      if ( sub_1A2C0(v15, "Expires: %s\r\n", v6) == -1 )
        return -1;
    }
    for ( i = *(_DWORD **)(v10[625] + 84); i; i = (_DWORD *)i[1] )
    {
      if ( sub_1A2C0(v15, "%s\r\n", *i) == -1 )
        return -1;
    }
  }
  if ( sub_1A2C0(v15, "\r\n") == -1 )
    return -1;
  *(_DWORD *)(v15 + 12) = *(_DWORD *)(v15 + 16);
  if ( !v14 )
    return 0;
  if ( sub_1A2C0(v15, "<title>%s</title>\n<h1>%s</h1>\n", v13, v13) == -1 )
    return -1;
  v7 = v10[624];
  if ( v7 == 404 )
  {
    if ( sub_1A2C0(v15, "The resource requested could not be found on this server.\n") == -1 )
      return -1;
    goto LABEL_104;
  }
  if ( v7 <= 404 )
  {
    if ( v7 != 400 )
    {
      if ( v7 > 400 )
      {
        if ( v7 == 401 )
        {
          if ( sub_1A2C0(v15, "You need proper authorization to use this resource.\n") == -1 )
            return -1;
        }
        else if ( v7 == 403 && sub_1A2C0(v15, "Access to this resource has been denied to you.\n") == -1 )
        {
          return -1;
        }
      }
      else if ( v7 == 302
             && sub_1A2C0(v15, "This document has moved to URL <a href=\"%s\">%s</a>.\n", v10[616], v10[616]) == -1 )
      {
        return -1;
      }
      goto LABEL_104;
    }
    goto LABEL_96;
  }
  if ( v7 == 501 )
    goto LABEL_96;
  if ( v7 <= 501 )
  {
    if ( v7 != 405 )
      goto LABEL_104;
LABEL_96:
    if ( sub_1A2C0(v15, "Your request was not understood or not allowed by this server.\n") == -1 )
      return -1;
    goto LABEL_104;
  }
  if ( v7 == 503 )
  {
    if ( sub_1A2C0(v15, "The server is temporarily busy.\n") == -1 )
      return -1;
    goto LABEL_104;
  }
  if ( v7 == 505 )
    goto LABEL_96;
LABEL_104:
  if ( v10[625]
    && *(_DWORD *)(v10[625] + 28)
    && sub_1A2C0(v15, "<p>Please contact the site administrator at <i>%s</i>.\n", *(_DWORD *)(v10[625] + 28)) == -1 )
  {
    return -1;
  }
  *((_QWORD *)v10 + 306) = *(_DWORD *)(v15 + 16) - *(_DWORD *)(v15 + 12);
  if ( s )
  {
    v8 = *((_QWORD *)v10 + 306);
    sprintf(s, "%*jd", v16 - s);
    *v16 = 13;
    v1 = 0;
  }
  else
  {
    sub_14604((int *)"cl_start is null!?!?");
    v1 = -1;
  }
  return v1;
}
// 29F24: using guessed type int dword_29F24;
// 29F58: using guessed type int dword_29F58;

//----- (0001ACC4) --------------------------------------------------------
int __fastcall sub_1ACC4(int result)
{
  *(_DWORD *)(result + 4) = 0;
  *(_DWORD *)(result + 8) = 0;
  *(_DWORD *)(result + 12) = 0;
  *(_DWORD *)(result + 16) = 0;
  *(_DWORD *)(result + 20) = 0;
  *(_DWORD *)(result + 24) = 0;
  *(_DWORD *)(result + 28) = 0;
  *(_DWORD *)(result + 32) = 0;
  *(_BYTE *)(result + 36) = 0;
  *(_BYTE *)(result + 836) = 0;
  *(_BYTE *)(result + 1636) = 0;
  *(_DWORD *)(result + 2440) = -1;
  *(_DWORD *)(result + 2444) = 0;
  *(_QWORD *)(result + 2448) = -1LL;
  *(_DWORD *)(result + 2456) = 0;
  *(_DWORD *)(result + 2460) = 0;
  *(_DWORD *)(result + 2464) = 0;
  *(_DWORD *)(result + 2468) = 0;
  *(_DWORD *)(result + 2472) = 0;
  *(_DWORD *)(result + 2476) = 0;
  *(_DWORD *)(result + 2480) = 0;
  *(_DWORD *)(result + 2484) = 0;
  *(_DWORD *)(result + 2488) = 0;
  *(_DWORD *)(result + 2492) = 0;
  *(_DWORD *)(result + 2496) = 0;
  *(_DWORD *)(result + 2608) = 0;
  *(_DWORD *)(result + 2500) = 0;
  *(_DWORD *)(result + 2612) = 0;
  *(_BYTE *)(result + 2616) = 0;
  *(_DWORD *)(result + 3432) = 0;
  *(_DWORD *)(result + 3436) = 0;
  *(_DWORD *)(result + 3444) = 0;
  *(_DWORD *)(result + 3448) = 0;
  *(_DWORD *)(result + 3452) = 0;
  *(_DWORD *)(result + 3456) = 0;
  *(_QWORD *)(result + 3464) = 0LL;
  *(_QWORD *)(result + 3472) = 0LL;
  *(_QWORD *)(result + 3480) = 0LL;
  *(_QWORD *)(result + 3488) = 0LL;
  *(_DWORD *)(result + 3496) = 0;
  *(_DWORD *)(result + 3500) = 0;
  *(_BYTE *)(result + 3504) = 0;
  *(_DWORD *)(result + 3904) = 0;
  *(_QWORD *)(result + 3912) = 0LL;
  *(_BYTE *)(result + 3920) = 0;
  *(_DWORD *)(result + 4720) = 0;
  *(_DWORD *)(result + 4724) = 0;
  return result;
}

//----- (0001AF4C) --------------------------------------------------------
signed int __fastcall sub_1AF4C(_DWORD *a1, signed int *a2)
{
  signed int v2; // r3
  char *v3; // r0
  signed int *v5; // [sp+8h] [bp-23Ch]
  _DWORD *v6; // [sp+Ch] [bp-238h]
  char v7; // [sp+10h] [bp-234h]
  size_t n; // [sp+210h] [bp-34h]
  struct sockaddr addr; // [sp+214h] [bp-30h]
  char s; // [sp+224h] [bp-20h]
  int v11; // [sp+228h] [bp-1Ch]
  struct in_addr *v12; // [sp+234h] [bp-10h]

  v6 = a1;
  v5 = a2;
  memset(&s, 0, 0x10u);
  n = 16;
  if ( getsockname(*(_DWORD *)(*v6 + 20), &addr, &n) == -1 )
    return 0;
  v12 = (struct in_addr *)&addr;
  if ( addr.sa_family != 2 )
    return 0;
  if ( getsockopt(*(_DWORD *)(*v6 + 20), 0, 80, &s, &n) )
    return 0;
  if ( v11 == v12[1].s_addr )
    return 0;
  if ( v6[2] && !strncasecmp((const char *)v6[2], "CaptiveNetworkSupport", 0x15u) )
  {
    *v5 = -1;
    v2 = -1;
  }
  else
  {
    v3 = inet_ntoa(v12[1]);
    sprintf(&v7, "http://%s/smart404/index.php", v3);
    v6[624] = 302;
    v6[616] = &v7;
    *(_DWORD *)(*v6 + 272) = 0;
    *v5 = sub_1A380(v6);
    v2 = 1;
  }
  return v2;
}

//----- (0001B0F8) --------------------------------------------------------
int __fastcall sub_1B0F8(int a1)
{
  signed int v1; // r3
  int v2; // r4
  signed int v3; // r0
  int v5; // [sp+4h] [bp-20h]
  int v6; // [sp+Ch] [bp-18h]
  int v7; // [sp+10h] [bp-14h]
  int v8; // [sp+14h] [bp-10h]

  v5 = a1;
  v8 = sub_19150(a1);
  if ( sub_1AF4C((_DWORD *)v5, &v6) )
    return v6;
  if ( v8 == -1 )
    return -1;
  if ( v8 )
  {
    sub_182E4((_DWORD *)v5);
    if ( !*(_DWORD *)(v5 + 2496) || *(_DWORD *)(v5 + 2612) )
    {
      v7 = 0;
      do
      {
        if ( *(_DWORD *)(v5 + 2612) )
        {
          *(_DWORD *)(v5 + 3432) = sub_17E64(
                                     (char *)(v5 + 836),
                                     *(unsigned __int8 **)(v5 + 2612),
                                     *(_DWORD *)(v5 + 20),
                                     0x31Fu);
          *(_DWORD *)(v5 + 2612) = 0;
        }
        if ( dword_29F58 )
          sub_14604((int *)"process_request: %s", v5 + 836);
        v8 = sub_184EC(v5);
        ++v7;
      }
      while ( v7 <= 2 && v8 == 1 && *(_DWORD *)(v5 + 2612) );
    }
  }
  if ( *(_DWORD *)(v5 + 2496) )
  {
    if ( sub_1A380((_DWORD *)v5) == -1 )
    {
      sub_14604((int *)"cannot prepare reply for client");
      return -1;
    }
  }
  else if ( *(_DWORD *)(v5 + 4720) )
  {
    if ( dword_29F58 )
      sub_14604((int *)"sending 100-continue");
    v2 = *(_DWORD *)v5 + 188;
    v3 = sub_1A08C(100);
    sub_1A2C0(v2, "HTTP/1.1 %s\r\n\r\n", v3);
  }
  if ( dword_29F58 )
    sub_14604((int *)"process_request finished (s=%d)", v8);
  if ( v8 < 0 )
    v1 = -1;
  else
    v1 = 0;
  return v1;
}
// 29F58: using guessed type int dword_29F58;

//----- (0001B338) --------------------------------------------------------
signed int __fastcall sub_1B338(int *a1)
{
  signed int v1; // r3
  int *v3; // [sp+4h] [bp-10h]
  signed int v4; // [sp+Ch] [bp-8h]

  v3 = a1;
  if ( dword_29F58 )
    sub_14604((int *)"cgi_error");
  v3[624] = 500;
  v3[1181] = 0;
  sub_1686C((int)v3);
  v4 = sub_1A380(v3);
  if ( v4 == -1 )
  {
    sub_14604((int *)"prepare_reply failed in cgi_error");
    sub_F5FC(*v3);
    v1 = -1;
  }
  else
  {
    sub_F38C((int *)*v3, 4);
    v1 = v4;
  }
  return v1;
}
// 29F58: using guessed type int dword_29F58;

//----- (0001B3EC) --------------------------------------------------------
signed int __fastcall sub_1B3EC(unsigned __int8 *a1, _BYTE *a2)
{
  char v3; // r2
  char v4; // r3
  bool v5; // r3
  _BYTE *v7; // [sp+0h] [bp-1Ch]
  unsigned __int8 *v8; // [sp+4h] [bp-18h]
  unsigned __int8 *v9; // [sp+4h] [bp-18h]
  signed int v10; // [sp+Ch] [bp-10h]
  signed int v11; // [sp+10h] [bp-Ch]
  char v12; // [sp+17h] [bp-5h]

  v8 = a1;
  v7 = a2;
  while ( 1 )
  {
    v12 = *v8;
    v5 = *v8++ != 0;
    if ( !v5 )
      break;
    if ( v12 == 37 )
    {
      v11 = *v8;
      v9 = v8 + 1;
      if ( !((*_ctype_b_loc())[v11] & 0x10) )
        return -1;
      v10 = *v9;
      v8 = v9 + 1;
      if ( !((*_ctype_b_loc())[v10] & 0x10) )
        return -1;
      if ( v11 > 57 )
        v3 = 16 * ((v11 & 7) + 9);
      else
        v3 = 16 * (v11 - 48);
      if ( v10 > 57 )
        v4 = (v10 & 7) + 9;
      else
        v4 = v10 - 48;
      *v7++ = v3 + v4;
    }
    else
    {
      *v7++ = v12;
    }
  }
  *v7 = 0;
  return 0;
}

//----- (0001B5A8) --------------------------------------------------------
signed int __fastcall sub_1B5A8(unsigned __int8 *a1, _BYTE *a2, int a3)
{
  char v4; // r2
  char v5; // r3
  bool v6; // r3
  bool v7; // r3
  int v9; // [sp+4h] [bp-20h]
  _BYTE *v10; // [sp+8h] [bp-1Ch]
  unsigned __int8 *v11; // [sp+Ch] [bp-18h]
  unsigned __int8 *v12; // [sp+Ch] [bp-18h]
  signed int v13; // [sp+14h] [bp-10h]
  signed int v14; // [sp+18h] [bp-Ch]
  char v15; // [sp+1Fh] [bp-5h]

  v11 = a1;
  v10 = a2;
  v9 = a3;
  while ( 1 )
  {
    v6 = v9-- != 0;
    if ( !v6 )
      break;
    v15 = *v11;
    v7 = *v11++ != 0;
    if ( !v7 )
      break;
    if ( v15 == 37 )
    {
      v14 = *v11;
      v12 = v11 + 1;
      if ( !((*_ctype_b_loc())[v14] & 0x10) )
        return -1;
      v13 = *v12;
      v11 = v12 + 1;
      if ( !((*_ctype_b_loc())[v13] & 0x10) )
        return -1;
      if ( v14 > 57 )
        v4 = 16 * ((v14 & 7) + 9);
      else
        v4 = 16 * (v14 - 48);
      if ( v13 > 57 )
        v5 = (v13 & 7) + 9;
      else
        v5 = v13 - 48;
      *v10++ = v4 + v5;
    }
    else
    {
      *v10++ = v15;
    }
  }
  *v10 = 0;
  return 0;
}

//----- (0001B790) --------------------------------------------------------
signed int __fastcall sub_1B790(const char *a1)
{
  char *s; // ST04_4
  char buf; // [sp+Ch] [bp-110h]
  char dest; // [sp+8Ch] [bp-90h]
  size_t n; // [sp+10Ch] [bp-10h]
  char *v7; // [sp+110h] [bp-Ch]
  void *src; // [sp+114h] [bp-8h]
  char v9[4]; // [sp+118h] [bp-4h]

  s = (char *)a1;
  src = strchr(a1, 91);
  v7 = strchr(s, 93);
  if ( !src || !v7 )
    return -22;
  src = (char *)src + 1;
  n = v7 - (_BYTE *)src;
  if ( v7 - (_BYTE *)src <= 0 || n > 0x7F )
    return -22;
  memcpy(&dest, src, n);
  v9[n - 140] = 0;
  if ( inet_pton(10, &dest, &buf) != 1 )
    return -22;
  v7[1] = 0;
  return 0;
}
// 1B790: using guessed type char var_4[4];

//----- (0001B89C) --------------------------------------------------------
signed int __fastcall sub_1B89C(const char *a1)
{
  signed int result; // r0
  char *v2; // [sp+4h] [bp-10h]
  int c; // [sp+8h] [bp-Ch]
  int i; // [sp+Ch] [bp-8h]

  v2 = (char *)a1;
  result = sub_1B790(a1);
  if ( result )
  {
    for ( i = 0; ; i = c )
    {
      c = (unsigned __int8)*v2;
      if ( !*v2 )
        break;
      if ( c == 58 )
      {
        *v2 = 0;
        break;
      }
      result = tolower(c);
      *v2++ = result;
    }
    if ( i == 46 )
      *(v2 - 1) = 0;
  }
  return result;
}

//----- (0001B958) --------------------------------------------------------
signed int sub_1B958()
{
  if ( !dword_29EFC )
    return 0;
  dword_29EBC = (int)malloc(16 * dword_29EFC);
  if ( dword_29EBC )
    return 0;
  sub_14604((int *)&unk_215D8);
  return -1;
}
// 29EBC: using guessed type int dword_29EBC;
// 29EFC: using guessed type int dword_29EFC;

//----- (0001B9DC) --------------------------------------------------------
signed int sub_1B9DC()
{
  sub_14604((int *)&unk_215F8);
  return -1;
}

//----- (0001B9FC) --------------------------------------------------------
signed int __fastcall sub_1B9FC(int a1, int a2)
{
  signed int v2; // r3
  int v3; // r3
  char *v4; // r0
  int v6; // [sp+0h] [bp-94h]
  _DWORD *v7; // [sp+0h] [bp-94h]
  int v8; // [sp+4h] [bp-90h]
  char *endptr; // [sp+Ch] [bp-88h]
  char v10; // [sp+10h] [bp-84h]
  unsigned __int64 v11; // [sp+38h] [bp-5Ch]
  int v12; // [sp+44h] [bp-50h]
  int v13; // [sp+48h] [bp-4Ch]
  int v14; // [sp+4Ch] [bp-48h]
  unsigned int v15; // [sp+50h] [bp-44h]
  unsigned int v16; // [sp+54h] [bp-40h]
  unsigned int v17; // [sp+58h] [bp-3Ch]
  int v18; // [sp+5Ch] [bp-38h]
  int v19; // [sp+60h] [bp-34h]
  int v20; // [sp+64h] [bp-30h]
  int v21; // [sp+68h] [bp-2Ch]
  char *nptr; // [sp+6Ch] [bp-28h]
  char *s1; // [sp+70h] [bp-24h]
  char *i; // [sp+74h] [bp-20h]
  unsigned int v25; // [sp+78h] [bp-1Ch]
  unsigned int v26; // [sp+7Ch] [bp-18h]
  unsigned int v27; // [sp+80h] [bp-14h]
  unsigned int j; // [sp+84h] [bp-10h]
  int v29; // [sp+88h] [bp-Ch]
  int v30; // [sp+8Ch] [bp-8h]

  v8 = a1;
  v6 = a2;
  v27 = 0;
  s1 = 0;
  v16 = 0;
  nptr = 0;
  v21 = 0;
  v20 = 0;
  v18 = 0;
  v26 = 0;
  v15 = 0;
  v25 = 0;
  v29 = 0;
  v17 = 0;
  v30 = 0;
  v19 = 1;
  for ( i = *(char **)(a1 + 244); *(_DWORD *)(v8 + 252) > (unsigned int)i; ++i )
  {
    v14 = (unsigned __int8)*i;
    if ( v29 )
    {
      if ( v29 == 1 )
      {
        ++v17;
        switch ( v14 )
        {
          case 9:
          case 32:
          case 58:
            if ( !v16 )
              v16 = v17;
            break;
          case 10:
          case 13:
            v30 = 1;
            v29 = 0;
            break;
          default:
            if ( v16 && !nptr )
              nptr = i;
            break;
        }
      }
    }
    else if ( v14 != 10 && v14 != 13 )
    {
      s1 = i;
      v16 = 0;
      nptr = 0;
      v17 = 0;
      v29 = 1;
    }
    if ( v30 )
    {
      if ( nptr || !strncasecmp(s1, (const char *)&unk_21618, 3u) )
      {
        if ( v19 && v16 > 7 && !strncmp(s1, "HTTP/", 5u) )
        {
          v26 = v27;
          v21 = 1;
        }
        else
        {
          switch ( v16 )
          {
            case 4u:
              if ( !strncasecmp(s1, "Date", 4u) )
                v30 = 0;
              break;
            case 6u:
              if ( !strncasecmp(s1, "Server", 6u) )
              {
                v30 = 0;
              }
              else if ( !strncasecmp(s1, "Status", 6u) )
              {
                if ( v21 )
                {
                  v30 = 0;
                }
                else
                {
                  v26 = v27;
                  v21 = 1;
                }
              }
              break;
            case 8u:
              if ( !strncasecmp(s1, "Location", 8u) )
              {
                if ( v20 )
                {
                  v30 = 0;
                }
                else
                {
                  v15 = v27;
                  v20 = 1;
                }
              }
              break;
            case 0xAu:
              if ( !strncasecmp(s1, "Connection", 0xAu) )
                v30 = 0;
              break;
            case 0xEu:
              if ( !strncasecmp(s1, "Content-Length", 0xEu) )
              {
                if ( v18 )
                {
                  v30 = 0;
                }
                else
                {
                  v25 = v27;
                  v18 = 1;
                }
              }
              break;
            case 0x11u:
              if ( strncasecmp(s1, "Transfer-Encoding", 0x11u) )
                break;
              sub_14604((int *)"convert_cgi_headers: script sent Transfer-Encoding!?!?");
              return -1;
            default:
              break;
          }
        }
      }
      else
      {
        v30 = 0;
      }
      if ( v19 )
        v19 = 0;
      if ( v30 )
      {
        if ( dword_29EFC <= v27 )
        {
          sub_14604((int *)"convert_cgi_headers: too many header lines");
          return -1;
        }
        *(_DWORD *)(dword_29EBC + 16 * v27) = s1;
        *(_DWORD *)(dword_29EBC + 16 * v27 + 8) = nptr;
        *(_DWORD *)(dword_29EBC + 16 * v27 + 4) = v16;
        *(_DWORD *)(dword_29EBC + 16 * v27++ + 12) = v17;
        v30 = 0;
      }
      else
      {
        sub_14604((int *)"convert_cgi_headers: disallowing header \"%.*s\"", v17, s1);
      }
    }
  }
  if ( v29 )
  {
    sub_14604((int *)"convert_cgi_headers: s=%d!?", v29);
    v2 = -1;
  }
  else
  {
    v13 = v8 + 188;
    if ( !v20 || v21 )
    {
      if ( v21 )
      {
        v29 = atoi(*(const char **)(dword_29EBC + 16 * v26 + 8));
        if ( v29 <= 199 || v29 > 599 )
        {
          sub_14604(
            (int *)"convert_cgi_headers: illegal header line \"%.*s\"",
            *(_DWORD *)(dword_29EBC + 16 * v26 + 12),
            *(_DWORD *)(dword_29EBC + 16 * v26));
          return -1;
        }
        if ( v29 == 204 || v29 == 304 )
        {
          if ( v18 )
          {
            sub_14604((int *)"convert_cgi_headers: script should not send content-length with status %d", v29);
            return -1;
          }
          *(_DWORD *)(v8 + 348) = 1;
          *(_DWORD *)(v8 + 344) = 0;
        }
        v12 = *(_DWORD *)(dword_29EBC + 16 * v26 + 12)
            + *(_DWORD *)(dword_29EBC + 16 * v26)
            - *(_DWORD *)(dword_29EBC + 16 * v26 + 8);
        if ( sub_1A2C0(v13, "HTTP/1.1 %.*s\r\n", v12, *(_DWORD *)(dword_29EBC + 16 * v26 + 8), v6) == -1 )
          return sub_1B9DC();
      }
      else
      {
        v29 = 200;
        if ( sub_1A2C0(v13, "HTTP/1.1 200 OK\r\n") == -1 )
          return sub_1B9DC();
      }
    }
    else
    {
      v29 = 302;
      if ( sub_1A2C0(v13, "HTTP/1.1 302 Moved\r\n") == -1 )
        return sub_1B9DC();
    }
    if ( v18 )
    {
      nptr = *(char **)(dword_29EBC + 16 * v25 + 8);
      if ( *nptr == 45 )
      {
        sub_14604(
          (int *)"convert_cgi_headers: illegal content-length header \"%.*s\"",
          *(_DWORD *)(dword_29EBC + 16 * v25 + 12),
          *(_DWORD *)(dword_29EBC + 16 * v25));
        return -1;
      }
      v11 = strtoull(nptr, &endptr, 10);
      if ( endptr != nptr )
      {
        while ( *endptr != 10 && (*endptr == 32 || *endptr == 9 || *endptr == 13) )
          ++endptr;
      }
      if ( *endptr != 10 )
      {
        sub_14604(
          (int *)"convert_cgi_headers: illegal content-length header \"%.*s\"",
          *(_DWORD *)(dword_29EBC + 16 * v25 + 12),
          *(_DWORD *)(dword_29EBC + 16 * v25));
        return -1;
      }
      *(_DWORD *)(v8 + 344) = 0;
      *(_DWORD *)(v8 + 352) = 1;
      *(_QWORD *)(v8 + 360) = v11;
      *(_DWORD *)(*(_DWORD *)(v8 + 12) + 2440) = 0;
      v3 = HIDWORD(v11);
      *(_QWORD *)(*(_DWORD *)(v8 + 12) + 2448) = v11;
    }
    else
    {
      v3 = *(_DWORD *)(*(_DWORD *)(v8 + 12) + 2488);
      if ( !v3 )
      {
        v3 = *(_DWORD *)(v8 + 348);
        if ( !v3 )
        {
          v3 = v8;
          *(_DWORD *)(v8 + 272) = 0;
        }
      }
    }
    if ( sub_1A2C0(v13, "Server: %s\r\n", 131804, v3, v6) == -1 )
    {
      v2 = sub_1B9DC();
    }
    else
    {
      v4 = sub_16324(dword_29F24, &v10);
      if ( sub_1A2C0(v13, "Date: %s\r\n", v4) == -1 )
      {
        v2 = sub_1B9DC();
      }
      else if ( *(_DWORD *)(v8 + 344) && sub_1A2C0(v13, "Transfer-Encoding: chunked\r\n") == -1 )
      {
        v2 = sub_1B9DC();
      }
      else if ( *(_DWORD *)(*(_DWORD *)(v8 + 12) + 2488)
             || !*(_DWORD *)(v8 + 272)
             || sub_1A2C0(v13, "Connection: keep-alive\r\n") != -1 )
      {
        if ( !*(_DWORD *)(*(_DWORD *)(v8 + 12) + 2488)
          || *(_DWORD *)(v8 + 272)
          || sub_1A2C0(v13, "Connection: close\r\n") != -1 )
        {
          for ( j = 0; j < v27; ++j )
          {
            if ( (!v21 || j != v26)
              && sub_1A2C0(v13, "%.*s\r\n", *(_DWORD *)(dword_29EBC + 16 * j + 12), *(_DWORD *)(dword_29EBC + 16 * j)) == -1 )
            {
              return sub_1B9DC();
            }
          }
          if ( sub_1A2C0(v13, "\r\n") == -1 )
          {
            v2 = sub_1B9DC();
          }
          else
          {
            *v7 = v29;
            v2 = 0;
          }
        }
        else
        {
          v2 = sub_1B9DC();
        }
      }
      else
      {
        v2 = sub_1B9DC();
      }
    }
  }
  return v2;
}
// 29EBC: using guessed type int dword_29EBC;
// 29EFC: using guessed type int dword_29EFC;
// 29F24: using guessed type int dword_29F24;

//----- (0001C674) --------------------------------------------------------
signed int __fastcall sub_1C674(int a1)
{
  signed int v1; // r3
  int v3; // [sp+Ch] [bp-10h]
  ssize_t v4; // [sp+10h] [bp-Ch]
  int nbytes; // [sp+14h] [bp-8h]

  v3 = a1;
  nbytes = *(_DWORD *)(a1 + 220) - *(_DWORD *)(a1 + 232);
  if ( (unsigned __int64)(unsigned int)nbytes > *(_QWORD *)(a1 + 336) )
    nbytes = *(_QWORD *)(a1 + 336);
  if ( nbytes )
  {
    v4 = read(*(_DWORD *)(a1 + 20), *(void **)(a1 + 232), nbytes);
    if ( dword_29F58 )
      sub_14604(
        (int *)"readfromclient: %d %zd %zu %zd",
        *(_DWORD *)(v3 + 20),
        *(_DWORD *)(v3 + 232) - *(_DWORD *)(v3 + 216),
        nbytes,
        v4);
    if ( v4 == -1 )
    {
      if ( *_errno_location() == 11 )
      {
        v1 = 0;
      }
      else
      {
        if ( dword_29F58 )
          sub_14840("read");
        sub_F5FC(v3);
        v1 = -1;
      }
    }
    else if ( v4 )
    {
      *(_DWORD *)(v3 + 156) = dword_29F24;
      *(_QWORD *)(v3 + 288) += v4;
      *(_DWORD *)(v3 + 232) += v4;
      *(_QWORD *)(v3 + 336) -= v4;
      v1 = 0;
    }
    else
    {
      sub_14604((int *)"readfromclient: client went away while posting data");
      sub_F5FC(v3);
      v1 = -1;
    }
  }
  else
  {
    sub_14604((int *)"readfromclient: bytestoread is zero!");
    v1 = 0;
  }
  return v1;
}
// 29F24: using guessed type int dword_29F24;
// 29F58: using guessed type int dword_29F58;

//----- (0001C8A0) --------------------------------------------------------
signed int __fastcall sub_1C8A0(int a1)
{
  signed int v1; // r3
  int v2; // r1
  int v4; // [sp+Ch] [bp-10h]
  ssize_t v5; // [sp+10h] [bp-Ch]
  int nbytes; // [sp+14h] [bp-8h]

  v4 = a1;
  nbytes = *(_DWORD *)(a1 + 248) - *(_DWORD *)(a1 + 260);
  if ( *(_DWORD *)(a1 + 352) && (unsigned __int64)(unsigned int)nbytes > *(_QWORD *)(a1 + 360) )
    nbytes = *(_QWORD *)(a1 + 360);
  if ( nbytes )
  {
    v5 = read(*(_DWORD *)(a1 + 24), *(void **)(a1 + 260), nbytes);
    if ( dword_29F58 )
      sub_14604(
        (int *)"readfromchild: %d %zd %zu %zd",
        *(_DWORD *)(v4 + 24),
        *(_DWORD *)(v4 + 260) - *(_DWORD *)(v4 + 244),
        nbytes,
        v5);
    if ( v5 != -1 )
    {
      if ( v5 )
      {
        *(_DWORD *)(v4 + 156) = dword_29F24;
        *(_DWORD *)(v4 + 260) += v5;
        if ( *(_DWORD *)(v4 + 352) )
        {
          *(_QWORD *)(v4 + 360) -= v5;
          if ( !*(_QWORD *)(v4 + 360) )
            *(_BYTE *)(v4 + 264) = 2;
        }
      }
      else
      {
        if ( *(_DWORD *)(v4 + 328) != 2 )
        {
          sub_14604(
            (int *)"readfromchild: premature end of script headers (ipp=%zd)",
            *(_DWORD *)(v4 + 260) - *(_DWORD *)(v4 + 244));
          sub_1B338(*(int **)(v4 + 12));
          return -1;
        }
        if ( *(_DWORD *)(v4 + 352) )
        {
          sub_14604((int *)"readfromchild: script went away (pmax=%lld)", v2, *(_QWORD *)(v4 + 360));
          sub_F5FC(v4);
          return -1;
        }
        *(_DWORD *)(v4 + 156) = dword_29F24;
        *(_BYTE *)(v4 + 264) = 2;
      }
      return 0;
    }
    if ( *_errno_location() == 11 )
    {
      v1 = 0;
    }
    else
    {
      if ( dword_29F58 )
        sub_14840("read");
      sub_F5FC(v4);
      v1 = -1;
    }
  }
  else
  {
    sub_14604((int *)"readfromchild: bytestoread is zero!");
    v1 = 0;
  }
  return v1;
}
// 29F24: using guessed type int dword_29F24;
// 29F58: using guessed type int dword_29F58;

//----- (0001CB8C) --------------------------------------------------------
signed int __fastcall sub_1CB8C(int a1)
{
  int v1; // r2
  signed int v2; // r3
  int v4; // [sp+Ch] [bp-10h]
  int n; // [sp+10h] [bp-Ch]
  ssize_t v6; // [sp+14h] [bp-8h]

  v4 = a1;
  v1 = *(_DWORD *)(a1 + 204);
  n = v1 - *(_DWORD *)(a1 + 196);
  if ( v1 == *(_DWORD *)(a1 + 196) )
  {
    sub_14604((int *)"writetoclient: bytestowrite is zero!");
    v2 = 0;
  }
  else
  {
    if ( *(_DWORD *)(*(_DWORD *)(a1 + 16) + 48) == 2 )
    {
      v6 = v1 - *(_DWORD *)(a1 + 196);
      sub_14604((int *)"%s: ignore the response to [%s]", 137992, a1 + 92);
    }
    else
    {
      v6 = write(*(_DWORD *)(a1 + 20), *(const void **)(a1 + 196), n);
    }
    if ( dword_29F58 )
      sub_14604(
        (int *)"writetoclient: %d %zd %zu %zd",
        *(_DWORD *)(v4 + 20),
        *(_DWORD *)(v4 + 196) - *(_DWORD *)(v4 + 188),
        n,
        v6);
    if ( v6 == -1 )
    {
      if ( *_errno_location() == 11 )
      {
        v2 = 0;
      }
      else
      {
        if ( dword_29F58 )
          sub_14840("write");
        sub_F5FC(v4);
        v2 = -1;
      }
    }
    else
    {
      *(_DWORD *)(v4 + 156) = dword_29F24;
      *(_QWORD *)(v4 + 296) += v6;
      *(_DWORD *)(v4 + 196) += v6;
      if ( *(_DWORD *)(v4 + 196) == *(_DWORD *)(v4 + 204) )
      {
        *(_DWORD *)(v4 + 204) = *(_DWORD *)(v4 + 188);
        *(_DWORD *)(v4 + 196) = *(_DWORD *)(v4 + 204);
      }
      v2 = 0;
    }
  }
  return v2;
}
// 29F24: using guessed type int dword_29F24;
// 29F58: using guessed type int dword_29F58;

//----- (0001CD88) --------------------------------------------------------
signed int __fastcall sub_1CD88(int a1)
{
  int v1; // r2
  signed int v2; // r3
  _DWORD *v4; // [sp+Ch] [bp-10h]
  ssize_t v5; // [sp+10h] [bp-Ch]
  int n; // [sp+14h] [bp-8h]

  v4 = (_DWORD *)a1;
  v1 = *(_DWORD *)(a1 + 232);
  n = v1 - *(_DWORD *)(a1 + 224);
  if ( v1 == *(_DWORD *)(a1 + 224) )
  {
    sub_14604((int *)"writetochild: bytestowrite is zero!");
    v2 = 0;
  }
  else
  {
    v5 = write(*(_DWORD *)(a1 + 24), *(const void **)(a1 + 224), n);
    if ( dword_29F58 )
      sub_14604((int *)"writetochild: %d %zd %zu %zd", v4[6], v4[56] - v4[54], n, v5);
    if ( v5 == -1 )
    {
      if ( *_errno_location() == 11 )
      {
        v2 = 0;
      }
      else
      {
        if ( dword_29F58 )
          sub_14840("write");
        sub_F5FC((int)v4);
        v2 = -1;
      }
    }
    else
    {
      v4[39] = dword_29F24;
      v4[56] += v5;
      if ( v4[56] == v4[58] )
      {
        v4[58] = v4[54];
        v4[56] = v4[58];
      }
      v2 = 0;
    }
  }
  return v2;
}
// 29F24: using guessed type int dword_29F24;
// 29F58: using guessed type int dword_29F58;

//----- (0001CF18) --------------------------------------------------------
signed int __fastcall sub_1CF18(_DWORD *a1)
{
  char *v1; // r3
  _DWORD *v4; // [sp+4h] [bp-10h]
  char v5; // [sp+Bh] [bp-9h]
  signed int v6; // [sp+Ch] [bp-8h]

  v4 = a1;
  v6 = a1[82];
  while ( a1[63] < a1[65] && v6 != 2 )
  {
    v1 = (char *)a1[63];
    v5 = *v1;
    a1[63] = v1 + 1;
    if ( v6 )
    {
      if ( v6 == 1 )
      {
        if ( v5 == 10 )
        {
          v6 = 2;
        }
        else if ( v5 != 13 )
        {
          v6 = 0;
        }
      }
    }
    else if ( v5 == 10 )
    {
      v6 = 1;
    }
  }
  a1[82] = v6;
  if ( v6 != 2 )
  {
    if ( a1[63] == a1[62] )
    {
      sub_14604((int *)"scanlflf: buffer full");
      sub_1B338((int *)v4[3]);
      return -1;
    }
    return 0;
  }
  if ( sub_1B9FC((int)a1, a1[3] + 2496) != -1 )
  {
    if ( v4[87] )
    {
      *((_BYTE *)v4 + 264) = 3;
    }
    else if ( v4[88] )
    {
      if ( v4[63] < v4[65] )
      {
        if ( v4[65] <= v4[63] + (unsigned int)*((_QWORD *)v4 + 45) )
        {
          *((_QWORD *)v4 + 45) -= v4[65] - v4[63];
        }
        else
        {
          sub_14604((int *)"extra garbage from script ignored");
          v4[65] = v4[63] + *((unsigned __int64 *)v4 + 45);
          *((_QWORD *)v4 + 45) = 0LL;
        }
      }
      if ( !*((_QWORD *)v4 + 45) )
        *((_BYTE *)v4 + 264) = 2;
    }
    return 0;
  }
  sub_1B338((int *)v4[3]);
  return -1;
}

//----- (0001D1B0) --------------------------------------------------------
_DWORD *__fastcall sub_1D1B0(_DWORD *result)
{
  _DWORD *v1; // [sp+4h] [bp-28h]
  char s; // [sp+Ch] [bp-20h]
  size_t v3; // [sp+1Ch] [bp-10h]
  size_t n; // [sp+20h] [bp-Ch]
  size_t v5; // [sp+24h] [bp-8h]

  v1 = result;
  if ( result[87] )
  {
    result[65] = result[61];
    result[63] = result[65];
  }
  else
  {
    v3 = result[48] - result[51];
    v5 = result[65] - result[63];
    if ( v5 > v3 )
      v5 = v3;
    if ( v5 && result[86] )
    {
      result = (_DWORD *)sprintf(&s, "%lx\r\n", v5);
      n = (size_t)result;
      if ( (unsigned int)result + 2 < v3 )
      {
        if ( v5 + n + 2 > v3 )
        {
          v5 = v5 - n - 2;
          n = sprintf(&s, "%lx\r\n", v5);
        }
        result = memcpy((void *)v1[51], &s, n);
        v1[51] += n;
      }
      else
      {
        v5 = 0;
      }
    }
    if ( v5 )
    {
      result = memcpy((void *)v1[51], (const void *)v1[63], v5);
      v1[51] += v5;
      v1[63] += v5;
      if ( v1[63] == v1[65] )
      {
        v1[65] = v1[61];
        v1[63] = v1[65];
      }
      if ( v1[86] )
      {
        result = memcpy((void *)v1[51], "\r\n", 2u);
        v1[51] += 2;
      }
    }
  }
  return result;
}

//----- (0001D408) --------------------------------------------------------
void **__fastcall sub_1D408(void **result)
{
  void **v1; // [sp+4h] [bp-8h]

  v1 = result;
  if ( result[86] )
  {
    if ( (_BYTE *)result[48] - (_BYTE *)result[51] > 4 )
    {
      result = (void **)memcpy(result[51], "0\r\n\r\n", 5u);
      v1[51] = (char *)v1[51] + 5;
      *((_BYTE *)v1 + 264) = 3;
    }
  }
  else
  {
    *((_BYTE *)result + 264) = 3;
  }
  return result;
}

//----- (0001D49C) --------------------------------------------------------
bool __fastcall sub_1D49C(int a1)
{
  if ( *(_BYTE *)(a1 + 264) != 3 )
    return 0;
  if ( *(_DWORD *)(a1 + 204) > *(_DWORD *)(a1 + 196) )
    return 0;
  if ( *(_DWORD *)(a1 + 260) <= *(_DWORD *)(a1 + 252) )
    return *(_BYTE *)(a1 + 236) != 1 || !*(_QWORD *)(a1 + 336);
  return 0;
}

//----- (0001D54C) --------------------------------------------------------
int *__fastcall sub_1D54C(_DWORD *a1)
{
  __int16 v1; // r3
  __int16 v2; // r3
  int *result; // r0
  _BOOL4 v4; // r3
  _BOOL4 v5; // r3
  int v6; // [sp+4h] [bp-18h]
  _BOOL4 v7; // [sp+Ch] [bp-10h]
  _BOOL4 v8; // [sp+10h] [bp-Ch]
  char v9; // [sp+14h] [bp-8h]
  __int16 v10; // [sp+16h] [bp-6h]

  v6 = (int)a1;
  if ( a1[69] == -1 )
    v1 = 0;
  else
    v1 = *(_WORD *)(dword_29F48 + 8 * a1[69] + 6);
  v10 = v1;
  if ( a1[70] == -1 )
    v2 = 0;
  else
    v2 = *(_WORD *)(dword_29F48 + 8 * a1[70] + 6);
  v9 = v2;
  if ( v10 & 8 || v10 == 16 )
    return sub_F5FC((int)a1);
  if ( v2 & 8 || v2 == 16 )
    return sub_F5FC((int)a1);
  v4 = v10 & 4 || a1[51] == a1[47];
  v8 = v4;
  v5 = v9 & 4 || a1[58] == a1[54];
  v7 = v5;
  if ( !(v10 & 1) || (result = (int *)sub_1C674((int)a1), result != (int *)-1) )
  {
    if ( !(v9 & 1) || (result = (int *)sub_1C8A0(v6), result != (int *)-1) )
    {
      if ( !*(_DWORD *)(v6 + 260)
        || *(_DWORD *)(v6 + 328) == 2
        || (result = (int *)sub_1CF18((_DWORD *)v6), result != (int *)-1) )
      {
        if ( *(_DWORD *)(v6 + 328) == 2 && *(_DWORD *)(v6 + 252) < *(_DWORD *)(v6 + 260) )
          sub_1D1B0((_DWORD *)v6);
        if ( *(_BYTE *)(v6 + 264) == 2 )
          sub_1D408((void **)v6);
        if ( *(_DWORD *)(v6 + 204) <= *(_DWORD *)(v6 + 196)
          || !v8
          || (result = (int *)sub_1CB8C(v6), result != (int *)-1) )
        {
          if ( *(_DWORD *)(v6 + 232) <= *(_DWORD *)(v6 + 224)
            || !v7
            || (result = (int *)sub_1CD88(v6), result != (int *)-1) )
          {
            result = (int *)sub_1D49C(v6);
            if ( result )
            {
              if ( *(_DWORD *)(v6 + 272) )
              {
                if ( *(_DWORD *)(v6 + 232) <= *(_DWORD *)(v6 + 224) )
                {
                  result = (int *)sub_F4DC(v6);
                }
                else
                {
                  sub_14604((int *)"client_input is not empty");
                  result = sub_F5FC(v6);
                }
              }
              else
              {
                result = sub_F5FC(v6);
              }
            }
          }
        }
      }
    }
  }
  return result;
}
// 29F48: using guessed type int dword_29F48;

//----- (0001D868) --------------------------------------------------------
int *__fastcall sub_1D868(int a1, int a2)
{
  int *result; // r0
  int fd; // [sp+0h] [bp-1Ch]
  int v4; // [sp+4h] [bp-18h]
  int v5; // [sp+Ch] [bp-10h]
  int v6; // [sp+10h] [bp-Ch]
  int n; // [sp+14h] [bp-8h]

  v4 = a1;
  fd = a2;
  v5 = *(_DWORD *)(a1 + 12);
  *(_DWORD *)(a1 + 232) = *(_DWORD *)(a1 + 216);
  *(_DWORD *)(v4 + 224) = *(_DWORD *)(v4 + 232);
  *(_DWORD *)(v4 + 204) = *(_DWORD *)(v4 + 188);
  *(_DWORD *)(v4 + 196) = *(_DWORD *)(v4 + 204);
  *(_DWORD *)(v4 + 260) = *(_DWORD *)(v4 + 244);
  *(_DWORD *)(v4 + 252) = *(_DWORD *)(v4 + 260);
  *(_BYTE *)(a1 + 264) = 1;
  *(_DWORD *)(a1 + 328) = 1;
  if ( *(_DWORD *)(a1 + 24) != -1 )
    close(*(_DWORD *)(a1 + 24));
  *(_DWORD *)(v4 + 24) = fd;
  *(_DWORD *)(v4 + 344) = *(_DWORD *)(v5 + 2488) > 0;
  *(_DWORD *)(v4 + 348) = *(_DWORD *)(v5 + 2492) == 1;
  *(_DWORD *)(v4 + 352) = 0;
  *(_QWORD *)(v4 + 360) = 0LL;
  if ( *(_QWORD *)(v5 + 3912) )
  {
    *(_BYTE *)(v4 + 236) = 1;
    *(_QWORD *)(v4 + 336) = *(_QWORD *)(v5 + 3912);
    n = *(_DWORD *)(v4 + 176) - *(_DWORD *)(v4 + 172);
    if ( (unsigned __int64)(unsigned int)n <= *(_QWORD *)(v4 + 336) )
    {
      v6 = 0;
    }
    else
    {
      v6 = *(_QWORD *)(v4 + 336);
      n = *(_QWORD *)(v4 + 336);
    }
    if ( n )
    {
      if ( (unsigned int)(*(_DWORD *)(v4 + 224) + n) > *(_DWORD *)(v4 + 220) )
      {
        sub_14604((int *)"init_child: script buffer too small!");
        close(fd);
        return sub_F5FC(v4);
      }
      memmove(*(void **)(v4 + 224), *(const void **)(v4 + 172), n);
      *(_DWORD *)(v4 + 232) += n;
      *(_QWORD *)(v4 + 336) -= (unsigned int)n;
      if ( v6 )
        *(_DWORD *)(v4 + 172) += v6;
      else
        *(_DWORD *)(v4 + 176) = *(_DWORD *)(v4 + 172);
    }
  }
  else
  {
    *(_BYTE *)(v4 + 236) = 0;
    *(_QWORD *)(v4 + 336) = 0LL;
  }
  result = sub_F38C((int *)v4, 2);
  *(_DWORD *)(v4 + 276) = -1;
  *(_DWORD *)(v4 + 280) = -1;
  return result;
}

//----- (0001DB94) --------------------------------------------------------
int __fastcall sub_1DB94(int a1, int *a2)
{
  int *i; // [sp+0h] [bp-14h]
  int v4; // [sp+4h] [bp-10h]
  int *v5; // [sp+8h] [bp-Ch]
  signed __int16 v6; // [sp+Eh] [bp-6h]
  signed __int16 v7; // [sp+Eh] [bp-6h]

  v4 = a1;
  for ( i = a2; i; i = v5 )
  {
    v5 = (int *)*i;
    v6 = 0;
    if ( *((_BYTE *)i + 236) == 1 && i[58] < (unsigned int)i[55] && *((_QWORD *)i + 42) )
      v6 = 1;
    if ( i[51] > (unsigned int)i[49] || i[82] == 2 && i[63] < (unsigned int)i[65] && i[51] == i[47] )
      v6 |= 4u;
    if ( v6 )
    {
      *(_DWORD *)(dword_29F48 + 8 * v4) = i[5];
      *(_WORD *)(dword_29F48 + 8 * v4 + 4) = v6;
      i[69] = v4++;
    }
    else
    {
      i[69] = -1;
    }
    v7 = 0;
    if ( *((_BYTE *)i + 264) == 1 && i[65] < (unsigned int)i[62] && (i[86] || !i[88] || *((_QWORD *)i + 45)) )
      v7 = 1;
    if ( i[58] > (unsigned int)i[56] )
      v7 |= 4u;
    if ( v7 )
    {
      *(_DWORD *)(dword_29F48 + 8 * v4) = i[6];
      *(_WORD *)(dword_29F48 + 8 * v4 + 4) = v7;
      i[70] = v4++;
    }
    else
    {
      i[70] = -1;
    }
  }
  return v4;
}
// 29F48: using guessed type int dword_29F48;

//----- (0001E164) --------------------------------------------------------
int __fastcall sub_1E164(signed int a1)
{
  signed int v3; // [sp+4h] [bp-80h]
  struct sockaddr addr; // [sp+Ch] [bp-78h]
  int fd; // [sp+7Ch] [bp-8h]

  v3 = a1;
  fd = socket(1, 1, 0);
  if ( fd < 0 )
    return -1;
  fcntl64(fd, 2, 1);
  addr.sa_family = 1;
  if ( !v3 )
    v3 = 138012;
  snprintf(addr.sa_data, 0x6Cu, "%s", v3);
  if ( connect(fd, &addr, 0x6Eu) >= 0 )
    return fd;
  close(fd);
  return -1;
}
// 953C: using guessed type int __fastcall fcntl64(_DWORD, _DWORD, _DWORD);

//----- (0001E230) --------------------------------------------------------
int __fastcall sub_1E230(size_t n, __int16 a2, int a3, void *a4, unsigned __int16 na)
{
  signed int v5; // r3
  void *v7; // [sp+0h] [bp-24h]
  size_t fd; // [sp+Ch] [bp-18h]
  __int16 buf; // [sp+10h] [bp-14h]
  unsigned __int16 v10; // [sp+12h] [bp-12h]
  int v11; // [sp+14h] [bp-10h]
  ssize_t v12; // [sp+1Ch] [bp-8h]

  fd = n;
  v7 = a4;
  buf = a2;
  v11 = a3;
  v10 = na;
  v12 = send(n, &buf, 0xCu, 0x4000);
  if ( v12 <= 0 )
    return -1;
  v12 = send(fd, v7, na, 0x4000);
  if ( v12 > 0 )
    v5 = 0;
  else
    v5 = -1;
  return v5;
}

//----- (0001E2D4) --------------------------------------------------------
int __fastcall sub_1E2D4(unsigned int a1, FILE *a2)
{
  size_t v2; // r0
  FILE *s; // [sp+8h] [bp-49Ch]
  unsigned int fd; // [sp+Ch] [bp-498h]
  int v6; // [sp+14h] [bp-490h]
  fd_set readfds; // [sp+414h] [bp-90h]
  size_t n; // [sp+494h] [bp-10h]
  fd_set *v9; // [sp+498h] [bp-Ch]
  unsigned int i; // [sp+49Ch] [bp-8h]
  char v11[4]; // [sp+4A0h] [bp-4h]

  fd = a1;
  for ( s = a2; ; fwrite(&v6, 1u, n, s) )
  {
    do
    {
      v9 = &readfds;
      for ( i = 0; i <= 0x1F; ++i )
        v9->__fds_bits[i] = 0;
      *(_DWORD *)&v11[4 * (fd >> 5) - 140] |= 1 << (fd & 0x1F);
    }
    while ( select(fd + 1, &readfds, 0, 0, 0) < 0 || !((*(_DWORD *)&v11[4 * (fd >> 5) - 140] >> (fd & 0x1F)) & 1) );
    n = read(fd, &v6, 0x400u);
    if ( (signed int)n <= 0 )
      break;
    if ( !v11[n - 1165] )
    {
      v2 = strlen((const char *)&v6);
      fwrite(&v6, 1u, v2, s);
      return fflush(s);
    }
  }
  return fflush(s);
}
// 1E2D4: using guessed type char var_4[4];

//----- (0001E4B4) --------------------------------------------------------
unsigned int __fastcall sub_1E4B4(unsigned int a1, int a2, unsigned int a3)
{
  unsigned int v4; // [sp+Ch] [bp-A0h]
  int v5; // [sp+10h] [bp-9Ch]
  unsigned int fd; // [sp+14h] [bp-98h]
  fd_set readfds; // [sp+18h] [bp-94h]
  ssize_t v8; // [sp+98h] [bp-14h]
  fd_set *v9; // [sp+9Ch] [bp-10h]
  unsigned int i; // [sp+A0h] [bp-Ch]
  unsigned int v11; // [sp+A4h] [bp-8h]
  char v12[4]; // [sp+A8h] [bp-4h]

  fd = a1;
  v5 = a2;
  v4 = a3;
  v11 = 0;
  while ( 1 )
  {
    v9 = &readfds;
    for ( i = 0; i <= 0x1F; ++i )
      v9->__fds_bits[i] = 0;
    *(_DWORD *)&v12[4 * (fd >> 5) - 144] |= 1 << (fd & 0x1F);
    if ( select(fd + 1, &readfds, 0, 0, 0) >= 0 )
    {
      if ( (*(_DWORD *)&v12[4 * (fd >> 5) - 144] >> (fd & 0x1F)) & 1 )
      {
        v8 = read(fd, (void *)(v5 + v11), v4 - v11);
        if ( v8 <= 0 )
          break;
        v11 += v8;
        if ( !*(_BYTE *)(v5 + v11 - 1) || v4 >= v11 )
          break;
      }
    }
  }
  return v11;
}
// 1E4B4: using guessed type char var_4[4];

//----- (0001E678) --------------------------------------------------------
signed int __fastcall sub_1E678(signed int a1, __int16 a2, int a3, void *a4, unsigned __int16 a5, FILE *a6)
{
  FILE *v6; // r3
  void *v8; // [sp+8h] [bp-1Ch]
  int v9; // [sp+Ch] [bp-18h]
  __int16 v10; // [sp+12h] [bp-12h]
  int fd; // [sp+18h] [bp-Ch]
  signed int v12; // [sp+1Ch] [bp-8h]

  v9 = a3;
  v8 = a4;
  v10 = a2;
  v12 = -1;
  fd = sub_1E164(a1);
  if ( fd >= 0 )
  {
    if ( sub_1E230(fd, v10, v9, v8, a5) >= 0 )
    {
      if ( a6 )
        v6 = a6;
      else
        v6 = (FILE *)stdout;
      sub_1E2D4(fd, v6);
      v12 = 0;
    }
    close(fd);
  }
  return v12;
}
// 29E40: using guessed type int stdout;

//----- (0001E730) --------------------------------------------------------
int __fastcall sub_1E730(signed int a1, __int16 a2, int a3, void *a4, unsigned __int16 a5)
{
  void *v6; // [sp+8h] [bp-2Ch]
  int v7; // [sp+Ch] [bp-28h]
  __int16 v8; // [sp+12h] [bp-22h]
  char buf; // [sp+18h] [bp-1Ch]
  int v10; // [sp+20h] [bp-14h]
  ssize_t v11; // [sp+24h] [bp-10h]
  int fd; // [sp+28h] [bp-Ch]
  int v13; // [sp+2Ch] [bp-8h]

  v7 = a3;
  v6 = a4;
  v8 = a2;
  v13 = -1;
  fd = sub_1E164(a1);
  if ( fd >= 0 )
  {
    if ( sub_1E230(fd, v8, v7, v6, a5) >= 0 )
    {
      v11 = read(fd, &buf, 0xCu);
      v13 = v10;
    }
    close(fd);
  }
  return v13;
}

//----- (0001ED78) --------------------------------------------------------
unsigned int __fastcall sub_1ED78(unsigned int result, unsigned int a2)
{
  char v2; // r2
  unsigned int v3; // r1
  unsigned int v4; // r3
  unsigned int v5; // r2
  bool v6; // zf

  if ( a2 != 1 )
  {
    if ( a2 >= 1 )
    {
      if ( result <= a2 )
      {
        result = result == a2;
      }
      else if ( a2 & (a2 - 1) )
      {
        v2 = __clz(a2) - __clz(result);
        v3 = a2 << v2;
        v4 = 1 << v2;
        v5 = 0;
        while ( 1 )
        {
          if ( result >= v3 )
          {
            result -= v3;
            v5 |= v4;
          }
          if ( result >= v3 >> 1 )
          {
            result -= v3 >> 1;
            v5 |= v4 >> 1;
          }
          if ( result >= v3 >> 2 )
          {
            result -= v3 >> 2;
            v5 |= v4 >> 2;
          }
          if ( result >= v3 >> 3 )
          {
            result -= v3 >> 3;
            v5 |= v4 >> 3;
          }
          v6 = result == 0;
          if ( result )
          {
            v4 >>= 4;
            v6 = v4 == 0;
          }
          if ( v6 )
            break;
          v3 >>= 4;
        }
        result = v5;
      }
      else
      {
        result >>= 31 - __clz(a2);
      }
    }
    else
    {
      result = sub_1EE40();
    }
  }
  return result;
}

//----- (0001EE20) --------------------------------------------------------
unsigned int __fastcall sub_1EE20(unsigned int a1, unsigned int a2)
{
  if ( !a2 )
    JUMPOUT(&loc_1EE14);
  return sub_1ED78(a1, a2);
}

//----- (0001EE40) --------------------------------------------------------
int sub_1EE40()
{
  return raise(8);
}

//----- (0001EE50) --------------------------------------------------------
void term_proc()
{
  ;
}

#error "There were 1 decompilation failure(s) on 164 function(s)"
